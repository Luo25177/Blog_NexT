<!DOCTYPE html>
<html lang="zh-CN">
<script src="/Blog_NexT/js/snow.js"></script>
<script src="/Blog_NexT/js/forbiden.js"></script>
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.1.1">
  <link rel="icon" type="image/png" sizes="32x32" href="/Blog_NexT/images/logo4.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/Blog_NexT/images/logo4.png">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">

<link rel="stylesheet" href="/Blog_NexT/css/main.css">


<link rel="stylesheet" href="/Blog_NexT/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"luo25177.github.io","root":"/Blog_NexT/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="机器学习的监督学习部分，在没有标签或输出变量指导的情况下，算法自行从数据中学习模式、结构和关系的过程">
<meta property="og:type" content="article">
<meta property="og:title" content="机器学习-非监督学习">
<meta property="og:url" content="https://luo25177.github.io/2025/03/02/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E9%9D%9E%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/index.html">
<meta property="og:site_name" content="LuosBlog">
<meta property="og:description" content="机器学习的监督学习部分，在没有标签或输出变量指导的情况下，算法自行从数据中学习模式、结构和关系的过程">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://luo25177.github.io/Blog_NexT/2025/03/02/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E9%9D%9E%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/4d27e6521ae385c0328577722d39f5e0.png">
<meta property="og:image" content="https://luo25177.github.io/Blog_NexT/2025/03/02/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E9%9D%9E%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/c091206df2cac821c53df341e9001e86.png">
<meta property="og:image" content="https://luo25177.github.io/Blog_NexT/2025/03/02/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E9%9D%9E%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/%E4%BA%8B%E5%8A%A1001.png">
<meta property="og:image" content="https://luo25177.github.io/Blog_NexT/2025/03/02/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E9%9D%9E%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/%E4%BA%8B%E5%8A%A1002.png">
<meta property="og:image" content="https://luo25177.github.io/Blog_NexT/2025/03/02/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E9%9D%9E%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/%E4%BA%8B%E5%8A%A1003.png">
<meta property="og:image" content="https://luo25177.github.io/Blog_NexT/2025/03/02/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E9%9D%9E%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/%E4%BA%8B%E5%8A%A1004.png">
<meta property="og:image" content="https://luo25177.github.io/Blog_NexT/2025/03/02/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E9%9D%9E%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/%E4%BA%8B%E5%8A%A1005.png">
<meta property="og:image" content="https://luo25177.github.io/Blog_NexT/2025/03/02/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E9%9D%9E%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/%E4%BA%8B%E5%8A%A1006.png">
<meta property="og:image" content="https://luo25177.github.io/Blog_NexT/2025/03/02/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E9%9D%9E%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/1740388689013.png">
<meta property="article:published_time" content="2025-03-02T13:42:16.000Z">
<meta property="article:modified_time" content="2025-04-02T12:23:45.885Z">
<meta property="article:author" content="落">
<meta property="article:tag" content="机器学习">
<meta property="article:tag" content="非监督学习">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://luo25177.github.io/Blog_NexT/2025/03/02/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E9%9D%9E%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/4d27e6521ae385c0328577722d39f5e0.png">

<link rel="canonical" href="https://luo25177.github.io/2025/03/02/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E9%9D%9E%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>机器学习-非监督学习 | LuosBlog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/Blog_NexT/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">LuosBlog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/Blog_NexT/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-引导">

    <a href="/Blog_NexT/../" rel="section"><i class="fas fa-heart fa-fw"></i>引导</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/Blog_NexT/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/Blog_NexT/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/Blog_NexT/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-友链">

    <a href="/Blog_NexT/links/" rel="section"><i class="fa fa-link fa-fw"></i>友链</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://luo25177.github.io/2025/03/02/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E9%9D%9E%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/Blog_NexT/images/avatar.png">
      <meta itemprop="name" content="落">
      <meta itemprop="description" content="茶凉言尽，月上柳梢">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuosBlog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          机器学习-非监督学习
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-03-02 21:42:16" itemprop="dateCreated datePublished" datetime="2025-03-02T21:42:16+08:00">2025-03-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-04-02 20:23:45" itemprop="dateModified" datetime="2025-04-02T20:23:45+08:00">2025-04-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/Blog_NexT/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">机器学习</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>56k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>51 分钟</span>
            </span>
            <div class="post-description">机器学习的监督学习部分，在没有标签或输出变量指导的情况下，算法自行从数据中学习模式、结构和关系的过程</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>非监督学习是指在没有标签或输出变量指导的情况下，算法自行从数据中学习模式、结构和关系的过程。这种学习方式不需要预先定义好的类别或标签，而是让模型自主地从数据中探索潜在的模式和规律，但是结果往往难以解释和评估，因为发现的模式可能不易理解</p>
<hr>
<h2 id="聚类"><a href="#聚类" class="headerlink" title="聚类"></a>聚类</h2><p>聚类算法是数据挖掘中的概念，指的是按照某个特定的标准把一个数据集分割成不同的类或簇，使得同一个簇内的数据对象相似性尽可能大，同时不在同一个簇内的对象之间的差异尽可能大</p>
<hr>
<h3 id="样本的距离度量"><a href="#样本的距离度量" class="headerlink" title="样本的距离度量"></a>样本的距离度量</h3><p>对于样本之间的距离函数 $dist(x_i,x_j)$ 应该满足一定的性质：</p>
<ul>
<li>非负性 $dist(x_i,x_j)\geq0$</li>
<li>同一性 $dist(x_i,x_j)=0$ 当且仅当 $x_i=x_j$</li>
<li>对称性 $dist(x_i,x_j)=dist(x_j,x_i)$</li>
<li>直通性 $dist(x_i,x_j)\leq dist(x_i,x_k)+dist(x_k,x_j)$</li>
</ul>
<hr>
<p><strong>对于距离的度量方法</strong></p>
<ul>
<li>欧氏距离（Euclidean Distance）：两点之间的直接距离 $d(x,y)=\sqrt{(x_1-y_1)^2+…+(x_n-y_n)^2}$</li>
<li>曼哈顿距离（Manhattan Distance）：在曼哈顿街区要从一个十字路口开车到另一个十字路口，驾驶距离显然不是两点间的直线距离 $d(x,y)=\sum\vert x_i-y_i\vert$</li>
<li>切比雪夫距离（Chebyshev Distance）：对应于国际象棋中的国王从一个格子走到另一个格子所需要的最小步数 $d(x,y)=\underset{i}{\max}(\vert x_i-y_i\vert)$ ，另一种等价形式为 $d(x,y)=\underset{k\rightarrow\infty}{\lim}(\sum_i^n\vert x_i-y_i\vert^k)^{\frac{1}{k}}$</li>
<li>闵可夫斯基距离（Minkowski Distance）：是衡量数值点之间距离的一种非常常见的方法 $d(x,y)=(\sum_i^n\vert x_i-y_i\vert^p)^{\frac{1}{p}}$ 其中最常用的 $p$ 是 1 和 2</li>
<li>标准化欧式距离（Standardized Euclidean Distance）：是针对欧式距离的缺点而做的一种改进。对于数据各维分量的分布不一样，那就先将各个分量都<strong>标准化</strong>到均值和方差相等 $d(x,y)=\sqrt{\sum(\frac{x_i-y_i}{s_i})^2}$ ，其中 $s_i$ 是样本中第 $i$ 维的标准差</li>
<li>马氏距离（Mahalanobis Distance）：马氏距离是基于样本分布的一种距离，物理意义就是在规范化的主成分空间中的欧氏距离 $d(x,y)=\sqrt{(x-y)^T\Sigma^{-1}(x-y)}$ 其中 $\Sigma$ 是样本的协方差矩阵</li>
<li>余弦距离（Cosine Distance）：在几何中，夹角余弦用于衡量两个向量方向的差异，这里用于衡量两个样本向量之间的差异 $d(x,y)=\frac{x\cdot y}{\vert x\vert\vert y\vert}$</li>
<li>汉明距离（Hamming Distance）：两个等长字符串之间的汉明距离为，将其中一个变为另外一个所需要作的最小字符替换次数</li>
<li>杰卡德距离（Jaccard Distance）：用两个集合中不同元素占所有元素的比例来衡量两个集合的区分度 $J(A,B)=\frac{\vert A\cup B\vert-\vert A\cap B\vert}{\vert A\cup B\vert}$</li>
<li>相关距离（Correlation distance）：相关系数衡量随机变量X与Y相关程度的一种方法，相关系数的取值范围是 $[-1,1]$ ，相关系数的绝对值越大，则表明X与Y相关度越高，而相关距离与此相反 $d(x,y)=1-\rho(x,y)$ 其中 $\rho(x,y)$ 是相关系数</li>
<li>信息熵（Information Entropy）：信息熵描述的是整个系统内部样本之间的一个距离，称之为系统内样本分布的集中程度 $Entropy(x)=\sum-p_i\log_2p_i$ 其中 $p_i$ 是第 $i$ 类元素出现的概率</li>
</ul>
<hr>
<h3 id="聚类性能评估"><a href="#聚类性能评估" class="headerlink" title="聚类性能评估"></a>聚类性能评估</h3><p>聚类性能度量又称为聚类的有效性指标。对于聚类结果可以根据某些性能度量来评估聚类效果，也可以将其作为优化目标来得到符合要求的聚类结果。一般来说希望簇内样本尽可能相似，簇间样本尽可能有差异</p>
<hr>
<p><strong>外部指标</strong></p>
<p>将聚类结果与某个参考模型进行比较</p>
<p>对于数据集 $D=\{x_1,…x_m\}$ 来说，假设通过聚类给出的簇划分为 $C=\{c_1,…c_k\}$ ，参考模型给出的簇划分为 $C^\star=\{c_1^\star,…c_s^\star\}$ 。令 $\lambda$ 和 $\lambda^\star$ 表示与 $C$ 和 $C^\star$ 对应的簇标记向量，定义如下几个数据</p>
<script type="math/tex; mode=display">
a=\vert SS\vert\quad SS=\{(x_i,x_j)|\lambda_i=\lambda_j,\lambda^\star_i=\lambda_j^\star,i<j\}\\b=\vert SD\vert\quad SD=\{(x_i,x_j)|\lambda_i=\lambda_j,\lambda^\star_i\not=\lambda_j^\star,i<j\}\\c=\vert DS\vert\quad DS=\{(x_i,x_j)|\lambda_i\not=\lambda_j,\lambda^\star_i=\lambda_j^\star,i<j\}\\d=\vert DD\vert\quad DD=\{(x_i,x_j)|\lambda_i\not=\lambda_j,\lambda^\star_i\not=\lambda_j^\star,i<j\}</script><p>其中 $\lambda_i=\lambda_j$ 表示在 $C$ 中两个样本属于相同簇， $\lambda_i^\star=\lambda_j^\star$ 表示在 $C^\star$ 中两个样本属于相同簇。由于每个样本都只能存在于一个集合中，因此有 $a+b+c+d=\frac{m(m-1)}{2}$</p>
<p>常用的外部指标有</p>
<ul>
<li>Jaccard 系数 $JC=\frac{a}{a+b+c}$</li>
<li>FM 指数 $FMI=\sqrt{\frac{a}{a+b}\times\frac{a}{a+c}}$</li>
<li>Rand 指数 $RI=\frac{2(a+d)}{m(m-1)}$</li>
</ul>
<p>这些指标结果位于 $[0,1]$ 之间，值越大越好</p>
<hr>
<p><strong>内部指标</strong></p>
<p>不利用任何参考模型直接考察聚类结果</p>
<p>对于聚类结果的簇划分 $C$ ，定义一个簇 $c_i$ 内样本的平均距离如下</p>
<script type="math/tex; mode=display">
avg(c_i)=\frac{2}{\vert c_i\vert(\vert c_i\vert-1)}\sum_{1\leq i\leq j\leq\vert c_i\vert} dist(x_i,x_j)</script><p>定义 $u_i=\frac{1}{\vert c_i\vert}\sum_{x\in c_i}x$ 为簇 $c_i$ 内样本的均值向量，则两个聚类簇 $c_i$ 和 $c_j$ 的中心距离为</p>
<script type="math/tex; mode=display">
d_{cen}(c_i,c_j)=dist(u_i,u_j)</script><p>常用的内部指标有</p>
<ul>
<li>DB 指数 $DBI=\frac{1}{k}\sum_{i=1}^k\underset{j\not=i}{\max}(\frac{avg(c_i)+avg(c_j)}{d_{cen}(u_i,u_j)})$</li>
</ul>
<p>一般来说 DB 指数越小就意味着簇内距离越小同时簇间距离越大，说明聚类的性能好</p>
<hr>
<h3 id="K-means算法"><a href="#K-means算法" class="headerlink" title="K-means算法"></a>K-means算法</h3><p>需要事先指定簇类的数目或者聚类中心，通过反复迭代，直到最后达到簇内点足够近，簇间点足够远的目标。K-means 算法以 k 为参数，把 n 个对象分为 k 个簇，使簇内具有较高的相似度，而簇间相似度较低</p>
<hr>
<p><strong>基本原理</strong></p>
<p>K-means 算法的目的是将 n 个数据点划分为 k 个簇，使得每个数据点属于离它最近的均值对应的簇，以次来最小化簇内的平方误差之和</p>
<p>首先定义算法中针对所有聚类所得簇 $C=\{c_1,…c_k\}$ 的聚类紧密程度如下</p>
<script type="math/tex; mode=display">
E=\sum_i^k\sum_{x\in c_i}\Vert x-\mu_i\Vert^2_2</script><p>其中 $\mu_i=\frac{1}{\vert c_i\vert}\sum_{x\in c_i}x$ 是簇 $c_i$ 的均值向量（参考向量，质心）。上述公式反映了簇内样本围绕簇均值向量的紧密程度， $E$ 越小簇内样本的相似度越高</p>
<p>因此 K-means 算法的优化目标为 $C^\star=\{c_1^\star,…c_k^\star\}=\underset{c_1,…c_k}{\arg\min}E$ </p>
<hr>
<p><strong>迭代步骤</strong></p>
<ol>
<li>初始化：随机选择 k 个数据点作为初始簇的中心</li>
<li>分配：计算每个数据点到各个簇中心的距离，将其分配到最近的簇中心，形成 k 个簇</li>
<li>更新：重新计算每个簇的均值向量</li>
<li>迭代：重复上述步骤，直到簇中心不再发生变化或者达到预期的迭代次数为止</li>
</ol>
<hr>
<p><strong>优点</strong></p>
<ul>
<li>简单易懂</li>
<li>计算效率高</li>
<li>可以扩展到多维空间</li>
<li>应用广泛</li>
</ul>
<hr>
<p><strong>缺点</strong></p>
<ul>
<li>对初始值敏感</li>
<li>需要预先指定簇的数量</li>
<li>对异常值敏感</li>
<li>只适用于凸形簇</li>
</ul>
<hr>
<p><strong>K-means++ 聚类方法</strong></p>
<p>为了提高算法收敛速度和聚类效果，提出了该方法。其初始的均值向量选择方法如下</p>
<ol>
<li>在 m 个数据中随机选择一个作为初始质心 $\mu_1$ 加入集合 $\mu:\{\mu_1\}$</li>
<li>对未被选中的每个数据点 $x_i$ ，计算其与 $\mu$ 中每个初始质心的距离，并将最短的一个距离记作 $d(x_i)$</li>
<li>以概率 $p_i$ 选择样本点 $x_i$ 作为下一个初始质心加入集合 $\mu$ ，其中 $p_i\varpropto d(x_i)$ ，即距离当前初始质心越远的样本点越有可能被选为下一个初始质心</li>
<li>重复上述步骤直到 k 个初始质心点全部被选出 $\mu:\{\mu_1,…\mu_k\}$</li>
<li>继续执行标准的 k-means 步骤进行迭代</li>
</ol>
<hr>
<h3 id="层次聚类算法"><a href="#层次聚类算法" class="headerlink" title="层次聚类算法"></a>层次聚类算法</h3><p>层次聚类算法（Hierarchical Clustering Algorithm），又称系统聚类法或分级聚类法，是一种常用的无监督学习算法。它通过将数据集划分成多个不同层次的簇，来揭示数据的内在结构和层次关系</p>
<hr>
<p><strong>基本原理</strong></p>
<p>层次聚类算法的基本思想就是将数据集构建成一个层次结构，这个结构通常以树状图的形式展示，其中每个样本最初表示为一个单独的簇，然后通过计算样本之间的相似度或距离来逐渐合并或分裂簇，形成更大的或更小的簇。整个过程可以表示为一棵树形结构，通过该树状图可以选择合适的切割点来确定最终的聚类结果</p>
<p>通常有两种主要的方法，根据层次分解的顺序分为：凝聚（自下而上）和分裂（自上而下）</p>
<hr>
<p><strong>簇间相似度度量方法</strong></p>
<ul>
<li>单链法（Single Linkage）：以两个簇中最近的两个点之间的距离作为簇间距离 $d_{min}(c_i,c_j)=\underset{x\in c_i,z\in c_j}{\min}dist(x,z)$</li>
<li>全链法（Complete Linkage）：以两个簇中最远的两个点之间的距离作为簇间距离 $d_{max}(c_i,c_j)=\underset{x\in c_i,z\in c_j}{\max}dist(x,z)$</li>
<li>平均链法（Average Linkage）：以两个簇中所有点对之间的平均距离作为簇间距离 $d_{avg}(c_i,c_j)=\frac{1}{\vert c_i\vert\vert c_j\vert}\sum_{x\in c_i}\sum_{z\in c_j}dist(x,z)$</li>
<li>Ward法：以合并后簇的方差增量作为相似度度量，适合欧氏距离</li>
</ul>
<hr>
<p><strong>凝聚层次聚类</strong></p>
<p>凝聚层次聚类是一种自底向上的方法，从每个数据点作为单独的簇开始，逐步合并最相似的簇，直到所有数据点合并为一个簇或达到预设的停止条件</p>
<ol>
<li>初始化：将每个数据点视作一个单独的簇</li>
<li>计算相似度：计算所有簇之间的相似度</li>
<li>合并簇：将最相似的两个簇合并为一个新簇</li>
<li>更新相似度：重新计算新簇与其他簇的相似度</li>
<li>迭代：重复上述步骤，直到所有数据点合并为一个簇或者满足停止条件</li>
</ol>
<hr>
<p><strong>分裂层次聚类</strong></p>
<p>分裂层次聚类是一种自上而下的方法，从所有数据点作为一个簇开始，逐步将不相似的簇分裂，直到每个数据点称为一个单独的簇或者达到设定的停止条件</p>
<ol>
<li>初始化：将所有数据视为一个簇</li>
<li>选择分裂簇：选择最不相似的簇进行分裂</li>
<li>分裂簇：将选定的簇分裂为两个簇</li>
<li>迭代：重复上述步骤，直到每个数据点称为一个单独的簇或者满足停止条件</li>
</ol>
<hr>
<p><strong>优点</strong></p>
<ul>
<li>不需要预先指定聚类数量，灵活性高</li>
<li>可以发现类的层次关系，有助于理解数据内在结构</li>
<li>结果可以使用树状图显示</li>
</ul>
<hr>
<p><strong>缺点</strong></p>
<ul>
<li>计算复杂度高，特别是对于大型数据集</li>
<li>对噪声和异常值敏感，可能会影响聚类结果</li>
<li>某些相似度度量方式容易导致链状效应，使得簇间结构不明确</li>
</ul>
<hr>
<h3 id="密度聚类算法"><a href="#密度聚类算法" class="headerlink" title="密度聚类算法"></a>密度聚类算法</h3><p>密度聚类（Density-Based Clustering）是一种基于数据点密度分布的聚类方法，能够发现任意形状的簇，并且对噪声和异常值具有较好的鲁棒性。最经典的算法是 DBSCAN 算法</p>
<hr>
<p><strong>核心概念</strong></p>
<ul>
<li>$\epsilon$ 邻域：对于一个样本点，其 $\epsilon$ 邻域包含样本集中与其距离不大于 $\epsilon$ 的样本</li>
<li>核心点：如果一个样本点的 $\epsilon$ 邻域内至少包含 $MinPts$ 个样本点，则该点是一个核心对象</li>
<li>边界点：如果一个样本点的 $\epsilon$ 邻域内包含的点数少于 $MinPts$ ，但是它位于某个核心点的 $\epsilon$ 邻域内，那该点为边界点</li>
<li>噪声点：既不是核心点，也不是边界点</li>
<li>密度直达：如果点 $x_i$ 在点 $x_j$ 的 $\epsilon$ 邻域内，且 $x_j$ 是核心点，则称 $x_i$ 从 $x_j$ 密度直达</li>
<li>密度可达：对于样本点 $x_i$ 和 $x_j$ ，若存在样本序列 $p_1,…p_n$ ，其中 $p_1=x_i,p_n=x_j$ ，且 $p_{i+1}$ 由 $p_i$ 密度直达，则称 $x_j$ 由 $x_i$ 密度可达</li>
<li>密度相连：如果存在点 $x_k$ 使得点 $x_i$ 和 $x_j$ 都从 $x_k$ 密度直达，则称 $x_i$ 和 $x_j$ 密度相连</li>
</ul>
<hr>
<p><strong>DBSCAN 算法</strong></p>
<p>DBSCAN 算法初始任意选择一个核心对象，然后找到所有这个核心对象能够密度可达的样本集合，即为一个聚类簇。接着继续选择另一个没有类别的核心对象去寻找密度可达的样本集合，这样就得到另一个聚类簇，一直运行到所有核心对象都有类别为止</p>
<p><strong>迭代步骤</strong></p>
<ol>
<li>初始化：设置参数 $\epsilon$ 邻域半径和最小点数 $MinPts$</li>
<li>遍历数据点：随机选择一个未访问的点，检查其邻域内的点数<ol>
<li>如果该点是核心点，那么就围绕它建立一个新簇，并将其所有密度可达的点加入其中</li>
<li>如果不是核心点则标记为噪声点</li>
</ol>
</li>
<li>扩展簇：对于每一个核心点，递归地将其密度直达的点加入当前簇</li>
<li>迭代：直到所有点都被访问</li>
</ol>
<p><strong>DBSCAN 算法参数选择</strong></p>
<ul>
<li>$\epsilon$ 邻域半径：决定了邻域的大小，通常通过可视化数据分布或使用 K 距离图来选择</li>
<li>$MinPts$ 最小点数：通常设置为数据维度加 1，或根据邻域知识调整</li>
</ul>
<p><strong>优点</strong></p>
<ul>
<li>能发现任意形状的簇</li>
<li>对噪声和异常值具有鲁棒性</li>
<li>不需要预先指定簇的数量</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>对参数 $\epsilon$ 和 $MinPts$ 敏感，参数选择不当可能导致聚类效果差</li>
<li>在高维数据中，密度定义可能失效（维度灾难）</li>
<li>对密度差异较大的数据集效果差</li>
</ul>
<hr>
<p><strong>OPTICS</strong></p>
<p>Ordering points to identify the clustering structure 是一种基于密度的聚类算法，是 DBSCAN 的改进版本，该算法的提出是为了帮助 DBSCAN 算法选择合适的参数，降低输入参数的敏感度。OPTICS 的输入参数和 DBSCAN 一样，也需要两个参数输入，但该算法对 $\epsilon$ 输入不敏感（一般将其固定为无穷大），同时该算法中并不显式的生成数据聚类，只是对数据集合中的对象进行排序，得到一个有序的对象列表，通过该有序列表，可以得到一个决策图，通过决策图可以不同 $\epsilon$ 参数的数据集中检测簇集，即：先通过固定的 $MinPts$ 和无穷大的 $\epsilon$ 得到有序列表，然后得到决策图，通过决策图可以知道当 $\epsilon$ 取特定值时数据的聚类情况</p>
<p><strong>引入了两个需要的定义</strong></p>
<ul>
<li>核心距离：对于给定的 $MinPts$ ，使得某个样本点称为核心点的最小邻域半径称为该核心点的核心距离 $cd(x)=\left\{\begin{aligned}&amp;undefined&amp;\vert N_\epsilon\vert&lt;MinPts\\&amp;d(x,N_\epsilon^{MinPts}(x))&amp;\vert N_\epsilon\vert\geq MinPts\end{aligned}\right.$<ul>
<li>$N_\epsilon^i(x)$ 表示集合 $N_\epsilon(x)$ 中与节点 $x$ 第 $i$ 临近的节点</li>
</ul>
</li>
<li>可达距离：对于两个样本点 $x$ 和 $y$ ，对于给定的 $\epsilon$ 和 $MinPts$ ， $y$ 关于 $x$ 的可达距离定义为 $rd(y,x)=\left\{\begin{aligned}&amp;undefined&amp;\vert N_\epsilon\vert&lt;MinPts\\&amp;\max(cd(x),d(x,y))&amp;\vert N_\epsilon\vert\geq MinPts\end{aligned}\right.$<ul>
<li>$rd(y,x)$ 表示使得 $x$ 称为核心点并且 $y$ 可以从 $x$ 直接密度可达成立的最小邻域半径</li>
</ul>
</li>
</ul>
<p><strong>引入的数据结构</strong></p>
<ul>
<li>$\{p_i\}_{i=1}^N$ ：是 OPTICS 算法的输出有序列表，表示集合中数据被处理的顺序</li>
<li>$\{c_i\}_{i=1}^N$ ：第 $i$ 号节点的核心距离</li>
<li>$\{r_i\}_{i=1}^N$ ：第 $i$ 号节点的可达距离</li>
</ul>
<p><strong>算法流程</strong></p>
<p><img src="/Blog_NexT/2025/03/02/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E9%9D%9E%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/4d27e6521ae385c0328577722d39f5e0.png" alt="4d27e6521ae385c0328577722d39f5e0.png"></p>
<ol>
<li>初始化核心对象集合 $\Omega$ 为空集</li>
<li>遍历数据集合 $D$ 的所有元素，如果是核心对象则将其加入到核心对象集合中</li>
<li>如果核心对象集合中元素都已经被处理则算法跳入第六步</li>
<li>在核心对象集合中，随机选择一个未处理的核心对象 $p$ ，先将其标记为已处理，同时将其压入到有序列表 $O$ 中，最后将 $p$ 的 $\epsilon$ 邻域中未访问的点，根据可达距离的大小依次存放到集合 $Q$ 中</li>
<li>如果集合 $Q=\varnothing$ 则跳转到第三步，否则从集合 $Q$ 中挑选可达距离最近的点 $q$ ，将其标记为已访问且已处理，同时将其压入有序列表 $O$ 中，判断其是否为核心对象，如果是就将 $s$ 中未访问的邻居点加入到集合 $Q$ 中，重新计算可达距离，按照可达距离排序。重复这一步</li>
<li>对于上述处理中得到的有序队列 $O$ ，从中按顺序取出点，如果该点的可达距离不大于给定半径 $\epsilon$ ，则该店属于当前类别，否则进入下一步</li>
<li>如果该点的核心距离大于 $\epsilon$ ，则该点为噪声，可以忽略，否则该点属于新的聚类</li>
<li>重复第六七步，直到有序队列为空</li>
</ol>
<hr>
<p><strong>DENCLUE</strong></p>
<p>Density-Based Clustering 是一种基于密度分布函数的聚类算法，通过建模数据点的密度分布来发现簇结构。它特别适合处理高维数据，并且能够识别任意形状的簇。DENCLUE 的核心思想是利用核密度估计（Kernel Density Estimation, KDE）来描述数据的密度分布，并通过密度吸引点（Density Attractors）将数据点分配到簇中</p>
<p><strong>核心概念</strong></p>
<ul>
<li>密度函数：使用核密度估计来定义数据点的密度分布。对于给定数据集 $X=\{x_1,…x_n\}$ 密度函数定义为 $f(x)=\frac{1}{n}\sum_{i=1}^nK(\frac{x-x_i}{h})$<ul>
<li>$K$ 是核函数</li>
<li>$h$ 是带宽参数，控制核函数的平滑程度</li>
</ul>
</li>
<li>密度吸引点：密度吸引点指的是密度函数的局部最大值点。数据点会沿着密度梯度方向“移动”到最近的密度吸引点，从而形成簇</li>
<li>密度吸引：对于每个数据点，通过梯度上升法找到其密度吸引点 $x_{t+1}=x_t+\alpha\nabla f(x_t)$<ul>
<li>$\alpha$ 为步长</li>
<li>$\nabla f(x_t)$ 是密度函数在 $x_t$ 处的梯度</li>
</ul>
</li>
<li>噪声点：如果数据点的密度值低于某个阈值 $\xi$ ，则将其标记为噪声点</li>
</ul>
<p><strong>算法步骤</strong></p>
<ol>
<li>初始化<ol>
<li>设置参数：带宽 $h$ 和密度阈值 $\xi$</li>
<li>计算每个数据点的密度值 $f(x)$</li>
</ol>
</li>
<li>寻找密度吸引点<ol>
<li>对于每个数据点，利用梯度上升法找到其密度吸引点</li>
<li>如果密度值小于密度阈值 $\xi$ ，则标记为噪声</li>
</ol>
</li>
<li>分配簇：将具有相同密度吸引点的数据点分配到同一个簇中</li>
<li>合并簇：如果两个密度吸引点之间的距离小于某个阈值，则将它们对应的簇合并</li>
</ol>
<p><strong>参数选择</strong></p>
<ul>
<li>带宽 $h$<ul>
<li>控制核函数的平滑程度，影响密度估计的精度</li>
<li>通常通过交叉验证或经验选择</li>
</ul>
</li>
<li>密度阈值 $\xi$<ul>
<li>决定数据点是否属于噪声</li>
<li>需要根据数据分布调整</li>
</ul>
</li>
</ul>
<p><strong>优点</strong></p>
<ul>
<li>能够处理高维数据</li>
<li>可以发现任意形状的簇</li>
<li>对噪声和异常值具有鲁棒性</li>
<li>理论基础强，基于概率密度估计</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>计算复杂度较高，尤其是梯度上升法的迭代过程</li>
<li>对参数（带宽 $h$ 和密度阈值 $\xi$ ）敏感</li>
<li>需要选择合适的核函数</li>
</ul>
<hr>
<h3 id="谱聚类算法"><a href="#谱聚类算法" class="headerlink" title="谱聚类算法"></a>谱聚类算法</h3><p>是一种基于图论的聚类算法，通过利用数据的相似性矩阵（或邻接矩阵）的谱（特征值和特征向量）来进行聚类。能处理复杂的簇结构，尤其是非凸形的簇，在高维数据中表现良好</p>
<p>谱聚类将数据点看作图中的节点，数据点之间的相似性看作边的权重。通过构建图的拉普拉斯矩阵（Laplacian Matrix），并分析其特征值和特征向量，将数据映射到低维空间，然后在低维空间中使用传统聚类算法（如 K-Means）进行聚类</p>
<hr>
<p><strong>步骤</strong></p>
<ol>
<li>构建相似性矩阵<ol>
<li>对于给定数据集 $X=\{x_1,…x_n\}$ ，计算数据点之间的相似性矩阵 $W$ ，其中 $W_{ij}$ 表示 $x_i$ 和 $x_j$ 之间的相似度</li>
<li>常用高斯核函数来进行相似度度量 $W_{ij}=\exp(-\frac{\Vert x_i-x_j\Vert^2}{2\sigma^2})$</li>
<li>其中 $\sigma$ 是带宽参数</li>
</ol>
</li>
<li>构建拉普拉斯矩阵<ol>
<li>计算度矩阵 $D$ ，其中 $D_{ii}=\sum_{j=1}^nW_{ij}$ ，其余元素均为 0</li>
<li>计算拉普拉斯矩阵<ul>
<li>非归一化拉普拉斯矩阵 $L=D-W$</li>
<li>对称归一化拉普拉斯矩阵 $L_{sym}=I-D^{-\frac{1}{2}}WD^{-\frac{1}{2}}$</li>
<li>随机游走归一化拉普拉斯矩阵 $L_{rw}=I-D^{-1}W$</li>
</ul>
</li>
</ol>
</li>
<li>计算特征值和特征向量：对拉普拉斯矩阵进行特征值分解，选择前 $k$ 个最小的特征值对应的特征向量，构成矩阵 $U\in R^{n\times k}$</li>
<li>低维嵌入：将矩阵 $U$ 的每一行看作数据点在低维空间中的表示</li>
<li>聚类：在低维空间中使用 K-means 等算法对数据点进行聚类</li>
</ol>
<hr>
<p><strong>参数选择</strong></p>
<ul>
<li>相似性矩阵的带宽参数 $\sigma$<ul>
<li>控制高斯核函数的平滑程度，影响相似性矩阵的构造</li>
<li>通常通过实验或经验选择</li>
</ul>
</li>
<li>聚类数量 $k$<ul>
<li>需要预先指定簇的数量</li>
</ul>
</li>
</ul>
<hr>
<p><strong>优点</strong></p>
<ul>
<li>能够处理复杂的簇结构（如非凸形状的簇）</li>
<li>在高维数据中表现良好</li>
<li>理论基础强，基于图论和线性代数</li>
</ul>
<hr>
<p><strong>缺点</strong></p>
<ul>
<li>计算复杂度较高，尤其是特征值分解部分</li>
<li>需要预先指定簇的数量 $k$</li>
<li>对相似性矩阵的构造和参数选择敏感</li>
</ul>
<hr>
<h3 id="高斯混合模型-GMM"><a href="#高斯混合模型-GMM" class="headerlink" title="高斯混合模型 GMM"></a>高斯混合模型 GMM</h3><p>是一种基于概率模型的聚类算法，假设数据是由多个高斯分布（正态分布）混合生成的，GMM 通过最大化似然函数来估计每个高斯分布的参数（均值，协方差）以及混合系数，从而将数据分配到不同簇中</p>
<hr>
<p><strong>核心思想</strong></p>
<p>GMM 假设数据是由 K 个高斯分布组成的混合分布生成的，每个高斯分布对应一个簇。数据点生成过程如下</p>
<ol>
<li>随机选一个高斯分布簇，选择概率由混合系数决定</li>
<li>从选定的高斯分布中生成一个数据点</li>
</ol>
<p>GMM 的目标是通过最大化似然函数，估计每个高斯分布的参数（均值 $\mu_k$ ，协方差 $\Sigma_k$ ）以及混合系数（子模型在总体中出现的概率）</p>
<hr>
<p><strong>数学模型</strong></p>
<p>对于给定数据集 $X=\{x_1,…x_n\}$ ，GMM 的概率密度函数为</p>
<script type="math/tex; mode=display">
p(x)=\sum_{k=1}^K\pi_k\cdot \mathcal{N}(x|\mu_k,\Sigma_k)</script><p>其中</p>
<ul>
<li>$\pi_k$ 是第 $k$ 个高斯分布的混合系数，满足 $\sum\pi_k=1$</li>
<li>$\mathcal{N}(x|\mu_k,\Sigma_k)$ 是第 $k$ 个高斯分布的概率密度函数 $\mathcal{N}(x|\mu_k,\Sigma_k)=\frac{1}{(2\pi)^\frac{d}{2}\vert\Sigma_k\vert^\frac{1}{2}}\exp(-\frac{1}{2}(x-\mu_k)^T\Sigma_k^{-1}(x-\mu_k))$<ul>
<li>其中 $d$ 是数据维度</li>
</ul>
</li>
</ul>
<hr>
<p><strong>参数估计</strong></p>
<p>GMM 使用期望最大化（EM）算法来估计参数，算法分为两步</p>
<ul>
<li>E 步：计算每个数据点 $x_i$ 属于第 $k$ 个高斯分布的后验概率 $\gamma_{ik}=\frac{\pi_k\cdot\mathcal{N}(x_i|\mu_k,\Sigma_k)}{\sum_{j=1}^K\pi_j\mathcal{N}(x_i|\mu_j,\Sigma_j)}$</li>
<li>M 步：根据上述后验概率更新参数<ul>
<li>更新混合参数 $\pi_k=\frac{1}{n}\sum_{i=1}^n\gamma_{ik}$</li>
<li>更新均值 $\mu_k=\frac{\sum_i^n\gamma_{ik}x_i}{\sum_i^n\gamma_{ik}}$</li>
<li>更新协方差 $\Sigma_k=\frac{\sum_i^n\gamma_{ik}(x_i-\mu_i)(x_i-\mu_i)^T}{\sum_i^n\gamma_{ik}}$</li>
</ul>
</li>
<li>重复上述两步，直到参数收敛</li>
</ul>
<hr>
<p><strong>参数选择</strong></p>
<ul>
<li>聚类数量 $K$<ul>
<li>需要预先指定簇的数量</li>
<li>可以通过肘部法，信息准则（如 AIC、BIC）或交叉验证选择</li>
</ul>
</li>
<li>协方差矩阵类型<ul>
<li>完全协方差矩阵：每个簇有自己的协方差矩阵</li>
<li>对角协方差矩阵：协方差矩阵是对角矩阵</li>
<li>球形协方差矩阵：协方差矩阵是标量乘以单位矩阵</li>
</ul>
</li>
</ul>
<hr>
<p><strong>优点</strong></p>
<ul>
<li>基于概率模型，能够提供属于每个簇的概率</li>
<li>可以拟合复杂的数据分布</li>
<li>能够处理不同形状，大小和方向的簇</li>
</ul>
<hr>
<p><strong>缺点</strong></p>
<ul>
<li>对初始值敏感，可能收敛到局部最优</li>
<li>计算复杂度较高，尤其是高维数据</li>
<li>需要预先指定簇的数量 $K$</li>
</ul>
<hr>
<h3 id="模糊-C-means-算法"><a href="#模糊-C-means-算法" class="headerlink" title="模糊 C-means 算法"></a>模糊 C-means 算法</h3><p>是一种基于模糊理论的聚类算法，是 K-means 的扩展版本，与 K-means 不同，FCM 允许数据点以一定的概率属于多个簇，而不是严格地属于某一个簇。这种软分配使得 FCM 在处理边界模糊地数据时更加灵活</p>
<hr>
<p><strong>核心思想</strong></p>
<p>FCM 的目标是最小化以下目标函数</p>
<script type="math/tex; mode=display">
J=\sum_{i}^n\sum_j^c\mu_{ij}^m\Vert x_i-v_j\Vert^2</script><p>其中</p>
<ul>
<li>$n$ 是数据点的数量</li>
<li>$c$ 是簇的数量</li>
<li>$u_{ij}$ 是数据点 $x_i$ 对于簇 $j$ 的隶属度，满足 $\sum_j^cu_{ij}=1$</li>
<li>$m$ 是模糊系数，通常 $m&gt;1$ ，控制隶属度的模糊程度</li>
<li>$v_j$ 是簇 $j$ 的中心</li>
<li>$\Vert x_i-v_j\Vert$ 是数据点与簇中心之间的距离</li>
</ul>
<p>FCM 通过迭代优化隶属度和簇中心来最小化目标函数</p>
<hr>
<p><strong>算法步骤</strong></p>
<ol>
<li>初始化<ol>
<li>随机初始化隶属度矩阵 $U=\begin{bmatrix}u_{ij}\end{bmatrix}$ ，满足 $\sum_j^cu_{ij}=1$</li>
<li>设置模糊系数 $m$</li>
</ol>
</li>
<li>更新簇中心：计算每个簇的中心 $v_j=\frac{\sum_i^nu_{ij}^mx_i}{\sum_i^nu_{ij}^m}$</li>
<li>更新隶属度：计算每个数据点 $x_i$ 对每个簇 $j$ 的隶属度 $u_{ij}=\frac{1}{\sum_k^c(\frac{\Vert x_i-v_j\Vert}{\Vert x_i-v_k\Vert})^{\frac{2}{m-1}}}$</li>
<li>重复迭代：重复上述步骤直到目标函数趋于某个阈值或达到最大迭代次数</li>
</ol>
<hr>
<p><strong>参数选择</strong></p>
<ul>
<li>簇的数量 $c$<ul>
<li>需要预先指定簇的数量</li>
<li>可以通过肘部法和轮廓系数等方法选择</li>
</ul>
</li>
<li>模糊系数 $m$<ul>
<li>控制隶属度的模糊程度，通常取 $m\in [1.5,3]$</li>
<li>$m$ 越大，隶属度越模糊</li>
<li>$m$ 接近 1 时，FCM 退化为 K-means</li>
</ul>
</li>
</ul>
<hr>
<p><strong>优点</strong></p>
<ul>
<li>允许数据点以概率形式属于多个簇，适合处理边界模糊的数据</li>
<li>能够发现复杂的簇结构</li>
<li>对噪声和异常值具有一定的鲁棒性</li>
</ul>
<hr>
<p><strong>缺点</strong></p>
<ul>
<li>计算复杂度较高，尤其是大数据集</li>
<li>对初始值敏感，可能收敛到局部最优</li>
<li>需要预先指定簇的数量 $c$ 和模糊系数 $m$</li>
</ul>
<hr>
<h2 id="降维"><a href="#降维" class="headerlink" title="降维"></a>降维</h2><p>降维（Dimensionality Reduction）是指通过数学方法将高维数据转换到低维空间，同时尽可能保留原始数据的重要信息。降维的主要目的是减少数据的复杂性，提高计算效率，并有助于可视化和分析</p>
<hr>
<h3 id="核函数"><a href="#核函数" class="headerlink" title="核函数"></a>核函数</h3><p>多维核函数用于衡量数据点之间的相似性，并决定了模型的灵活性和性能</p>
<p>单维核函数（Univariate Kernel Functions）是用于一维数据的核函数，常用于核密度估计（Kernel Density Estimation, KDE）和非参数回归等任务，这些核函数通常是对称的、非负的，并且积分为 1</p>
<hr>
<p><strong>二维核函数</strong></p>
<ul>
<li><p>线性核：最简单的核函数，适用于线性可分的数据，计算效率高但是无法捕捉非线性关系</p>
<script type="math/tex; mode=display">
  k(x_i,x_j)=x_i^Tx_j+c</script></li>
<li><p>高斯核：函数无限可微，平滑性好</p>
<script type="math/tex; mode=display">
  k(x_i,x_j)=\exp(-\frac{\Vert x_i-x_j\Vert^2}{2\sigma^2})</script><ul>
<li>$\sigma$ 是带宽参数，控制函数的平滑程度。过大导致欠拟合，过小导致过拟合</li>
</ul>
</li>
<li><p>多项式核：可以捕捉数据中的多项式关系</p>
<script type="math/tex; mode=display">
  k(x_i,x_j)=(x_i^Tx_j+c)^d</script><ul>
<li>$d$ 是阶数，用于控制模型的复杂度，但是高阶可能导致过拟合</li>
</ul>
</li>
<li><p>Sigmoid 核：在某些情况下可能导致核矩阵非正定</p>
<script type="math/tex; mode=display">
  k(x_i,x_j)=\tanh(\alpha x_i^Tx_j+c)</script><ul>
<li>$\alpha$ 和 $c$ 是参数</li>
</ul>
</li>
<li><p>径向基函数核：具有强大的非线性建模能力，数据点距离越近，核函数值越大</p>
<script type="math/tex; mode=display">
  k(x_i,x_j)=\exp(-\gamma\Vert x_i-x_j\Vert^2)</script><ul>
<li>$\gamma$ 参数，过大导致过拟合，过小导致欠拟合</li>
</ul>
</li>
<li><p>Matérn 核（Matérn Kernel）：是 RBF 核的广义形式</p>
<script type="math/tex; mode=display">
  k(x_i,x_j)=\frac{2^{1-v}}{\Gamma(v)}(\frac{\sqrt{2v}\Vert x_i-x_j\Vert}{\sigma})^vK_v(\frac{\sqrt{2v}\Vert x_i-x_j\Vert}{\sigma})</script><ul>
<li>$v$ 是平滑参数，控制平滑度。当 $v=\frac{1}{2}$ 时退化为指数核，当 $v\rightarrow\infty$ 时接近 RBF 核</li>
<li>$\sigma$ 是尺度参数</li>
<li>$K_v$ 是修正的贝塞尔函数</li>
</ul>
</li>
<li><p>指数核：比 RBF 核更不平滑，适合建模具有突变的数据</p>
<script type="math/tex; mode=display">
  k(x_i,x_j)=\exp(-\frac{\Vert x_i-x_j\Vert}{2\sigma})</script></li>
<li><p>幂指数核：</p>
<script type="math/tex; mode=display">
  k(x_i,x_j)=\exp(-(\frac{\Vert x_i-x_j\Vert}{\sigma})^\beta)</script><ul>
<li>$\sigma$ 是尺度参数</li>
<li>$\beta$ 是形状参数，控制函数的平滑程度<ul>
<li>$\beta=2$ 时，退化为高斯核</li>
<li>$\beta=1$ 时，退化为拉普拉斯核</li>
</ul>
</li>
</ul>
</li>
<li><p>拉普拉斯核：对数据点的影响随距离线性衰减，比高斯核更不平滑，适合建模具有突变的数据</p>
<script type="math/tex; mode=display">
  k(x_i,x_j)=\exp(-\frac{\Vert x_i-x_j\Vert}{\sigma})</script><ul>
<li>$\sigma$ 是尺度参数</li>
</ul>
</li>
<li><p>ANOVA 核：基于 ANOVA（方差分析）思想，适合高维数据，对每个维度单独计算核函数，然后求和</p>
<script type="math/tex; mode=display">
  k(x_i,x_j)=\sum_k^d\exp(-\sigma(x_i^k-x_j^k)^2)</script><ul>
<li>$d$ 是数据维度</li>
<li>$\sigma$ 是尺度参数</li>
</ul>
</li>
<li><p>有理二次核：可以看作多个 RBF 核的叠加，适合建模多尺度数据</p>
<script type="math/tex; mode=display">
  k(x_i,x_j)=(1+\frac{\Vert x_i-x_j\Vert^2}{2\alpha\sigma^2})^{-\alpha}</script><ul>
<li>$\alpha$ 是形状参数</li>
</ul>
</li>
<li><p>多元二次核：核函数值随距离增加而增加，适合插值和外推任务</p>
<script type="math/tex; mode=display">
  k(x_i,x_j)=\sqrt{\Vert x_i-x_j\Vert^2+c^2}</script><ul>
<li>$c$ 是形状参数</li>
</ul>
</li>
<li><p>逆多元二次核：核函数值随距离增加而衰减</p>
<script type="math/tex; mode=display">
  k(x_i,x_j)=\frac{1}{\sqrt{\Vert x_i-x_j\Vert^2+c^2}}</script><ul>
<li>$c$ 是形状参数</li>
</ul>
</li>
<li><p>周期核：专门用于建模周期性数据，可以捕捉数据中的重复模式</p>
<script type="math/tex; mode=display">
  k(x_i,x_j)=\exp(-\frac{2\sin^2(\pi\Vert x_i-x_j\Vert/p)}{2\sigma^2})</script><ul>
<li>$p$ 是周期长度</li>
</ul>
</li>
</ul>
<hr>
<p><strong>单维核函数</strong></p>
<ul>
<li><p>高斯核：平滑性好，对数据点的影响随距离衰减</p>
<script type="math/tex; mode=display">
  k(\mu)=\frac{1}{\sqrt{2\pi}}\exp(-\frac{(x-x_i)^2}{2h^2})</script><ul>
<li>$h$ 是带宽参数</li>
</ul>
</li>
<li><p>均匀核：简单，但对数据点的影响是均匀的，非连续导致数据不够平滑</p>
<script type="math/tex; mode=display">
  k(\mu)=\left\{\begin{aligned}&\frac{1}{2}&\vert \mu\vert\leq1\\&0&\vert \mu\vert>1\end{aligned}\right.</script></li>
<li><p>三角核：比均匀核更平滑，但仍有一定的突变</p>
<script type="math/tex; mode=display">
  k(\mu)=\left\{\begin{aligned}&1-\vert\mu\vert&\vert \mu\vert\leq1\\&0&\vert \mu\vert>1\end{aligned}\right.</script></li>
<li><p>Epanechnikov 核：平滑性好，计算效率高</p>
<script type="math/tex; mode=display">
  k(\mu)=\left\{\begin{aligned}&\frac{3}{4}(1-\mu^2)&\vert \mu\vert\leq1\\&0&\vert \mu\vert>1\end{aligned}\right.</script></li>
<li><p>双权重核：比 Epanechnikov 核更平滑，对数据点的影响随距离快速衰减</p>
<script type="math/tex; mode=display">
  k(\mu)=\left\{\begin{aligned}&\frac{15}{16}(1-\mu^2)^2&\vert \mu\vert\leq1\\&0&\vert \mu\vert>1\end{aligned}\right.</script></li>
<li><p>三权重核：比双权重核更平滑，对数据点的影响随距离更快衰减</p>
<script type="math/tex; mode=display">
  k(\mu)=\left\{\begin{aligned}&\frac{35}{32}(1-\mu^2)^3&\vert \mu\vert\leq1\\&0&\vert \mu\vert>1\end{aligned}\right.</script></li>
<li><p>余弦核：形状类似于余弦函数，平滑性好</p>
<script type="math/tex; mode=display">
  k(\mu)=\left\{\begin{aligned}&\frac{\pi}{4}\cos(\frac{\pi\mu}{2})&\vert \mu\vert\leq1\\&0&\vert \mu\vert>1\end{aligned}\right.</script></li>
<li><p>指数核：对数据点的影响随距离指数衰减，不平滑但适合建模突变数据</p>
<script type="math/tex; mode=display">
  k(\mu)=\frac{1}{2}\exp(-\vert \mu\vert)</script></li>
<li><p>拉普拉斯核：与指数核相同，对数据点的影响随距离指数衰减</p>
<script type="math/tex; mode=display">
  k(\mu)=\frac{1}{2}\exp(-\vert \mu\vert)</script></li>
<li><p>逻辑核：形状类似于逻辑函数，平滑且对称</p>
<script type="math/tex; mode=display">
  k(\mu)=\frac{1}{e^\mu+2+e^{-\mu}}=\frac{1}{2+2\cosh(\mu)}</script></li>
<li><p>五次核：类似于三权重核，比二权重核更平滑</p>
<script type="math/tex; mode=display">
  k(\mu)=\left\{\begin{aligned}&\frac{105}{64}(1-\mu^2)^3&\vert \mu\vert\leq1\\&0&\vert \mu\vert>1\end{aligned}\right.</script></li>
<li><p>柯西核：长尾分布，适合建模异常值较多的数据</p>
<script type="math/tex; mode=display">
  k(\mu)=\frac{1}{\pi(1+\mu^2)}</script></li>
<li><p>卡方核：基于卡方分布，适合特定类型的非对称数据</p>
<script type="math/tex; mode=display">
  k(\mu)=\frac{1}{2^{k/2}\Gamma(k/2)}\mu^{k/2-1}e^{-\mu/2}</script><ul>
<li>$k$ 是自由度</li>
</ul>
</li>
</ul>
<hr>
<h3 id="降维方法的选择"><a href="#降维方法的选择" class="headerlink" title="降维方法的选择"></a>降维方法的选择</h3><ul>
<li>数据的线性关系<ul>
<li>线性数据：如果数据在原始空间中呈现线性关系，可以选择线性降维方法<ul>
<li>PCA（主成分分析）：最常用的线性降维方法，适合去除冗余特征和降低维度</li>
<li>LDA（线性判别分析）：适用于分类任务，能够最大化类间距离</li>
<li>ICA（独立成分分析）：适用于信号分离或特征提取</li>
</ul>
</li>
<li>非线性数据：如果数据在原始空间中呈现非线性关系，需要选择非线性降维方法<ul>
<li>t-SNE（t-分布邻域嵌入）：适合高维数据的可视化，能够保留局部结构</li>
<li>UMAP（Uniform Manifold Approximation and Projection）：比t-SNE更快，适合大规模数据</li>
<li>自编码器（Autoencoder）：通过神经网络学习非线性映射，适合复杂数据结构</li>
</ul>
</li>
</ul>
</li>
<li>数据的规模大小<ul>
<li>小规模数据：可以使用计算复杂度较高的方法，如 t-SNE，核 PCA（Kernel PCA）</li>
<li>大规模数据：需要选择计算效率高的方法，如 PCA，UMAP，随机投影（Random Projection）</li>
</ul>
</li>
<li>数据稀疏性：如果数据是稀疏的（例如文本数据），可以使用 Truncated SVD 或者 NMF（非负矩阵分解）</li>
<li>数据可视化：对于目标是可视化高维数据（降维到 2D 或者 3D）<ul>
<li>t-SNE：适合展示局部结构，但计算较慢</li>
<li>UMAP：比 t-SNE 更快，并且能更好的保留全局结构</li>
<li>PCA：适合线性数据的快速可视化</li>
</ul>
</li>
<li>特征提取：对于目标需要提取重要特征用于机器学习模型<ul>
<li>PCA：适合线性数据的特征提取</li>
<li>LDA：适合分类任务的特征提取</li>
<li>自编码器：适合非线性数据的特征提取</li>
</ul>
</li>
<li>降噪：目标是去除噪声或冗余信息<ul>
<li>PCA：通过保留主成分去除噪声</li>
<li>NMF：适合非负数据的降噪</li>
</ul>
</li>
<li>分类或聚类<ul>
<li>对于分类问题：LDA 可以最大化类间距离</li>
<li>对于聚类问题：t-SNE 或 UMAP 适合展示聚类结构</li>
</ul>
</li>
<li>计算效率<ul>
<li>PCA、LDA、随机投影：计算速度快，适合大规模数据</li>
<li>t-SNE、UMAP：计算较慢，适合中小规模数据</li>
</ul>
</li>
<li>内存需求<ul>
<li>t-SNE：内存需求较高，不适合超大规模数据</li>
<li>UMAP：内存需求较低，适合较大规模数据</li>
</ul>
</li>
</ul>
<hr>
<h3 id="主成分分析"><a href="#主成分分析" class="headerlink" title="主成分分析"></a>主成分分析</h3><p>PCA(Principal Component Analysis)，即主成分分析方法，是一种使用最广泛的数据降维算法。PCA 的主要思想是指通过正交变换将一组高维的，可能存在相关性的样本变换为一组低维的，线性不相关的样本，转换后的新样本特征也被称为主成分，是能最大程度代表原样本特征的特性</p>
<hr>
<p><strong>实现思想</strong></p>
<p>通过计算数据矩阵的协方差矩阵，然后得到协方差矩阵的特征值特征向量，选择特征值最大（即方差最大）的 k 个特征所对应的特征向量组成的矩阵，就可以将数据矩阵转换到新的空间当中，实现数据特征的降维</p>
<p>得到协方差矩阵的特征值特征向量有两种方法：特征值分解协方差矩阵，奇异值分解协方差矩阵。所以对应的 PCA 算法有两种实现方式：基于特征值分解矩阵实现PCA算法，基于SVD分解协方差矩阵实现PCA算法</p>
<hr>
<p><strong>协方差和散度矩阵</strong></p>
<p>对于样本 $X:\{x_1,…x_n\}$ ，样本的均值为</p>
<script type="math/tex; mode=display">
\bar{x}=\frac{1}{n}\sum_i^nx_i</script><p>样本的方差为</p>
<script type="math/tex; mode=display">
S^2=\frac{1}{n-1}\sum_i^n(x_i-\bar{x})^2</script><p>则样本 $X:\{x_1,…x_n\}$ 和样本 $Y:\{y_1,…y_n\}$ 的协方差为</p>
<script type="math/tex; mode=display">
Cov(X,Y)=E[(X-E(X))(Y-E(Y))]=\frac{1}{n-1}\sum_i^n(x_i-\bar{x})(y_i-\bar{y})</script><p>由于方差的计算都是一维的特征之间的计算，协方差的计算都是对于二维数据的，对于协方差，如果协方差为正，那么说明 $X$ 和 $Y$ 正相关，如果协方差为负，说明 $X$ 和 $Y$ 负相关，如果为 0 则说明两者之间的相关性为 0。对于三维数据的协方差矩阵为</p>
<script type="math/tex; mode=display">
Cov(X,Y,Z)=\begin{bmatrix}Cov(X,X)&Cov(X,Y)&Cov(X,Z)\\Cov(Y,X)&Cov(Y,Y)&Cov(Y,Z)\\Cov(Z,X)&Cov(Z,Y)&Cov(Z,Z)\end{bmatrix}</script><p>对于高维的协方差矩阵也是如此，协方差矩阵是一个对称矩阵，且是一个半正定矩阵，主对角线是各个维度上的方差。对于数据集 $X$ 的协方差矩阵为 $\frac{\tilde{X}\tilde{X}^T}{n-1}$ ，其中 $\tilde{X}$ 是样本数据集 $X$ 减去各自维度的均值之后得到的矩阵</p>
<p>对于数据集 $X$ 的散度矩阵为 $\tilde{X}\tilde{X}^T$ ，其实协方差矩阵和散度矩阵关系密切，散度矩阵就是协方差矩阵乘以 $n-1$</p>
<hr>
<p><strong>特征值分解矩阵</strong></p>
<p>对于一个向量 $\vec{v}$ 是矩阵 $A$ 的特征向量，那么可以表示为下述形式</p>
<script type="math/tex; mode=display">
A\vec{v}=\lambda\vec{v}</script><p>其中 $\lambda$ 是特征向量的 $\vec{v}$ 对应的特征值，一个矩阵的一组特征向量是一组正交向量。对于矩阵 $A$ 的一组特征向量 $V$ ，将这组向量进行正交化单位化，就得到一组正交单位向量，对于特征值分解就是将矩阵 $A$ 按照如下形式分解</p>
<script type="math/tex; mode=display">
A=Q\Sigma Q^{-1}</script><p>其中 $Q$ 是矩阵 $A$ 的特征向量组成的矩阵， $\Sigma$ 是一个对角阵，对角线上的元素就是特征值</p>
<hr>
<p><strong>SVD 分解矩阵</strong></p>
<p>奇异值分解矩阵适用于任意矩阵的一种分解方法，对于任意矩阵 $A$ 总是存在如下一个奇异值分解</p>
<script type="math/tex; mode=display">
A=U\Sigma V^T</script><p>对于矩阵 $A\in R^{m\times n}$ ，则矩阵 $U\in R^{m\times m}$ 里的正交向量被称为左奇异向量。矩阵 $\Sigma\in R^{m\times n}$ 除了对角线其他元素均为 0，对角线上的元素称为奇异值。矩阵 $V\in R^{n\times n}$ 里的正交向量被称为右奇异值向量</p>
<ol>
<li>求解 $AA^T$ 的特征值和特征向量，用单位化的特征向量构成 $U$</li>
<li>求解 $A^TA$ 的特征值和特征向量，用单位化的特征向量构成 $V$</li>
<li>将 $AA^T$ 或者 $A^TA$ 的特征值求平方根，然后构成 $\Sigma$</li>
</ol>
<hr>
<p><strong>基于特征值分解协方差矩阵实现 PCA</strong></p>
<p>对于数据集 $X:\{x_1,…x_n\}$ ，将其降到 $k$ 维</p>
<ol>
<li>去平均值，即去中心化，每一位特征值都减去各自的平均值</li>
<li>计算协方差矩阵 $\frac{\tilde{X}\tilde{X}^T}{n-1}$ （实际上这里使用 $\frac{\tilde{X}\tilde{X}^T}{n}$ 或者 $\tilde{X}\tilde{X}^T$ 对结果不会有太大影响）</li>
<li>用特征值分解方式来求协方差矩阵的特征值和正则化之后的特征向量</li>
<li>对特征值从大大小排序，选择其中最大的 $k$ 个，然后将其对应的特征向量分别作为行向量组成特征向量矩阵 $P$</li>
<li>将数据转换到 $k$ 个特征向量构成的新空间中 $Y=PX$</li>
</ol>
<hr>
<p><strong>基于 SVD 分解协方差矩阵实现 PCA</strong></p>
<ol>
<li>去平均值，即去中心化，每一位特征值都减去各自的平均值</li>
<li>计算协方差矩阵 $\frac{\tilde{X}\tilde{X}^T}{n-1}$ （实际上这里使用 $\frac{\tilde{X}\tilde{X}^T}{n}$ 或者 $\tilde{X}\tilde{X}^T$ 对结果不会有太大影响）</li>
<li>用 SVD 方式来求协方差矩阵的特征值和正则化之后的特征向量</li>
<li>对特征值从大大小排序，选择其中最大的 $k$ 个，然后将其对应的特征向量分别作为行向量组成特征向量矩阵 $P$</li>
<li>将数据转换到 $k$ 个特征向量构成的新空间中 $Y=PX$</li>
<li>对于步骤 4 中选择特征值和特征向量，这里一般选择左奇异矩阵来计算，左奇异矩阵将样本数据从 $n\times m$ 降维到了 $k\times m$ ，是对维度的降维。而右奇异矩阵是将样本数据从 $n\times m$ 降到了 $n\times k$ ，此时数据转换的公式为 $Y=XP^T$</li>
</ol>
<hr>
<p><strong>PCA 推导角度</strong></p>
<ul>
<li>最大可分性：样本点在一个线性超平面上的投影尽可能分开，也就是样本矩阵X 投影后的各特征维度的方差最大，这个方差就是协方差矩阵的特征值</li>
<li>最近重构性：样本点到一个线性超平面的投影距离都足够近，由于投影距离越长，损失的信息也会越多</li>
</ul>
<hr>
<p><strong>PCA 评估</strong></p>
<p>将投影后新样本的第 k 维称为原样本的第 k 个主成分。定义方差贡献率为新样本在第 k 维的方差（即特征值 $\lambda_k$ ）与 d 个方差和的比值</p>
<script type="math/tex; mode=display">
\eta_k=\frac{\lambda_k}{\sum_i^d\lambda_i}</script><hr>
<p><strong>PCA 的变种</strong></p>
<p>有些时候，会选择在相关系数矩阵上进行 PCA。两个特征变量的相关系数为它们的协方差除以它们标准差的乘积，如下</p>
<script type="math/tex; mode=display">
\rho(X,Y)=\frac{Cov(X,Y)}{\sqrt{Cov(X,X)Cov(Y,Y)}}</script><p>相关系数剔除了两个特征变量量纲的影响，只是单纯反应两个特征变量每单位变化时的相似程度</p>
<hr>
<p><strong>PCA 选择降维后的主成分个数</strong></p>
<p>根据 PCA 过程中得到的特征值矩阵 $S\in R^{m\times 1}$ （实际上就是特征值从大到小排列之后得到的矩阵），然后定义一个误差变量 $\varepsilon$ ，也就是经过 PCA 之后数据损失（ $\varepsilon=0.01$ 损失为 $1\%$ ， $99\%$ 的信息被保留）。则可以根据下列公式来求解最佳的 $k$</p>
<script type="math/tex; mode=display">
1-\frac{\sum_i^ks_i}{\sum_i^ms_i}\leq \varepsilon</script><p>也可以根据原始点与投影点之间的距离之和来判断，如下</p>
<script type="math/tex; mode=display">
\frac{\frac{1}{m}\sum_i^m\Vert x_i-x_i^\star\Vert^2}{\frac{1}{m}\sum_i^m\Vert x_i\Vert^2}\leq \varepsilon</script><p>其中 $x_i$ 是原始点， $x_i^\star$ 是投影点</p>
<hr>
<p><strong>优点</strong></p>
<ul>
<li>能够有效去除冗余特征，降低数据维度</li>
<li>保留数据中方差最大的方向，尽可能减少信息损失</li>
<li>计算效率高，适合大规模数据</li>
</ul>
<hr>
<p><strong>缺点</strong></p>
<ul>
<li>只能处理线性关系，对非线性数据效果较差</li>
<li>降维后的特征可解释性较差</li>
<li>对异常值敏感</li>
</ul>
<hr>
<h3 id="核主成分分析"><a href="#核主成分分析" class="headerlink" title="核主成分分析"></a>核主成分分析</h3><p>核主成分分析（Kernel Principal Component Analysis, KPCA） 是主成分分析（PCA）的非线性扩展，通过引入核方法（Kernel Method）将数据映射到高维特征空间，并在该空间中进行线性 PCA，能够捕捉数据中的非线性结构，适用于非线性降维和特征提取任务</p>
<hr>
<p><strong>步骤</strong></p>
<ol>
<li><p>对于给定的数据集 $X:\{x_1,..x_n\}\in R^{n\times d}$ 利用核函数 $k(x_i,x_j)$ 计算核矩阵 $K\in R^{n\times n}$</p>
<script type="math/tex; mode=display">
 K_{ij}=k(x_i,x_j)</script></li>
<li><p>对核矩阵进行中心化，得到中心化核矩阵 $\tilde{K}$</p>
<script type="math/tex; mode=display">
 \tilde{K}=K-1_nK-K1_n+1_nK1_n</script><ul>
<li>$1_n\in R^{n\times n}$ ，所有元素均为 $\frac{1}{n}$</li>
</ul>
</li>
<li><p>对中心化核矩阵进行特征值分解</p>
<script type="math/tex; mode=display">
 \tilde{K}\alpha=\lambda\alpha</script><ul>
<li>$\lambda$ 是特征值</li>
<li>$\alpha$ 是对应的特征向量</li>
</ul>
</li>
<li>归一化特征向量，使得 $\alpha^T\alpha=\frac{1}{\lambda}$ ，得到 $\alpha^\prime$</li>
<li><p>将数据投影到前 $k$ 个主成分上，得到降维后的数据 $Y\in R^{n\times k}$</p>
<script type="math/tex; mode=display">
 Y_{ij}=\sum_k^n\tilde{K}_{ik}\alpha^\prime_{kj}</script></li>
</ol>
<hr>
<p><strong>优点</strong></p>
<ul>
<li>KPCA 能够捕捉数据中的非线性关系，适用于非线性降维任务</li>
<li>通过核技巧，KPCA 避免了显式计算高维特征空间中的向量</li>
<li>可以使用不同的核函数适应不同的数据分布</li>
</ul>
<hr>
<p><strong>缺点</strong></p>
<ul>
<li>核矩阵的计算和特征值分解的复杂度为 $O(n^3)$ ，对于大规模数据计算成本较高</li>
<li>核矩阵需要存储 $n\times n$ 个元素，对于大规模数据，内存占用高</li>
<li>核函数的选择核参数设置对结果影响较大，需要调参</li>
</ul>
<hr>
<h3 id="线性判别分析"><a href="#线性判别分析" class="headerlink" title="线性判别分析"></a>线性判别分析</h3><p>线性判别分析 LDA（Linear Discriminant Analysis）是一种监督学习的降维技术，它的数据集的每个样本都是有类别输出的</p>
<p>LDA 的思想是最大化类间均值，最小化类内方差，实际上就是将数据投影到低维度上，并且投影之后同种类别的数据的投影点尽可能近，不同类别数据的投影点的中心点尽可能远</p>
<hr>
<p><strong>投影</strong></p>
<p>对于两个向量 $\vec{x}_1$ 和 $\vec{x}_2$ 来说，两个向量的内积可以表示为</p>
<script type="math/tex; mode=display">
\vec{x}_1\cdot\vec{x}_2=\vert\vec{x}_1\vert\vert\vec{x_2}\vert\cos\theta</script><p> 当 $\vec{x}_2$ 是个单位向量时，两个向量的内积值就变成了 $\vec{x}_1$ 在 $\vec{x}_2$ 上的投影，即</p>
<script type="math/tex; mode=display">
\vec{x}_1\cdot\vec{x}_2=\vert\vec{x}_1\vert\cos\theta</script><hr>
<p><strong>瑞利商与广义瑞利商</strong></p>
<p>对于瑞利商，是如下函数</p>
<script type="math/tex; mode=display">
R(A,x)=\frac{x^HAx}{x^Hx}</script><p>其中 $x$ 是非零向量， $x^H$ 是它的共轭转置矩阵， $A$ 是一个 $n\times n$ 的 Hermitan 矩阵（满足共轭转置与自身相等）</p>
<p>瑞利商有一个非常重要的性质，那就是它的最大值等于矩阵 $A$ 的最大特征值，而最小值等于 $A$ 的最小特征值，如下</p>
<script type="math/tex; mode=display">
\lambda_{min}\leq\frac{x^HAx}{x^Hx}\leq\lambda_{max}</script><p>当向量 $x$ 是标准正交基时，即 $x^Hx=1$ 时，上述瑞利商变为</p>
<script type="math/tex; mode=display">
R(A,x)=x^HAx</script><p>定义广义瑞利商如下</p>
<script type="math/tex; mode=display">
R(A,B,x)=\frac{x^HAx}{x^HBx}</script><p>对其进行标准化就可以转化为瑞利商的格式，令 $x=B^{-\frac{1}{2}}x^\prime$ ，上述函数可以转为下面的形式</p>
<script type="math/tex; mode=display">
R(A,B,x^\prime)=\frac{x^{\prime H}B^{-\frac{1}{2}}AB^{-\frac{1}{2}}x^\prime}{x^{\prime H}x^\prime}</script><p>就得到了瑞利商形式</p>
<hr>
<p><strong>类间散度矩阵</strong></p>
<p>对于样本数据集 $X:\{x_1,…x_n\}$ 来说，一共有 $C$ 个类型，每一个类型的样本个数分别为 $n_1,…n_k$ 个，那么 $x_i^j$ 就表示第 $i$ 类里的第 $j$ 个数据，对应的可以得到 $X_i:\{x_i^1,…x_i^{n_i}\}$ 就是第 $i$ 类的数据</p>
<p>考虑如何使得不同类样例的投影点尽可能远离，采用类间散度矩阵来衡量类间距离，这里采用两个类别的均值向量 $\mu_i$ 在直线上的投影的距离</p>
<script type="math/tex; mode=display">
(w^T\mu_1-w^T\mu_2)^2=w^T(\mu_1-\mu_2)(\mu_1-\mu_2)^Tw</script><p>上述公式中 $w$ 为该直线的方向向量，上述类间散度写作 $w^TS_bw$</p>
<hr>
<p><strong>类内散度矩阵</strong></p>
<p>在考虑使得同类样例的投影点尽可能接近，采用类内散度矩阵来衡量类内间距。对于一维数据，要衡量其内部间距一般会使用方差，所以这里也使用方差来衡量</p>
<p>所以这里可以计算出第 $i$ 类的数据的方差，用 $\Sigma_i$ 表示</p>
<script type="math/tex; mode=display">
\sigma_i^2=\sum_{x\in X_i}(w^Tx-w^T\mu_i)^2\\=w^T(\sum_{x\in X_i}(x-\mu_i)(x-\mu_i)^T)w\\=w^T\Sigma_iw</script><p>则两个类别的方差和为</p>
<script type="math/tex; mode=display">
\Sigma_1+\Sigma_2=w^T(\sum_{x\in X_1}(x-\mu_1)(x-\mu_1)^T)w+w^T(\sum_{x\in X_2}(x-\mu_2)(x-\mu_2)^T)w\\=w^T(\sum_{x\in X_1}(x-\mu_1)(x-\mu_1)^T+\sum_{x\in X_2}(x-\mu_2)(x-\mu_2)^T)w\\=w^T(\Sigma_1+\Sigma_2)w</script><p>上述类内散度写作 $w^TS_ww$</p>
<hr>
<p><strong>定义目标函数</strong></p>
<p>根据LDA的目标，我们需要使得同类样例间的投影点尽可能接近，即类内散度矩阵 $w^TS_ww$ 尽可能小，而异类样例间的投影点尽可能远离，即类间散度矩阵 $w^TS_bw$ 尽可能大，所以构造目标函数如下</p>
<script type="math/tex; mode=display">
J=\frac{w^TS_bw}{w^TS_ww}</script><p>可知 $J$ 越大就越符合 LDA 的目标，这种形式是一种广义瑞利商的形式。对于上述函数，可知最优参数 $w^\star$ 的长度不重要，只需要确定方向即可，所以可以令 $w^TS_ww=1$ ，那么上述目标函数优化为</p>
<script type="math/tex; mode=display">
w^\star=\underset{w}{\arg\min}(-w^TS_bw)\\s.t.\quad w^tS_ww=1</script><p>求解上述最优问题可以构造 Lagrange 函数</p>
<script type="math/tex; mode=display">
\mathcal{L}(w,\lambda)=-w^TS_bw+\lambda(w^tS_ww-1)</script><p>求解可以得到</p>
<script type="math/tex; mode=display">
\frac{\partial\mathcal{L}}{\partial w}=S_bw-\lambda S_ww=0</script><p>所以最终得到的最优解应该满足</p>
<script type="math/tex; mode=display">
S_w^{-1}S_bw^\star=\lambda w^\star\\\lambda w^\star=S_w^{-1}(\mu_1-\mu_2)(\mu_1-\mu_2)^Tw^\star</script><p>所以可以得知 $w^\star$ 是 $S_w^{-1}S_b$ 的特征向量，由于 $(\mu_1-\mu_2)^Tw^\star$ 和 $\lambda$ 是标量，不影响 $w^\star$ 的方向，可以省去特征值分解的过程，此时得到 $w^\star$ 与 $S_w^{-1}(\mu_1-\mu_2)$ 共线，如下</p>
<script type="math/tex; mode=display">
w^\star=S_w^{-1}(\mu_1-\mu_2)</script><p>最终得到最优化参数 $w^\star$ ，选择前 $k$ 个最大特征值对应的特征向量，构成投影矩阵 $W$</p>
<p>最终得到投影数据</p>
<script type="math/tex; mode=display">
Y=XW</script><hr>
<p><strong>优点</strong></p>
<ul>
<li>能够有效提升分类性能</li>
<li>保留类别信息，适合有监督任务</li>
<li>计算效率高，适合中小规模数据</li>
</ul>
<hr>
<p><strong>缺点</strong></p>
<ul>
<li>假设数据服从高斯分布，对非高斯分布数据效果较差</li>
<li>对异常值敏感</li>
<li>最多只能降到 $C-1$ 维（ $C$ 是类别数）</li>
</ul>
<hr>
<h3 id="t-分布邻域嵌入"><a href="#t-分布邻域嵌入" class="headerlink" title="t-分布邻域嵌入"></a>t-分布邻域嵌入</h3><p>t-分布邻域嵌入（t-Distributed Stochastic Neighbor Embedding，t-SNE）是一种非线性降维方法，主要用于高维数据的可视化。t-SNE 通过保留数据点之间的局部结构，将高维数据映射到低维空间（通常是 2D 或 3D），从而在低维空间中展示数据的聚类结构</p>
<hr>
<p><strong>基本原理</strong></p>
<p>t-SNE 的核心思想时通过概率分布来描述高维和低维空间中数据点之间的相似性，并最小化这两个分布之间的差异。t-SNE 由 SNE 算法改进而来，而 SNE 算法的思想是如果两个数据在高维空间中是相似的，那么降维到二维空间时它们应该距离很近</p>
<hr>
<p><strong>KL 散度</strong></p>
<p>KL 散度（Kullback-Leibler Divergence）是用来度量两个概率分布相似度的指标，它作为经典损失函数被广泛地用于聚类分析与参数估计等机器学习任务中</p>
<p>假设对随机变量 $\xi$ ，存在两个概率分布 $P$ 和 $Q$ ，如果 $\xi$ 为离散随机变量，定义从 $P$ 到 $Q$ 的 KL 散度为</p>
<script type="math/tex; mode=display">
\mathbb{D}_{KL}(P\Vert Q)=\sum_iP(i)\ln(\frac{P(i)}{Q(i)})</script><p>如果 $\xi$ 为连续随机变量，则定义从 $P$ 到 $Q$ 的 KL 散度为</p>
<script type="math/tex; mode=display">
\mathbb{D}_{KL}(P\Vert Q)=\int_{-\infty}^{\infty}P(x)\ln(\frac{P(x)}{Q(x)})dx</script><hr>
<p><strong>具体步骤</strong></p>
<ol>
<li><p>计算高维空间中的相似性。对于高维空间中的两个点 $x_i$ 和 $x_j$ ，那么以点 $x_i$ 为中心构建方差为 $\sigma_i$ 的高斯分布，使用 $p_{j|i}$ 表示 $x_j$ 是 $x_i$ 邻域的概率，如果两个点很接近，那么 $p_{j|i}$ 就会很大</p>
<script type="math/tex; mode=display">
 p_{j|i}=\frac{\exp(-\frac{\Vert x_i-x_j\Vert^2}{2\sigma_i^2})}{\sum_{k\not=i}\exp(-\frac{\Vert x_i-x_k\Vert^2}{2\sigma_i^2})}</script><ul>
<li><p>将上述公式对称化相似性矩阵</p>
<script type="math/tex; mode=display">
p_{ij}=\frac{p_{j|i}+p_{i|j}}{2n}</script></li>
</ul>
</li>
<li><p>计算低维空间中的相似性。在低维空间中，使用 t 分布表示数据点之间的相似性</p>
<script type="math/tex; mode=display">
 q_{ij}=\frac{(1+\Vert y_i-y_j\Vert^2)^{-1}}{\sum_{k\not=l}(1+\Vert y_k-y_l\Vert^2)^{-1}}</script></li>
<li><p>最小化 KL 散度：利用梯度下降法最小化高维和低维空间相似性分布之间的 KL 散度</p>
<script type="math/tex; mode=display">
 \mathbb{D}_{KL}(P\Vert Q)=\sum_{i\not=j}p_{ij}\log\frac{p_{ij}}{q_{ij}}</script></li>
</ol>
<hr>
<p><strong>优点</strong></p>
<ul>
<li>能够有效保留高维数据的局部结构，适合展示聚类结构</li>
<li>可视化效果优秀，特别适合高维数据的 2D 或 3D 可视化</li>
</ul>
<hr>
<p><strong>缺点</strong></p>
<ul>
<li>计算复杂度高，适合中小规模数据</li>
<li>对超参数（如困惑度）敏感</li>
<li>不保留全局结构，可能导致不同聚类之间的距离失真</li>
</ul>
<hr>
<h3 id="自编码器"><a href="#自编码器" class="headerlink" title="自编码器"></a>自编码器</h3><p>自编码器（Autoencoder）是一种无监督学习的神经网络模型，主要用于数据的降维、特征提取和去噪。它的核心思想是通过学习数据的低维表示（编码），然后从低维表示重构原始数据（解码），从而捕捉数据中的重要特征</p>
<hr>
<p><strong>结构</strong></p>
<p><img src="/Blog_NexT/2025/03/02/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E9%9D%9E%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/c091206df2cac821c53df341e9001e86.png" alt="c091206df2cac821c53df341e9001e86.png"></p>
<p>一个简单的自编码器如上图所示，上图中只有一个隐藏层，自编码器由两部分组成</p>
<ul>
<li><p>编码器：将数据映射到低维表示，如图中就是将数据从输入层映射到隐藏层</p>
<script type="math/tex; mode=display">
  z=f(x)=\sigma(W_ex+b_e)</script><ul>
<li>其中 $W_e$ 是权重矩阵， $b_e$ 是偏置向量， $\sigma$ 是激活函数</li>
</ul>
</li>
<li><p>解码器：将低维表示映射回重构数据，图中数据从隐藏层映射到输出层</p>
<script type="math/tex; mode=display">
  \hat{x}=g(z)=\sigma(W_dx+b_d)</script><ul>
<li>其中 $W_d$ 是权重矩阵， $b_d$ 是偏置向量， $\sigma$ 是激活函数</li>
</ul>
</li>
</ul>
<hr>
<p><strong>自编码器类型</strong></p>
<ul>
<li>普通自编码器：由编码器和解码器组成，用于简单的降维和特征提取任务</li>
<li>稀疏自编码器：在损失函数中加入稀疏性约束，使得编码 $z$ 大部分元素接近于 0，用于提取稀疏特征</li>
<li>去噪自编码器：在输入数据中加入噪声，训练模型从噪声数据中重构原始数据，用于数据去噪和鲁棒特征提取</li>
<li>变分自编码器：基于概率生成模型，学习数据的潜在分布，用于生成新数据和数据分布建模</li>
<li>卷积自编码器：使用卷积神经网络作为编码器和解码器，用于图像的降维和特征提取</li>
</ul>
<hr>
<p><strong>普通自编码器</strong></p>
<p>自编码器的目标是最小化输入数据与输出数据之间的差异，通常用均方误差作为损失函数</p>
<script type="math/tex; mode=display">
\mathcal{L}(x,\hat{x})=\Vert x-\hat{x}\Vert^2</script><p>通过不断学习更新参数</p>
<hr>
<p><strong>稀疏自编码器</strong></p>
<p>稀疏性约束有两种方式实现</p>
<ul>
<li><p>L1 正则化</p>
<script type="math/tex; mode=display">
  \mathcal{L}(x,\hat{x})=\Vert x-\hat{x}\Vert^2+\lambda\Vert z\Vert_1</script></li>
<li><p>KL 散度约束</p>
<script type="math/tex; mode=display">
  KL(\rho\Vert\hat{\rho})=\rho\log\frac{\rho}{\hat{\rho}}+(1-\rho)\log\frac{1-\rho}{1-\hat{\rho}}\\\mathcal{L}(x,\hat{x})=\Vert x-\hat{x}\Vert^2+\lambda\sum_jKL(\rho\Vert\hat{\rho}_j)</script><ul>
<li>假设编码的激活概率为 $\hat{\rho}$ ，目标稀疏概率为 $\rho$ ，而 $\hat{\rho}_j$ 是第 $j$ 个编码单元的激活概率</li>
</ul>
</li>
</ul>
<hr>
<p><strong>去噪自编码器</strong></p>
<p>去噪自编码器需要对输入数据加入噪声，用得到的噪声数据 $\tilde{x}$ 作为新的输入数据去做映射。最终用得到的重构数据 $\hat{x}$ 与原始输入数据 $x$ 作比较，最小化两者之间的差异</p>
<p>加入噪声的方式有如下几种</p>
<ul>
<li>加性高斯噪声： $\tilde{x}=x+\varepsilon\quad\varepsilon\sim\mathcal{N}(0,\sigma^2)$</li>
<li>掩码噪声：随机将输入数据的一部分元素置为零</li>
<li>椒盐噪声：随机将输入数据的一部分元素设置为最大值或最小值</li>
</ul>
<hr>
<p><strong>变分自编码器</strong></p>
<p>核心思想如下</p>
<ul>
<li>输入数据映射到映射到潜在分布的参数，得到潜在分布的均值和方差</li>
<li>从潜在分布中采样得到潜在变量 $z$</li>
<li>将潜在变量映射回重构数据 $\hat{x}$</li>
<li>通过最大化数据的对数似然和最小化潜在分布与先验分布之间的KL散度来训练模型</li>
</ul>
<p>假设潜在变量 $z$ 服从标准正态分布 $z\sim\mathcal(\mu,\sigma)$ ，编码器输出潜在分布的均值和方差 $\mu,\sigma$ ，潜在变量通过重参数化技巧采样 $z=\mu+\sigma\varepsilon$ 其中 $\varepsilon\sim\mathcal{N}(0,I)$</p>
<p>变分自编码器的损失函数包括两部分</p>
<ul>
<li>重构误差</li>
<li>KL 散度：衡量潜在分布 $q(z|x)$ 与先验分布 $p(z)$ 之间的差异</li>
</ul>
<p>损失函数公式如下</p>
<script type="math/tex; mode=display">
KL(q(z|x)\Vert p(z))=\frac{1}{2}\sum_i(\sigma_i^2+\mu_i^2-1-\log(\sigma_i^2))\\\mathcal{L}(x,\hat{x})=\Vert x-\hat{x}\Vert^2+KL(q(z|x)\Vert p(z))</script><hr>
<p><strong>卷积自编码器</strong></p>
<p>是一种基于卷积神经网络（CNN）的自编码器，专门用于处理图像数据</p>
<ul>
<li>编码器：使用卷积层和池化层逐步提取图像的局部特征，并将图像压缩为低维表示</li>
<li>解码器：使用反卷积层（或转置卷积层）和上采样层逐步将低维表示重构为原始图像</li>
</ul>
<hr>
<h3 id="独立成分分析"><a href="#独立成分分析" class="headerlink" title="独立成分分析"></a>独立成分分析</h3><p>独立成分分析（Independent Component Analysis，ICA）能够有效地从混合信号中分离出相互独立的成分。ICA 假设观测信号是多个独立源信号的线性组合，通过寻找一个线性变换，使得变换后的信号尽可能独立</p>
<hr>
<p><strong>核心思想</strong></p>
<p>ICA 的目标是从混合信号中恢复出独立的信号源。假设观测信号 $x$ 是源信号 $s$ 的线性混合</p>
<script type="math/tex; mode=display">
x=As</script><p>其中 $A$ 是混合矩阵</p>
<p>ICA 通过寻找一个解混矩阵 $W$ 使得变换后的信号 $y$ 尽可能独立</p>
<script type="math/tex; mode=display">
y=Wx</script><p>其中 $y$ 是估计的源信号</p>
<hr>
<p><strong>峭度</strong></p>
<p>是统计学中用于描述概率分布形状的一个重要指标，特别是用于衡量分布的尾部厚度和尖峰程度</p>
<script type="math/tex; mode=display">
Kurtosis(X)=\frac{E[(X-\mu)^4]}{\sigma^4}</script><ul>
<li>$X$ 是随机变量</li>
<li>$\mu$ 是 $X$ 的均值</li>
<li>$\sigma$ 是 $X$ 的标准差</li>
<li>$E$ 表示期望</li>
</ul>
<p>性质</p>
<ul>
<li>基准值：对于正态分布（高斯分布），峭度为 3</li>
<li>超额峭度：为了便于比较一般会使用超额峭度 $Excess Kurtosis(X)=Kurtosis(X)-3$ ，超额峭度的基准值为 0</li>
<li>分布形状<ul>
<li>正峭度：分布比正态分布更尖峰</li>
<li>负峭度：分布比正正态分布更平坦，尾部更薄</li>
</ul>
</li>
</ul>
<p>峭度值解释</p>
<ul>
<li>正峭度表示数据分布具有更多的极端值或异常值</li>
<li>负峭度表示数据分布较为平坦，极端值较少</li>
</ul>
<hr>
<p><strong>负熵</strong></p>
<p>基于信息熵的概念，用于衡量信号与高斯分布的偏离程度</p>
<script type="math/tex; mode=display">
J(y)=H(y_{Gauss})-H(y)</script><ul>
<li>$H(y)$ 是信号源 $y$ 的熵</li>
<li>$H(y_{Gauss})$ 是与 $y$ 具有相同方差的高斯分布的熵</li>
<li>熵是衡量随机变量不确定性的指标，定义为 $H(y)=-\int p(y)\log p(y)dy$</li>
<li>对于高斯分布，熵的计算公式为 $H(y_{Gauss})=\frac{1}{2}\log(2\pi e\sigma^2)$ ， $\sigma^2$ 是信号的方差</li>
</ul>
<p>性质</p>
<ul>
<li>非负性：负熵 $J(y)\geq0$ ，当且仅当 $y$ 是高斯分布时 $J(y)=0$</li>
<li>非高斯性度量：负熵越大，信号的非高斯性越强</li>
<li>鲁棒性：负熵对信号的幅度不敏感</li>
</ul>
<hr>
<p><strong>步骤</strong></p>
<ol>
<li>ICA 假设源信号是统计独立的，独立性意味着联合概率分布可以分解为边缘概率分布的乘积 $p(s_1,…s_n)=\prod_{i=1}^np(s_i)$</li>
<li>ICA 假设源信号是非高斯的，因为高斯信号的独立性无法通过线性变换恢复</li>
<li><p>优化目标：ICA 通过最大化非高斯性来估计解混矩阵 $W$ ，常用的非高斯性度量有</p>
<ul>
<li><p>峭度（Kurtosis）：是衡量信号分布尖峰程度的一个指标</p>
<script type="math/tex; mode=display">
  Kurtosis(y)=E[y^4]-3(E[y^2])^2</script></li>
<li><p>负熵（Negentropy）：用于衡量信号与高斯分布的偏离程度</p>
<script type="math/tex; mode=display">
  J(y)=H(y_{Gauss})-H(y)</script></li>
</ul>
</li>
<li><p>求解，常用的算法如下</p>
<ul>
<li>FastICA：基于负熵的快速算法<ul>
<li>收敛速度较快，适合处理大规模数据</li>
<li>对初始值不敏感，具有较好的鲁棒性</li>
<li>支持多种非线性函数，适应不同的数据特性</li>
</ul>
</li>
<li>Infomax：基于互信息最大化的算法<ul>
<li>基于信息理论，具有明确的数学解释</li>
<li>适用于多种信号分离任务</li>
<li>对初始值不敏感，具有较好的鲁棒性</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<p><strong>FastICA</strong></p>
<p>是一种基于负熵最大化的快速独立成分分析（ICA）算法，用于从混合信号中分离出独立的源信号，通过最大化非高斯性（通常使用负熵作为度量）来估计独立的源信号</p>
<ol>
<li><p>中心化：将观测信号的均值调整为零</p>
<script type="math/tex; mode=display">
 X^\prime=X-mean(X)</script></li>
<li><p>白化数据：对观测信号进行白化处理，得到白化信号</p>
<script type="math/tex; mode=display">
 \Sigma_X=E[X^\prime(X^\prime)^T]\\\Sigma_X=VDV^T\\Z=D^{-\frac{1}{2}}V^TX^\prime</script><ul>
<li>$D$ 是对角阵，包含协方差矩阵的特征值</li>
<li>$V$ 是特征向量矩阵</li>
<li>$Z$ 是白化处理之后的数据信号，经过白化处理后，信号的协方差矩阵变为单位矩阵，信号之间的相关性被消除</li>
</ul>
</li>
<li><p>负熵最大化，通过最大化负熵来估计解混矩阵 $W$</p>
<script type="math/tex; mode=display">
 J(y)=\sum_i^mk_i(E[G_i(y)]-E[G_i(v)])^2</script><ul>
<li>$G_i$ 是非线性函数</li>
<li>$v$ 是标准高斯随机变量</li>
<li>$k_i$ 是权重系数</li>
</ul>
</li>
<li><p>迭代更新：使用固定点算法迭代更新解混向量</p>
<script type="math/tex; mode=display">
 w^+=E[zg(w^Tz)]-E[g^\prime(w^Tz)]w</script><ul>
<li>$g$ 是非线性函数</li>
<li>归一化处理 $w=\frac{w^+}{\Vert w^+\Vert}$</li>
</ul>
</li>
<li>收敛：重复迭代直至收敛</li>
</ol>
<hr>
<p><strong>Infomax</strong></p>
<p>是一种基于信息理论的独立成分分析（ICA）算法，用于从混合信号中分离出独立的源信号。Infomax 的核心思想是通过最大化输出信号的互信息，使得变换后的信号尽可能独立</p>
<p>Infomax 的目标是找到一个线性变换使得变换后的信号的互信息最大化。互信息是衡量多个随机变量之间依赖性的指标，最大化互信息等价于最小化输出信号之间的依赖性</p>
<p>对于输出信号 $y$ 互信息定义为</p>
<script type="math/tex; mode=display">
I(y)=\sum_i^nH(y_i)-H(y)</script><ul>
<li>$H(y_i)$ 是单个输出信号 $y_i$ 的熵</li>
<li>$H(y)$ 是联合熵</li>
</ul>
<p>通过最大化 $I(y)$ 来分离出独立的源信号</p>
<ol>
<li>模型假设：假设源信号 $s$ 是统计独立的，观测信号是源信号的线性混合</li>
<li><p>优化目标函数，最大化输出信号的互信息</p>
<script type="math/tex; mode=display">
 I(y)=\sum_i^nH(y_i)-H(y)</script><ul>
<li>通过优化 $W$ 使得互信息最大化</li>
</ul>
</li>
<li><p>优化方法选择梯度上升法</p>
<script type="math/tex; mode=display">
 \frac{\partial I(y)}{\partial W}=\frac{\partial}{\partial W}(\sum_i^nH(y_i)-H(y))</script></li>
<li><p>非线性变换：为了简化计算，通常对输出信号 $y$ 进行非线性变换，其中 $g$ 是非线性函数</p>
<script type="math/tex; mode=display">
 y_i=g(w_i^Tx)</script></li>
</ol>
<hr>
<p><strong>优点</strong></p>
<ul>
<li>能够分离出独立的源信号。</li>
<li>适用于盲源分离问题，如语音信号分离和图像去噪等</li>
</ul>
<hr>
<p><strong>缺点</strong></p>
<ul>
<li>对噪声敏感</li>
<li>假设源信号是非高斯的，可能不适用于高斯信号</li>
<li>无法确定源信号的顺序和幅度</li>
</ul>
<hr>
<h3 id="多维缩放"><a href="#多维缩放" class="headerlink" title="多维缩放"></a>多维缩放</h3><p>多维缩放（Multidimensional Scaling，MDS）是一种降维技术，用于将高维数据映射到低维空间（通常是 2D 或 3D），同时尽可能保留数据点之间的距离关系。MDS的核心思想是通过低维空间中的点之间的距离来近似原始高维空间中的距离</p>
<hr>
<p><strong>基本原理</strong></p>
<p>MDS 的目标是找到一个低维表示，使得低维空间中的点之间的距离（如欧氏距离）尽可能接近原始高维空间中的距离。</p>
<p>一般步骤就是给定高维数据，计算数据点之间的成对距离，通过优化算法（如梯度下降）找到一个低维表示，使得低维空间中的距离矩阵与原始距离矩阵尽可能接近</p>
<hr>
<p><strong>类型</strong></p>
<ul>
<li>经典 MDS<ul>
<li>优点<ul>
<li>计算效率高，适合中小规模数据</li>
<li>能够保留全局距离关系</li>
<li>直观且易于理解</li>
</ul>
</li>
<li>缺点<ul>
<li>仅适用于欧氏距离</li>
<li>对于非线性数据结构，效果可能不如 t-SNE 或 UMAP</li>
</ul>
</li>
</ul>
</li>
<li>度量 MDS<ul>
<li>优点<ul>
<li>适用于任意距离度量，灵活性高</li>
<li>能够保留全局距离关系</li>
<li>适合处理非线性数据</li>
</ul>
</li>
<li>缺点<ul>
<li>计算复杂度较高，尤其是对于大规模数据</li>
<li>对于高维数据，可能需要较长的训练时间</li>
</ul>
</li>
</ul>
</li>
<li>非度量 MDS<ul>
<li>优点<ul>
<li>适用于非数值型数据或基于排序的距离</li>
<li>能够处理非线性关系</li>
<li>适合处理心理学实验中的相似性评分等数据</li>
</ul>
</li>
<li>缺点<ul>
<li>计算复杂度较高，尤其是对于大规模数据</li>
<li>对于高维数据，可能需要较长的训练时间</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<p><strong>步骤</strong></p>
<ol>
<li>对于高维数据点 $X:\{x_1,…x_n\}$ ，计算数据点之间的成对距离</li>
<li>降维优化<ul>
<li>对于经典 MDS，通过特征值分解求解低维表示</li>
<li>对于度量 MDS，通过优化算法最小化应力函数</li>
</ul>
</li>
<li>输出低维表示<ul>
<li>得到低维空间中的点 $Y:\{y_1,…y_n\}$</li>
</ul>
</li>
</ol>
<hr>
<p><strong>经典 MDS</strong></p>
<p>经典 MDS 专门用于处理欧氏距离矩阵，通过特征值分解（Eigenvalue Decomposition）直接求解低维表示，是一种高效且直观的降维方法</p>
<ol>
<li>对于高维数据点 $X:\{x_1,…x_n\}$ ，计算数据点两两之间的欧式距离 $D=\{d_{ij}=\Vert x_i-x_j\Vert\}$</li>
<li><p>中心化距离矩阵，构造中心化矩阵 $B$</p>
<script type="math/tex; mode=display">
 B=-\frac{1}{2}HD^2H</script><ul>
<li>$D^2$ 是距离矩阵的平方</li>
<li>$H$ 是中心化矩阵 $H=I-\frac{1}{n}\vec{1}\vec{1}^T$ ，其中 $\vec{1}$ 是全 1 向量</li>
</ul>
</li>
<li><p>特征值分解，对 $B$ 进行特征值分解</p>
<script type="math/tex; mode=display">
 B=Q\Lambda Q^T</script><ul>
<li>$Q$ 是特征向量矩阵</li>
<li>$\Lambda$ 是特征值对角矩阵</li>
</ul>
</li>
<li><p>选择主成分：选择前 $k$ 个最大特征值对应的特征向量，构成低维表示</p>
<script type="math/tex; mode=display">
 Y=Q_k\Lambda_k^{\frac{1}{2}}</script><ul>
<li>$Q_k$ 是前 $k$ 个特征向量</li>
<li>$\Lambda_k$ 是前 $k$ 个特征值</li>
</ul>
</li>
</ol>
<hr>
<p><strong>度量 MDS</strong></p>
<p>度量 MDS 的目标是找到一个低维表示，使得低维空间中的点之间的距离尽可能接近原始高维空间中的距离。度量 MDS 不局限于欧氏距离，可以处理任意距离度量</p>
<ol>
<li>对于高维数据点 $X:\{x_1,…x_n\}$ ，计算数据点两两之间的任意距离 $D=\{d_{ij}\}$ 这个距离可以是任意距离，例如曼哈顿距离等</li>
<li><p>度量MDS通过优化算法（如梯度下降）最小化下述应力函数</p>
<script type="math/tex; mode=display">
 Stress=\sqrt{\frac{\sum_{i,j}(d_{ij}-\hat{d}_{ij})^2}{\sum_{i,j}d_{ij}^2}}</script><ul>
<li>$d_{ij}$ 是原始高维空间中的距离</li>
<li>$\hat{d}_{ij}$ 是低维空间中的距离</li>
</ul>
</li>
<li>使用梯度下降或其他优化算法，逐步调整低维表示 $Y:\{y_1,…y_n\}$ 使得应力函数最小化</li>
</ol>
<hr>
<p><strong>非度量 MDS</strong></p>
<p>非度量MDS的目标是找到一个低维表示，使得低维空间中的点之间的距离的相对顺序尽可能接近原始高维空间中的距离的相对顺序，不关注距离的绝对数值，而是关注距离的排名或顺序</p>
<ol>
<li>对于高维数据点 $X:\{x_1,…x_n\}$ ，计算数据点两两之间的距离排序 $D=\{d_{ij}\}$ ，是基于排序或等级的距离</li>
<li><p>度量MDS通过优化算法（如梯度下降）最小化下述应力函数</p>
<script type="math/tex; mode=display">
 Stress=\sqrt{\frac{\sum_{i,j}(f(d_{ij})-\hat{d}_{ij})^2}{\sum_{i,j}d_{ij}^2}}</script><ul>
<li>$d_{ij}$ 是原始高维空间中的距离</li>
<li>$\hat{d}_{ij}$ 是低维空间中的距离</li>
<li>$f$ 是一个单调递增函数，用于将原始距离映射到低维空间中的距离</li>
</ul>
</li>
<li>使用梯度下降或其他优化算法，逐步调整低维表示 $Y:\{y_1,…y_n\}$ 使得应力函数最小化</li>
</ol>
<hr>
<p><strong>优点</strong></p>
<ul>
<li>直观且易于理解，适合可视化</li>
<li>能够保留数据点之间的全局距离关系</li>
<li>适用于多种距离度量（尤其是度量 MDS 和非度量 MDS）</li>
</ul>
<hr>
<p><strong>缺点</strong></p>
<ul>
<li>计算复杂度较高，尤其是对于大规模数据</li>
<li>对于非线性数据结构，效果可能不如 t-SNE 或 UMAP</li>
<li>经典MDS仅适用于欧氏距离</li>
</ul>
<hr>
<h3 id="UMAP"><a href="#UMAP" class="headerlink" title="UMAP"></a>UMAP</h3><p>UMAP (Uniform Manifold Approximation and Projection) 是一种非线性降维和可视化算法，特别适用于可视化和聚类高维数据。UMAP 基于基于图论和流形学习理论，旨在保留数据局部和全局结构的同时，将高维数据映射到低维空间（通常是 2D 或 3D）</p>
<hr>
<p><strong>特点</strong></p>
<ul>
<li>UMAP 假设数据分布在一个低维流形上，通过近似流形的拓扑结构来实现降维，能够捕捉数据的局部和全局结构</li>
<li>UMAP 使用随机近邻图（k-nearest neighbors graph）和概率模型来优化降维过程，相比 t-SNE，计算效率更高，尤其是在处理大规模数据集时</li>
<li>与 t-SNE 相比，UMAP 在保留数据全局结构方面表现更好，同时也能捕捉局部结构</li>
<li>参数<ul>
<li><code>n_neighbors</code> 控制局部结构的粒度，较小的值更关注局部结构，较大的值更关注全局结构</li>
<li><code>min_dist</code> 控制低维空间中点的分布，较小的值会使点更聚集，较大的值会使点更分散</li>
<li><code>n_components</code> 指定降维之后的维度</li>
</ul>
</li>
</ul>
<hr>
<p><strong>原理</strong></p>
<ol>
<li><p>构建高维图：在高维数据中构建一个图结构，以捕捉数据的局部和全局关系</p>
<ol>
<li>计算 k-nearest neighbors ，对于每个点找到其最近的 <code>n_neighbors</code> 个邻居</li>
<li><p>对于每个点及其邻居，计算它们之间的概率相似度</p>
<script type="math/tex; mode=display">
 p_{i|j}=\exp(-\frac{d(x_i.x_j)-\rho_i}{\sigma_i})</script><ul>
<li>$d(x_i,x_j)$ 是两个点之间的距离</li>
<li>$\rho_i$ 是点 $i$ 到其最近邻居的距离</li>
<li>$\sigma_i$ 是一个放缩参数，通过二分法确定，使得点 $i$ 的邻居概率总和为 $\log_2(n)$ ，其中 $n$ 等于 <code>n_neighbors</code></li>
</ul>
</li>
<li><p>将概率矩阵对称化，得到高维空间的联合概率分布</p>
<script type="math/tex; mode=display">
 p_{ij}=p_{i|j}+p_{j|i}-p_{i|j}p_{j|i}</script></li>
</ol>
</li>
<li><p>在低维空间（通常是 2D 或 3D）中随机初始化点的位置</p>
</li>
<li><p>构建低维图：在低维空间中，UMAP 使用类似的图结构来表示点之间的关系</p>
<ol>
<li><p>计算低维空间中的概率相似度</p>
<script type="math/tex; mode=display">
 q_{ij}=(1+a\cdot d(y_i,y_j)^{2b})^{-1}</script><ul>
<li>$d(y_i,y_j)$ 是低维空间中两个点之间的距离</li>
<li>$a$ 和 $b$ 是超参数，通常通过曲线拟合确定</li>
</ul>
</li>
</ol>
</li>
<li><p>低维优化，通过优化目标函数，使低维空间中的图结构尽可能接近高维空间中的图结构</p>
<ol>
<li><p>目标函数，UMAP 的目标是最小化高维和低维概率分布之间的交叉熵。这个目标函数鼓励高维空间中相似的点在低维空间中靠近，而不相似的点在低维空间中远离</p>
<script type="math/tex; mode=display">
 \mathcal{L}=\sum_{i,j}p_{ij}\log\frac{p_{ij}}{q_{ij}}+(1-p_{ij})\log\frac{1-p_{ij}}{1-q_{ij}}</script></li>
<li><p>使用梯度下降法更新低维空间中点的位置，以最小化目标函数，其中 $\alpha$ 是学习率</p>
<script type="math/tex; mode=display">
 y_i=y_i-\alpha\frac{\partial\mathcal{L}}{\partial y_i}</script></li>
</ol>
</li>
<li><p>输出低维嵌入：经过优化后，UMAP 输出低维空间中的点坐标，这些坐标可以用于可视化或进一步分析</p>
</li>
</ol>
<hr>
<p><strong>优点</strong></p>
<ul>
<li>速度快：比 t-SNE 更快，适合大规模数据集</li>
<li>全局结构保留：在降维时能更好地保留数据的全局结构</li>
<li>灵活性：参数可调，适应不同场景</li>
</ul>
<hr>
<p><strong>缺点</strong></p>
<ul>
<li>参数选择对结果影响较大，需要根据具体数据调整</li>
<li>对于某些复杂的高维数据，可能无法完全保留所有结构</li>
</ul>
<hr>
<h3 id="Truncated-SVD"><a href="#Truncated-SVD" class="headerlink" title="Truncated SVD"></a>Truncated SVD</h3><p>Truncated SVD（截断奇异值分解，Truncated Singular Value Decomposition）是奇异值分解（SVD）的一种变体，主要用于降维和特征提取。它通过保留最重要的奇异值和对应的奇异向量，将高维数据映射到低维空间，同时尽可能保留数据的主要信息</p>
<hr>
<p><strong>奇异值分解</strong></p>
<p>奇异值分解是将一个矩阵 $A$ 分解为三个矩阵的乘积</p>
<script type="math/tex; mode=display">
A=U\Sigma V^T</script><ul>
<li>$A\in R^{m\times n}$</li>
<li>$U\in R^{m\times m}$ 的正交阵，其列向量称为左奇异向量</li>
<li>$\Sigma\in R^{m\times n}$ 的对角矩阵，对角线上的元素称为奇异值</li>
<li>$V\in R^{n\times n}$ 的正交矩阵，其列向量称为右奇异向量</li>
</ul>
<hr>
<p><strong>核心思想</strong></p>
<p>Truncated SVD 通过只保留前 $k$ 个最大的奇异值及其对应的奇异向量，将原始矩阵 $A$ 近似为一个低秩矩阵 $A_k$</p>
<script type="math/tex; mode=display">
A_k=U_k\Sigma_kV_k^T</script><ul>
<li>$U_k\in R^{m\times k}$ 是 $U$ 的前 $k$ 列</li>
<li>$\Sigma_k\in R^{k\times k}$ 是 $\Sigma$ 的前 $k$ 个奇异值</li>
<li>$V_k\in R^{n\times k}$ 是 $V$ 的前 $k$ 列</li>
</ul>
<p>通过这种方式，将原始矩阵降维为 $A_k$</p>
<hr>
<p><strong>步骤</strong></p>
<ol>
<li>计算 SVD，对矩阵 $A$ 进行奇异值分解，得到 $U,\Sigma,V$</li>
<li>选择截断值，根据需求选择保留奇异值数量 $k$ ，通常基于奇异值的衰减情况或降维目标来选择</li>
<li>保留前 $k$ 个奇异值及其对应的奇异向量，得到 $U_k,\Sigma_k,V_k$</li>
<li>重构低秩矩阵 $A_k=U_k\Sigma_kV_k^T$</li>
</ol>
<hr>
<p><strong>优点</strong></p>
<ul>
<li>将高维数据映射到低维空间，减少计算复杂度</li>
<li>通过丢弃较小的奇异值，去除数据中的噪声</li>
<li>提取数据的主要特征，适用于分类、聚类等任务</li>
<li>对于稀疏矩阵，Truncated SVD 可以高效处理</li>
</ul>
<hr>
<p><strong>缺点</strong></p>
<ul>
<li>对数据缩放敏感</li>
<li>计算复杂度较高</li>
<li>对噪声敏感</li>
<li>需要手动选择截断值 $k$</li>
<li>对稀疏数据的处理效率有限</li>
</ul>
<hr>
<h3 id="非负矩阵分解"><a href="#非负矩阵分解" class="headerlink" title="非负矩阵分解"></a>非负矩阵分解</h3><p>非负矩阵分解（Non-negative Matrix Factorization, NMF） 是一种用于降维和特征提取的矩阵分解方法。与 Truncated SVD 和 PCA 不同，NMF 要求分解后的矩阵中的所有元素均为非负数</p>
<hr>
<p><strong>矩阵分解</strong></p>
<p>对于一个非负矩阵 $A\in R^{m\times n}$ ，NMF 目标是将其分解为两个非负矩阵 $W\in R^{m\times k}$ 和 $H\in R^{k\times n}$</p>
<script type="math/tex; mode=display">
A\approx W\cdot H</script><ul>
<li>$W$ 是基矩阵，表示数据的特征</li>
<li>$H$ 是系数矩阵，表示数据在特征空间中的表示</li>
<li>$k$ 是降维后的维度</li>
</ul>
<hr>
<p><strong>步骤</strong></p>
<ol>
<li>确定降维后的维度</li>
<li>根据输入数据 $A\in R^{m\times n}$ 初始化基矩阵 $W\in R^{m\times k}$ 和系数矩阵 $H\in R^{k\times n}$ ，有两种初始化的方法<ul>
<li>随机初始化：随机生成两个矩阵</li>
<li>NNDSVD（Non-negative Double Singular Value Decomposition）：基于 SVD 的初始化方法，能够加速收敛</li>
</ul>
</li>
<li><p>NMF 通过迭代优化算法来最小化原始矩阵 $A$ 和分解结果 $W\cdot H$ 之间的差异，常用的方法如下</p>
<ul>
<li><p>基于欧式距离的更新规则</p>
<script type="math/tex; mode=display">
  W_{ij}^{k+1}=W_{ij}^k\frac{(A(H^k)^T)_{ij}}{(W^kH^k(H^k)^T)_{ij}}\\H_{ij}^{k+1}=H^k_{ij}\frac{((W^k)^TA)_{ij}}{((W^k)^TW^kH^k)_{ij}}</script></li>
<li><p>基于 KL 散度的更新规则</p>
<script type="math/tex; mode=display">
  W^{k+1}_{ij}=W^k_{ij}\frac{\sum_mH_{jm}^kA_{im}/(W^kH^k)_{im}}{\sum_mH^k_{jm}}\\H^{k+1}_{ij}=H^k_{ij}\frac{\sum_mW_{jm}^kA_{im}/(W^kH^k)_{im}}{\sum_mW^k_{jm}}</script></li>
<li><p>梯度下降法：通过梯度下降法更新两个矩阵</p>
<script type="math/tex; mode=display">
  W^{k+1}=W^k-\alpha_W\cdot\nabla_W\Vert A-W^kH^k\Vert^2_F\\H^{k+1}=H^k-\alpha_H\cdot\nabla_H\Vert A-W^kH^k\Vert^2_F</script><ul>
<li>其中 $\alpha_w,\alpha_H$ 是学习率</li>
</ul>
</li>
</ul>
</li>
<li>收敛判断：在每次迭代后，检查目标函数（如欧氏距离或 KL 散度）是否收敛。常用的收敛条件如下<ul>
<li>目标函数的变化小于某个阈值</li>
<li>达到最大迭代次数</li>
</ul>
</li>
<li>输出结果，算法收敛之后，输出基矩阵和系数矩阵<ul>
<li>基矩阵 $W$ 表示数据的特征</li>
<li>系数矩阵 $H$ 表示数据在特征空间中的表示</li>
</ul>
</li>
</ol>
<hr>
<p><strong>NNDSVD</strong></p>
<p>NNDSVD（Non-negative Double Singular Value Decomposition） 是一种用于非负矩阵分解（NMF）的初始化方法，通过奇异值分解（SVD）为 NMF 提供一个更好的初始解，从而加速收敛并提高分解结果的质量</p>
<ol>
<li><p>对矩阵 $A$ 进行奇异值分解</p>
<script type="math/tex; mode=display">
 A=U\Sigma V^T</script><ul>
<li>$A\in R^{m\times n}$</li>
<li>$U\in R^{m\times m}$ 的正交阵，其列向量称为左奇异向量</li>
<li>$\Sigma\in R^{m\times n}$ 的对角矩阵，对角线上的元素称为奇异值</li>
<li>$V\in R^{n\times n}$ 的正交矩阵，其列向量称为右奇异向量</li>
</ul>
</li>
<li>选择前 $k$ 个奇异值和奇异向量<ul>
<li>$U_k\in R^{m\times k}$ 是 $U$ 的前 $k$ 列</li>
<li>$\Sigma_k\in R^{k\times k}$ 是 $\Sigma$ 的前 $k$ 个奇异值</li>
<li>$V_k\in R^{n\times k}$ 是 $V$ 的前 $k$ 列</li>
</ul>
</li>
<li>构造非负初始化矩阵 $W$ 和 $H$<ul>
<li>基矩阵 $W=U_k\sqrt{\Sigma_k}$</li>
<li>系数矩阵 $H=\sqrt{\Sigma_k}V_k^T$</li>
<li>计算完成之后，将两个矩阵中的负值设置为 0，保证非负性</li>
</ul>
</li>
<li>调整初始值：进一步提高初始化的质量<ul>
<li>将两个矩阵中的零值替换为一个较小的整数</li>
<li>对两个矩阵进行归一化，使其满足某些约束条件</li>
</ul>
</li>
</ol>
<hr>
<p><strong>优点</strong></p>
<ul>
<li>非负性：分解结果均为非负数</li>
<li>由于非负约束，NMF 的结果通常更容易解释</li>
<li>NMF 能够很好地处理稀疏矩阵</li>
<li>NMF 可以提取数据的局部特征，适用于图像分解、主题建模等任务</li>
</ul>
<hr>
<p><strong>缺点</strong></p>
<ul>
<li>NMF 的优化目标是非凸的，可能导致局部最优解</li>
<li>分解结构依赖于 $W$ 和 $H$ 的初始值，不同初始值可能导致不同的结果</li>
<li>对于大规模数据，NMF 的计算成本较高</li>
<li>需要手动选择降维后的维度 $k$ ，选择不当可能影响结果</li>
<li>NMF 要求输入矩阵为非负数，对于包含负值的数据需要预处理</li>
</ul>
<hr>
<h3 id="随机投影"><a href="#随机投影" class="headerlink" title="随机投影"></a>随机投影</h3><p>随机投影（Random Projection） 是一种用于降维的快速且高效的技术，特别适用于高维数据的降维和近似计算。核心思想是通过随机矩阵将高维数据投影到低维空间，同时保留数据的主要结构</p>
<hr>
<p><strong>Johnson-Lindenstrauss 引理</strong></p>
<p>给定一组 $n$ 个点的高维数据，存在一个低维空间（维度为 $k=O(\epsilon^2\log n)$ ），使得这些点之间的距离在投影后近似保持不变，误差不超过 $1\plusmn\epsilon$ </p>
<hr>
<p><strong>步骤</strong></p>
<ol>
<li>输入高维数据矩阵 $X\in R^{n\times d}$ ，目标维度为 $k$</li>
<li>构造随机矩阵 $R\in R^{d\times k}$ ，常用如下随机矩阵生成方法<ul>
<li>高斯随机矩阵：矩阵所有元素服从标准正态分布 $\mathcal{N}(0,1)$</li>
<li>稀疏随机矩阵：矩阵元素以概率 $\frac{p}{2}$ 取 $\plusmn s$ ，以概率 $1-p$ 取 0， $s$ 是缩放因子，通常取 1 或 $\sqrt{3}$</li>
<li>Achlioptas 随机矩阵：矩阵元素以概率 $\frac{1}{6}$ 取 $\plusmn\sqrt{3}$ ，以概率 $\frac{2}{3}$ 取 0</li>
<li>Li 随机矩阵：矩阵元素以 $\frac{1}{2\sqrt{d}}$ 取 $\plusmn1$ ，以概率 $1-\frac{1}{\sqrt{d}}$ 取 0</li>
</ul>
</li>
<li>计算并输出低维投影 $Y=XR$</li>
</ol>
<hr>
<p><strong>优点</strong></p>
<ul>
<li>随机投影的计算复杂度为 $O(ndk)$ ，远低于其他降维方法</li>
<li>由于计算效率高，随机投影特别适合处理大规模高维数据</li>
<li>随机投影能够近似保持高维数据中的距离和相似性</li>
<li>随机投影不需要对数据进行训练，直接生成随机矩阵即可</li>
</ul>
<hr>
<p><strong>缺点</strong></p>
<ul>
<li>随机投影是一种近似方法，可能会引入一定的误差</li>
<li>由于随机矩阵的生成具有随机性，每次投影的结果可能不同</li>
<li>随机投影是一种线性降维方法，无法捕捉数据中的非线性结构</li>
</ul>
<hr>
<h2 id="关联规则学习"><a href="#关联规则学习" class="headerlink" title="关联规则学习"></a>关联规则学习</h2><p>关联规则学习（Association Rule Learning） 是一种从大规模数据集中发现变量之间有趣关系的数据挖掘技术，主要用于发现数据中的频繁模式、关联规则和相关性</p>
<hr>
<h3 id="一些基本概念"><a href="#一些基本概念" class="headerlink" title="一些基本概念"></a>一些基本概念</h3><ul>
<li>项集：一个项集是数据集中一个或多个项的集合</li>
<li><p>支持度：项集的支持度是指数据集中包含该项集的事务的比例</p>
<script type="math/tex; mode=display">
  Support(\{A,B\})=\frac{\text{包含}A\text{和}B\text{的事务数}}{\text{总事务数}}</script></li>
<li><p>置信度：置信度是指包含一个项集的事务中同时包含另一个项集的比例，表示这条规则的可信度</p>
<script type="math/tex; mode=display">
  Confidence(A\rightarrow B)=\frac{Support(\{A,B\})}{Support(\{A\})}</script></li>
<li><p>提升度：用于衡量规则的相关性</p>
<script type="math/tex; mode=display">
  Lift(A\rightarrow B)=\frac{Support(\{A,B\})}{Support(\{A\})\cdot Support(\{B\})}</script><ul>
<li>如果提升度大于 1，说明 $A$ 和 $B$ 正相关</li>
<li>如果提升度等于 1，说明 $A$ 和 $B$ 独立</li>
<li>如果提升度小于 1，说明 $A$ 和 $B$ 负相关</li>
</ul>
</li>
<li>频繁项集：对于项集 $A$ 如果其支持度满足预定义的最小支持度阈值，则 $A$ 是频繁项集</li>
<li>最小支持度：衡量支持度的一个阈值，表示项目集在统计意义上的最低重要性</li>
<li>最小置信度：衡量置信度的一个阈值，表示关联规则的最低可靠性</li>
<li>强规则：同时满足最小支持度阈值和最小置信度阈值的规则</li>
</ul>
<hr>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li>生成频繁项集：使用算法找出支持度大于最小支持度阈值的频繁项集<ul>
<li>Apriori 算法</li>
<li>FP-Growth 算法</li>
<li>Eclat 算法</li>
</ul>
</li>
<li>生成关联规则：从频繁项集中生成置信度大于最小置信度阈值的关联规则，从频繁项集中生成置信度大于最小置信度的规则，计算置信度还是要使用原来的事务来计算</li>
<li>评估规则：使用支持度、置信度、提升度等指标评估规则的有效性和相关性</li>
</ol>
<hr>
<h3 id="Apriori-算法"><a href="#Apriori-算法" class="headerlink" title="Apriori 算法"></a>Apriori 算法</h3><p>Apriori 算法是生成频繁项集的经典方法，基于逐层搜索和剪枝的思想</p>
<hr>
<p><strong>核心原理</strong></p>
<ul>
<li>先验性质：如果一个项集是频繁的，那么它的所有子集也一定是频繁的</li>
<li>通过逐层生成候选项集并剪枝，逐步找到所有频繁项集</li>
</ul>
<hr>
<p><strong>算法步骤</strong></p>
<ol>
<li>生成候选项集<ol>
<li>从单个项（1-项集）开始，生成所有可能的候选项集</li>
<li>对于数据集中的项 $\{A,B,C\}$ ，则 1-项集为 $\{A\},\{B\},\{C\}$</li>
</ol>
</li>
<li><p>扫描数据集，计算每个候选项集的支持度</p>
<script type="math/tex; mode=display">
 Support(\{X\})=\frac{\text{包含}X\text{的事务数}}{\text{总事务数}}</script></li>
<li><p>删除支持度低于最小支持度阈值的项集，保留频繁项集</p>
</li>
<li>生成更高阶的候选项集，通过连接频繁项集生成更高阶的候选项集 <ol>
<li>例如频繁 1-项集 $\{A\},\{B\},\{C\}$ 可以生成 2-项集 $\{A,B\},\{B,C\},\{A,C\}$</li>
</ol>
</li>
<li>重复上述迭代步骤，直到无法生成更高阶的候选项集</li>
</ol>
<hr>
<p><strong>用例子介绍具体步骤</strong></p>
<p>首先定义最小支持度为 0.5，对于一组事务如下</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>TID</th>
<th>项</th>
</tr>
</thead>
<tbody>
<tr>
<td>001</td>
<td>r z h j p</td>
</tr>
<tr>
<td>002</td>
<td>z y x w v u t s</td>
</tr>
<tr>
<td>003</td>
<td>z</td>
</tr>
<tr>
<td>004</td>
<td>r x n o s</td>
</tr>
<tr>
<td>005</td>
<td>y r x z q t p</td>
</tr>
<tr>
<td>006</td>
<td>y z x e q s t m</td>
</tr>
</tbody>
</table>
</div>
<p>生成候选项集 1-项集，计算每个候选项集的支持度，如下</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>r</th>
<th>z</th>
<th>h</th>
<th>j</th>
<th>p</th>
<th>y</th>
<th>x</th>
<th>w</th>
<th>v</th>
<th>u</th>
<th>t</th>
<th>s</th>
<th>n</th>
<th>o</th>
<th>q</th>
<th>e</th>
<th>m</th>
</tr>
</thead>
<tbody>
<tr>
<td>0.50</td>
<td>0.83</td>
<td>0.17</td>
<td>0.17</td>
<td>0.33</td>
<td>0.50</td>
<td>0.67</td>
<td>0.17</td>
<td>0.17</td>
<td>0.17</td>
<td>0.50</td>
<td>0.50</td>
<td>0.17</td>
<td>0.17</td>
<td>0.17</td>
<td>0.17</td>
<td>0.17</td>
</tr>
</tbody>
</table>
</div>
<p>将不满足最小支持度的项都去掉，得到最终得到 $r,z,y,x,t,s$ ，然后得到 2-项集，并且计算对应的支持度，如下</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>{r, z}</th>
<th>{r, y}</th>
<th>{r, x}</th>
<th>{r, t}</th>
<th>{r, s}</th>
<th>{z, y}</th>
<th>{z, x}</th>
<th>{z, t}</th>
<th>{z, s}</th>
<th>{y, x}</th>
<th>{y, t}</th>
<th>{y, s}</th>
<th>{x, t}</th>
<th>{x, s}</th>
<th>{t, s}</th>
</tr>
</thead>
<tbody>
<tr>
<td>0.33</td>
<td>0.17</td>
<td>0.33</td>
<td>0.17</td>
<td>0.17</td>
<td>0.5</td>
<td>0.5</td>
<td>0.5</td>
<td>0.33</td>
<td>0.5</td>
<td>0.5</td>
<td>0.33</td>
<td>0.5</td>
<td>0.5</td>
<td>0.33</td>
</tr>
</tbody>
</table>
</div>
<p>将不满足最小支持度的项去掉，得到满足的项有 $\{z,y\}, \{z,x\}, \{z,t\}, \{y,x\}, \{y,t\}, \{x,t\}, \{x,s\}$ ，然后组合得到如下的项集和对应的支持度</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>{z, y, x}</th>
<th>{z, y, t}</th>
<th>{z, x, y, t}</th>
<th>{z, y, x, s}</th>
<th>{z, x, t}</th>
<th>{z, x, s}</th>
<th>{z, x, s, t}</th>
<th>{y, x, t}</th>
<th>{y, x, s}</th>
<th>{y, x, s, t}</th>
<th>{x, s, t}</th>
</tr>
</thead>
<tbody>
<tr>
<td>0.5</td>
<td>0.5</td>
<td>0.5</td>
<td>0.33</td>
<td>0.5</td>
<td>0.33</td>
<td>0.33</td>
<td>0.5</td>
<td>0.33</td>
<td>0.33</td>
<td>0.33</td>
</tr>
</tbody>
</table>
</div>
<p>将不满足最小支持度的项都去掉，得到满足的项有 $\{z, y, x\},\{z, y, t\},\{z, x, y, t\},\{z, x, t\},\{y, x, t\}$ ，但是它们之间的组合无法得到更新的项集了算法停止</p>
<p>上述的项集中，满足最小支持度要求的都是频繁项集，如下</p>
<ul>
<li>1-项集 $\{r\},\{z\},\{y\},\{x\},\{t\},\{s\}$</li>
<li>2-项集 $\{z,y\}, \{z,x\}, \{z,t\}, \{y,x\}, \{y,t\}, \{x,t\}, \{x,s\}$</li>
<li>3-项集 $\{z, y, x\},\{z, y, t\},\{z, x, y, t\},\{z, x, t\},\{y, x, t\}$</li>
</ul>
<hr>
<p><strong>优点</strong></p>
<ul>
<li>简单易懂，易于实现</li>
</ul>
<hr>
<p><strong>缺点</strong></p>
<ul>
<li>计算复杂度高，需要多次扫描数据集</li>
<li>生成的候选项集数量可能非常大</li>
</ul>
<hr>
<h3 id="FP-Growth-算法"><a href="#FP-Growth-算法" class="headerlink" title="FP-Growth 算法"></a>FP-Growth 算法</h3><p>FP-Growth 算法是一种基于 FP 树（Frequent Pattern Tree）的高效频繁项集生成方法</p>
<hr>
<p><strong>核心思想</strong></p>
<ul>
<li>通过构建 FP 树压缩数据集，避免生成候选项集</li>
<li>使用分治法递归挖掘频繁项集</li>
</ul>
<hr>
<p><strong>步骤</strong></p>
<ol>
<li>构建 FP 树<ol>
<li>扫描数据集，统计每个项的支持度，删除支持度低于阈值的项，将剩余的项按支持度从高到低排序</li>
<li>再次扫描数据集，将每条事务插入 FP 树中，FP 树的每个节点包含事务中的项的名称和支持度计数，每条事务中的项按支持度从高到低排序</li>
<li>如果 FP 树中已存在相同前缀路径，则增加相应节点的计数，否则，创建新节点</li>
</ol>
</li>
<li>对于每个项，生成其条件模式基（即包含该项的所有路径的前缀路径）</li>
<li>对于每个项，根据条件模式基构建条件 FP 树</li>
<li>从条件 FP 树中递归挖掘频繁项集</li>
</ol>
<hr>
<p><strong>构建 FP 树</strong></p>
<p>由于构建 FP 树的流程比较复杂，所以这里详细解释一下</p>
<p>对于一组事务如下</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>TID</th>
<th>项</th>
</tr>
</thead>
<tbody>
<tr>
<td>001</td>
<td>r z h j p</td>
</tr>
<tr>
<td>002</td>
<td>z y x w v u t s</td>
</tr>
<tr>
<td>003</td>
<td>z</td>
</tr>
<tr>
<td>004</td>
<td>r x n o s</td>
</tr>
<tr>
<td>005</td>
<td>y r x z q t p</td>
</tr>
<tr>
<td>006</td>
<td>y z x e q s t m</td>
</tr>
</tbody>
</table>
</div>
<p>计算每个项的支持度，就是包含该项的事务占所有事务的比例</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>r</th>
<th>z</th>
<th>h</th>
<th>j</th>
<th>p</th>
<th>y</th>
<th>x</th>
<th>w</th>
<th>v</th>
<th>u</th>
<th>t</th>
<th>s</th>
<th>n</th>
<th>o</th>
<th>q</th>
<th>e</th>
<th>m</th>
</tr>
</thead>
<tbody>
<tr>
<td>0.50</td>
<td>0.83</td>
<td>0.17</td>
<td>0.17</td>
<td>0.33</td>
<td>0.50</td>
<td>0.67</td>
<td>0.17</td>
<td>0.17</td>
<td>0.17</td>
<td>0.50</td>
<td>0.50</td>
<td>0.17</td>
<td>0.17</td>
<td>0.17</td>
<td>0.17</td>
<td>0.17</td>
</tr>
</tbody>
</table>
</div>
<p>这里选择最小支持度为 0.2，将上述事务中的项按照支持度重新排列</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>项</th>
</tr>
</thead>
<tbody>
<tr>
<td>001</td>
<td>z r</td>
</tr>
<tr>
<td>002</td>
<td>z x y t s</td>
</tr>
<tr>
<td>003</td>
<td>z</td>
</tr>
<tr>
<td>004</td>
<td>x s r</td>
</tr>
<tr>
<td>005</td>
<td>z x y t r</td>
</tr>
<tr>
<td>006</td>
<td>z x y t s</td>
</tr>
</tbody>
</table>
</div>
<p>再次扫描，开始构造 FP 树，具体过程如下图所示，依次是事务 1 到 6 构建 FP 树，其中蓝色的线表示相同项，最后一张图片就是最终创建出的 FP 树</p>
<p><img src="/Blog_NexT/2025/03/02/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E9%9D%9E%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/%E4%BA%8B%E5%8A%A1001.png" alt="事务001.png"></p>
<p><img src="/Blog_NexT/2025/03/02/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E9%9D%9E%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/%E4%BA%8B%E5%8A%A1002.png" alt="事务002.png"></p>
<p><img src="/Blog_NexT/2025/03/02/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E9%9D%9E%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/%E4%BA%8B%E5%8A%A1003.png" alt="事务003.png"></p>
<p><img src="/Blog_NexT/2025/03/02/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E9%9D%9E%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/%E4%BA%8B%E5%8A%A1004.png" alt="事务004.png"></p>
<p><img src="/Blog_NexT/2025/03/02/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E9%9D%9E%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/%E4%BA%8B%E5%8A%A1005.png" alt="事务005.png"></p>
<p><img src="/Blog_NexT/2025/03/02/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E9%9D%9E%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/%E4%BA%8B%E5%8A%A1006.png" alt="事务006.png"></p>
<hr>
<p><strong>得到条件模式基</strong></p>
<p>对于每一个元素项，获得其对应的条件模式基（conditional pattern base)，单个元素项的条件模式基也就是元素项的关键字，条件模式基是以所查找元素项为结尾的路径集合。每一条路径其实都是一条前辍路径，一条前缀路径是介于所査找元素项与树根节点之间的所有内容</p>
<p>对于上述创建出的 FP 树，求每一个元素项的条件模式基，寻找条件模式基的过程实际上是从 FP 树的每个叶子节点回溯到根节点的过程</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>条件模式基</th>
</tr>
</thead>
<tbody>
<tr>
<td>z</td>
<td>{}</td>
</tr>
<tr>
<td>x</td>
<td>{z}</td>
</tr>
<tr>
<td>y</td>
<td>{z, x}</td>
</tr>
<tr>
<td>t</td>
<td>{z, x, y}</td>
</tr>
<tr>
<td>s</td>
<td>{z}, {z, x, y, t}, {x}</td>
</tr>
<tr>
<td>r</td>
<td>{z}, {z, x, y, t}, {x, s}</td>
</tr>
</tbody>
</table>
</div>
<hr>
<p><strong>构建条件树</strong></p>
<p>为了发现更多的频繁项集，对于每一个频繁项，都创建一棵条件 FP 树，使用上述的条件模式基作为输入数据，构建条件 FP 树。然后，递归地发现频繁项、发现条件模式基，以及发现另外的条件树</p>
<p>例如，对于 r 元素的条件模式基来说，将其的每一个条件模式基都作为一个事务，以次来构建 FP 树，这里选择最小支持度为 0.5，可以得到如下支持度列表</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>z</th>
<th>x</th>
<th>y</th>
<th>t</th>
<th>s</th>
</tr>
</thead>
<tbody>
<tr>
<td>0.67</td>
<td>0.67</td>
<td>0.33</td>
<td>0.33</td>
<td>0.33</td>
</tr>
</tbody>
</table>
</div>
<p>将事务项重新排列得到</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>001</th>
<th>z</th>
</tr>
</thead>
<tbody>
<tr>
<td>002</td>
<td>z x</td>
</tr>
<tr>
<td>003</td>
<td>x</td>
</tr>
</tbody>
</table>
</div>
<p>构建出的条件 FP 树如下</p>
<p><img src="/Blog_NexT/2025/03/02/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E9%9D%9E%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/1740388689013.png" alt="1740388689013.png"></p>
<p>得到 r 的条件模式为 $\{z,x\},\{x\}$ 并且没有其他能满足最小支持度的路径，所以 r 的条件树只有上述一个。但是需要注意的是 $\{z,x\}$ 中的 x 与 $\{x\}$ 中的 x 是不同的，在 $\{z,x\}$ 中，z 是 x 的父节点，在构造条件 FP 树时，不能直接移除父节点，仅能从子节点开始逐级移除，得到频繁项集 $\{z,x\},\{x\}$</p>
<p>对于每一个元素项都进行构建条件树，最终发现频繁项集 $\{z,x\},\{x\}$ 两个频繁项集</p>
<hr>
<p><strong>优点</strong></p>
<ul>
<li>计算效率高，只需扫描数据集两次</li>
<li>不生成候选项集，节省存储空间和计算资源</li>
<li>适用于稀疏数据集和大规模数据</li>
<li>内存效率高，通过 FP 树压缩数据</li>
</ul>
<hr>
<p><strong>缺点</strong></p>
<ul>
<li>实现复杂，尤其是 FP 树的构建和递归挖掘</li>
<li>对内存要求较高，处理超大规模数据时可能受限</li>
<li>不适合动态数据集</li>
<li>对最小支持度敏感，设置不当可能导致性能下降</li>
<li>难以并行化，限制了在分布式环境中的应用</li>
</ul>
<hr>
<h3 id="Eclat-算法"><a href="#Eclat-算法" class="headerlink" title="Eclat 算法"></a>Eclat 算法</h3><p>Eclat算法（Equivalence Class Clustering and bottom-up Lattice Traversal）是一种用于挖掘频繁项集的算法，采用垂直数据格式和深度优先搜索策略，通过交集操作高效发现频繁项集，特别适合处理稠密数据集</p>
<hr>
<p><strong>步骤</strong></p>
<ol>
<li>将水平格式的事务数据集转换为垂直格式（项-TID 集），移除支持度低于最小支持度的项</li>
<li>扫描垂直数据格式，统计每个项的支持度，筛选出频繁 1-项集</li>
<li>对于每个频繁 (k-1)-项集，与其他频繁 (k-1)-项集进行交集操作，生成候选 k-项集。计算候选 k-项集的支持度（交集的大小），如果支持度满足最小支持度，则保留为频繁k-项集</li>
<li>当无法生成新的频繁项集时，算法终止</li>
</ol>
<hr>
<p><strong>用例子介绍具体步骤</strong></p>
<p>首先定义最小支持度为 0.5，对于一组事务如下</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>TID</th>
<th>项</th>
</tr>
</thead>
<tbody>
<tr>
<td>001</td>
<td>r z h j p</td>
</tr>
<tr>
<td>002</td>
<td>z y x w v u t s</td>
</tr>
<tr>
<td>003</td>
<td>z</td>
</tr>
<tr>
<td>004</td>
<td>r x n o s</td>
</tr>
<tr>
<td>005</td>
<td>y r x z q t p</td>
</tr>
<tr>
<td>006</td>
<td>y z x e q s t m</td>
</tr>
</tbody>
</table>
</div>
<p>转换为垂直格式得到</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>r</th>
<th>z</th>
<th>h</th>
<th>j</th>
<th>p</th>
<th>y</th>
<th>x</th>
<th>w</th>
<th>v</th>
<th>u</th>
<th>t</th>
<th>s</th>
<th>n</th>
<th>o</th>
<th>q</th>
<th>e</th>
<th>m</th>
</tr>
</thead>
<tbody>
<tr>
<td>1, 4, 5</td>
<td>1, 2, 3, 5, 6</td>
<td>1</td>
<td>1</td>
<td>1, 5</td>
<td>2, 5, 6</td>
<td>2, 4, 5, 6</td>
<td>2</td>
<td>2</td>
<td>2</td>
<td>2, 5, 6</td>
<td>2, 4, 6</td>
<td>4</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>6</td>
</tr>
</tbody>
</table>
</div>
<ol>
<li>扫描生成频繁 1-项集 $r, z, y, x, t, s$</li>
<li>生成频繁 2-项集</li>
</ol>
<pre><code>| $&#123;r\cap z&#125;$ | $&#123;r\cap y&#125;$ | $&#123;r\cap x&#125;$ | $&#123;r\cap t&#125;$ | $&#123;r\cap s&#125;$ | $&#123;z\cap y&#125;$ | $&#123;z\cap x&#125;$ | $&#123;z\cap t&#125;$ | $&#123;z\cap s&#125;$ | $&#123;y\cap x&#125;$ | $&#123;y\cap t&#125;$ | $&#123;y\cap s&#125;$ | $&#123;x\cap t&#125;$ | $&#123;x\cap s&#125;$ | $&#123;t\cap s&#125;$ |
| ----------- | ----------- | ----------- | ----------- | ----------- | ----------- | ----------- | ----------- | ----------- | ----------- | ----------- | ----------- | ----------- | ----------- | ----------- |
| 1, 5        | 5           | 4, 5        | 5           | 4           | 2, 5, 6     | 2, 5, 6     | 2, 5, 6     | 2, 6        | 2, 5, 6     | 2, 5, 6     | 2, 6        | 2, 5, 6     | 2, 4, 6     | 2, 6        |
- 生成频繁 2-项集为 $\&#123;z,y\&#125;, \&#123;z,x\&#125;, \&#123;z,t\&#125;, \&#123;y,x\&#125;, \&#123;y,t\&#125;, \&#123;x,t\&#125;, \&#123;x,s\&#125;$
</code></pre><ol>
<li>生成频繁 3-项集</li>
</ol>
<pre><code>| $&#123;z\cap y\cap x&#125;$ | $&#123;z\cap y\cap t&#125;$ | $&#123;z\cap x\cap y\cap t&#125;$ | $&#123;z\cap y\cap x\cap s&#125;$ | $&#123;z\cap x\cap t&#125;$ | $&#123;z\cap x\cap s&#125;$ | $&#123;z\cap x\cap s\cap t&#125;$ | $&#123;y\cap x\cap t&#125;$ | $&#123;y\cap x\cap s&#125;$ | $&#123;y\cap x\cap s\cap t&#125;$ | $&#123;x\cap s\cap t&#125;$ |
| ----------------- | ----------------- | ----------------------- | ----------------------- | ----------------- | ----------------- | ----------------------- | ----------------- | ----------------- | ----------------------- | ----------------- |
| 2, 5, 6           | 2, 5, 6           | 2, 5, 6                 | 2, 6                    | 2, 5, 6           | 2, 6              | 2, 6                    | 2, 5, 6           | 2, 6              | 2, 6                    | 2, 6              |
- 生成频繁 3-项集为 $\&#123;z, y, x\&#125;,\&#123;z, y, t\&#125;,\&#123;z, x, y, t\&#125;,\&#123;z, x, t\&#125;,\&#123;y, x, t\&#125;$
</code></pre><ol>
<li>此时无法生成新的频繁项集时，算法终止</li>
<li>得到频繁项集如下<ul>
<li>1-项集 $\{r\},\{z\},\{y\},\{x\},\{t\},\{s\}$</li>
<li>2-项集 $\{z,y\}, \{z,x\}, \{z,t\}, \{y,x\}, \{y,t\}, \{x,t\}, \{x,s\}$</li>
<li>3-项集 $\{z, y, x\},\{z, y, t\},\{z, x, y, t\},\{z, x, t\},\{y, x, t\}$</li>
</ul>
</li>
</ol>
<hr>
<p><strong>优点</strong></p>
<ul>
<li>使用垂直数据格式和交集操作，避免了生成大量候选集</li>
<li>在项集出现频率较高的情况下表现优异</li>
<li>深度优先搜索策略减少了内存占用</li>
</ul>
<hr>
<p><strong>缺点</strong></p>
<ul>
<li>在项集出现频率较低的情况下，性能可能下降</li>
<li>对于大规模数据集，TID 集的存储和计算可能成为瓶颈</li>
</ul>
<hr>
<h3 id="生成关联规则示例"><a href="#生成关联规则示例" class="headerlink" title="生成关联规则示例"></a>生成关联规则示例</h3><p>首先定义最小支持度为 0.5，设定最小置信度为 0.7，对于一组事务如下</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>TID</th>
<th>项</th>
</tr>
</thead>
<tbody>
<tr>
<td>001</td>
<td>r z h j p</td>
</tr>
<tr>
<td>002</td>
<td>z y x w v u t s</td>
</tr>
<tr>
<td>003</td>
<td>z</td>
</tr>
<tr>
<td>004</td>
<td>r x n o s</td>
</tr>
<tr>
<td>005</td>
<td>y r x z q t p</td>
</tr>
<tr>
<td>006</td>
<td>y z x e q s t m</td>
</tr>
</tbody>
</table>
</div>
<p>通过 Apriori 算法中所得到的频繁项集如下</p>
<ul>
<li>1-项集 $\{r\},\{z\},\{y\},\{x\},\{t\},\{s\}$</li>
<li>2-项集 $\{z,y\}, \{z,x\}, \{z,t\}, \{y,x\}, \{y,t\}, \{x,t\}, \{x,s\}$</li>
<li>3-项集 $\{z, y, x\},\{z, y, t\},\{z, x, y, t\},\{z, x, t\},\{y, x, t\}$</li>
</ul>
<ol>
<li>先在 3-项集中寻找规则<ul>
<li>$z,y\rightarrow x=\frac{3}{3}=1$</li>
<li>$x,y\rightarrow z=\frac{3}{3}=1$</li>
<li>$x,z\rightarrow y=\frac{3}{3}=1$</li>
<li>……</li>
</ul>
</li>
<li>在 2-项集中寻找规则<ul>
<li>$z\rightarrow y=\frac{3}{5}=0.6$</li>
<li>$y\rightarrow z=\frac{3}{3}=1$</li>
<li>……</li>
</ul>
</li>
</ol>
<p>可以得到有用的关联规则</p>
<hr>
<h2 id="密度估计"><a href="#密度估计" class="headerlink" title="密度估计"></a>密度估计</h2><p>密度估计是机器学习中的一种重要技术，用于估计数据的概率分布，在许多任务中都有应用，例如异常检测、生成模型和数据可视化</p>
<p>密度估计的目标是从观测数据中估计出数据的概率密度函数</p>
<hr>
<h3 id="马尔可夫链蒙特卡罗"><a href="#马尔可夫链蒙特卡罗" class="headerlink" title="马尔可夫链蒙特卡罗"></a>马尔可夫链蒙特卡罗</h3><p>马尔可夫链蒙特卡罗（MCMC，Markov Chain Monte Carlo）方法是一类通过构建马尔可夫链来从复杂概率分布中采样的算法，在难以直接采样时非常有效</p>
<hr>
<p><strong>步骤</strong></p>
<ol>
<li>选择一个初始状态 $x_0$</li>
<li>通过采样算法来逐步生成新状态 $x_{t+1}$ ，采样方法如下<ul>
<li>Hamiltonian Monte Carlo</li>
<li>Metropolis-Hastings 算法</li>
<li>Gibbs 采样</li>
</ul>
</li>
<li>运行足够长的时间以达到平稳分布，判断收敛的方法有<ul>
<li>目测法：观察样本路径是否稳定</li>
<li>统计检验：如 Gelman-Rubin 统计量</li>
<li>自相关性分析：检查样本的自相关性是否降低</li>
</ul>
</li>
<li>当马尔可夫链达到平稳分布时，生成的样本可以视为来自目标分布 $p(x)$</li>
<li><p>这些样本用于蒙特卡罗估计来计算需要的数据，例如计算目标函数的期望</p>
<script type="math/tex; mode=display">
 E[f(x)]=\frac{1}{N}\sum_t^Nf(x_t)</script></li>
</ol>
<hr>
<p><strong>Hamiltonian Monte Carlo</strong></p>
<p>是一种高效的马尔可夫链蒙特卡罗（MCMC）方法，特别适用于高维空间的采样，结合了物理系统中的哈密顿动力学和蒙特卡罗采样，通过引入动量变量来探索目标分布，避免了随机游走的低效性</p>
<ol>
<li>物理类比<ol>
<li>将目标分布 $p(x)$ 看作一个势能函数 $U(x)=-\log p(x)$</li>
<li>引入动量 $v$ 与 $x$ 共同构成相空间 $(x,v)$</li>
<li>系统的总能量（哈密顿量）为 $H(x,v)=U(x)+K(v)$ 其中 $K(v)=\frac{v^Tv}{2}$ 是动量</li>
</ol>
</li>
<li>动力学模拟<ol>
<li>通过模拟哈密顿动力学生成 $(x,v)$ 的轨迹</li>
<li>动力学方程由哈密顿方程描述 $\frac{dx}{dt}=\frac{\partial H}{\partial v},\frac{dv}{dt}=-\frac{\partial H}{\partial x}$</li>
</ol>
</li>
<li>蒙特卡罗采样<ol>
<li>利用动力学轨迹生成候选状态</li>
<li>通过 Metropolis-Hastings 步骤接受或拒绝候选状态，确保采样正确性</li>
</ol>
</li>
</ol>
<p>具体步骤</p>
<ol>
<li>选择初始状态 $x_0$ ，初始化动量变量 $v_0$ ，通常从高斯分布 $v_0\sim\mathcal{N}(0,M)$ 中采样，其中 $M$ 是质量矩阵，但可以根据目标分布的特性调整</li>
<li><p>从当前状态 $(x_t,v_t)$ 出发，模拟哈密顿动力学轨迹</p>
<ol>
<li>计算梯度：计算势能函数的梯度 $\nabla U(x)$</li>
<li><p>交替更新动量和位置，其中 $\epsilon$ 是控制动力学模拟的步长，步长过大会导致模拟不准确，步长过小会降低效率</p>
<script type="math/tex; mode=display">
 v_{k+1}=v_k-\frac{\epsilon}{2}\nabla U(x)\\x_{k+1}=x_{k}+\epsilon M^{-1}v</script></li>
<li><p>重复上述步骤 $L$ 次，得到候选状态 $(x^\star,v^\star)$ ，步数 $L$ 是每次模拟的步数过短会导致探索不足，过长会增加计算成本</p>
</li>
</ol>
</li>
<li><p>M-H 接受/拒绝</p>
<ol>
<li><p>计算哈密顿量的变化</p>
<script type="math/tex; mode=display">
 \Delta H=H(x^\star,v^\star)-H(x_t,v_t)</script></li>
<li><p>计算接受概率</p>
<script type="math/tex; mode=display">
 A=\min(1,\exp(-\Delta H))</script></li>
<li><p>从均匀分布 $U(0,1)$ 中生成随机数 $u$</p>
<ul>
<li>$u\leq A$ ，接受候选状态 $x^\star$ 作为新状态 $x_{t+1}$</li>
<li>否则保留 $x_{t+1}=x_t$</li>
</ul>
</li>
</ol>
</li>
<li>重复迭代，直到生成足够多的样本</li>
<li>丢弃预热样本，例如丢弃前 1000 个样本，以减少初始值的影响</li>
</ol>
<hr>
<p><strong>Metropolis-Hastings</strong></p>
<p>Metropolis-Hastings（MH）是一种经典的马尔可夫链蒙特卡罗（MCMC）方法，用于从复杂的目标分布中采样</p>
<ol>
<li>初始化，选择一个初始状态 $x_0$ ，初始状态可以是任意值，但接近目标分布的高概率区域会加速收敛。初始化样本集合 $S:\{\}$ </li>
<li><p>迭代采样，对于每次迭代 $t=0,1,…$ 采取以下步骤</p>
<ol>
<li>从提议分布 $q(x^\prime\vert x_t)$ 中生成候选状态 $x^\prime$ ，提议分布可以是任意的，但是通常选择对称分布 $q(x^\prime\vert x_t)=q(x_t\vert x^\prime)$ 。提议分布的选择对算法效率至关重要，如果提议分布过于狭窄，链会缓慢探索空间，如果过于宽泛，接受率会很低</li>
<li><p>计算接受概率 $A(x^\prime\vert x_t)$</p>
<script type="math/tex; mode=display">
 A(x^\prime\vert x_t)=\min(1,\frac{p(x^\prime)q(x_t\vert x^\prime)}{p(x_t)q(x^\prime\vert x_t)})</script></li>
<li><p>从均匀分布 $U(0,1)$ 中生成随机数 $u$</p>
<ul>
<li>$u\leq A(x^\prime\vert x_t)$ ，接受候选状态 $x^\star$ 作为新状态 $x_{t+1}$</li>
<li>否则保留 $x_{t+1}=x_t$</li>
</ul>
</li>
</ol>
</li>
<li>从均匀分布 $U(0,1)$ 中生成随机数 $u$<ul>
<li>$u\leq A(x^\prime\vert x_t)$ ，接受候选状态 $x^\star$ 作为新状态 $x_{t+1}$</li>
<li>否则保留 $x_{t+1}=x_t$</li>
</ul>
</li>
<li>将新状态加入样本集合</li>
<li>运行马尔可夫链足够长的时间，直到链达到平稳分布</li>
<li>丢弃预热样本，例如丢弃前 1000 个样本，以减少初始值的影响</li>
</ol>
<hr>
<p><strong>Gibbs 采样</strong></p>
<p>Gibbs 采样 是一种特殊的马尔可夫链蒙特卡罗（MCMC）方法，用于从多维概率分布中采样，通过依次更新每个维度，利用条件分布生成样本，避免了接受概率的计算</p>
<ol>
<li>选择多维初始状态 $x^{(0)}=\{x_1^{(0)},…x_n^{(0)}\}$ ，初始化样本集合 $S:\{\}$</li>
<li>迭代采样，对于每次迭代 $t=0,1,…$ 采取以下步骤<ol>
<li>对于每个维度做如下工作</li>
<li>从条件分布 $P(x_i\vert x_{-i}^{(t)})$ 中采样新值 $x_i^{(t+1)}$ ，其中 $x_{-i}^{(t)}$ 表示当前状态下除了第 $i$ 个维度以外的其他维度</li>
<li>将 $x_i^{(t+1)}$ 更新到当前状态中</li>
<li>完成所有维度的更新之后，将新状态 $x^{(t+1)}=\{x_1^{(t+1)},…x_n^{(t+1)}\}$ 加入样本集合 $S$ 中</li>
</ol>
</li>
<li>运行足够长时间，直到马尔可夫链达到平稳</li>
<li>丢弃预热样本，例如丢弃前 1000 个样本，以减少初始值的影响</li>
</ol>
<hr>
<p><strong>优点</strong></p>
<ul>
<li>适用于各种复杂分布</li>
<li>在满足条件下，马尔可夫链都会收敛到目标分布</li>
</ul>
<hr>
<p><strong>缺点</strong></p>
<ul>
<li>在高维或复杂分布下，收敛可能较慢</li>
<li>调参比较复杂</li>
</ul>
<hr>
<h3 id="变分推断"><a href="#变分推断" class="headerlink" title="变分推断"></a>变分推断</h3><p>变分推断（Variational Inference, VI） 是一种用于近似复杂概率分布的方法，广泛应用于贝叶斯推断和机器学习中，与马尔可夫链蒙特卡罗（MCMC）方法不同，变分推断通过优化问题来找到一个近似分布，而不是通过采样，将推断问题转化为优化问题，从而在计算效率和精度之间取得平衡</p>
<hr>
<p><strong>核心思想</strong></p>
<ol>
<li>目标：给定一个复杂的后验分布 $P(z\vert x)$ ，变分推断的目标是找到一个简单的近似分布 $Q(z)$ 使其尽可能接近 $P(z\vert x)$</li>
<li>通过最小化 $Q(z)$ 与 $P(z\vert x)$ 之间的差异来找到最佳近似分布，通常用 KL 散度来衡量</li>
<li>$Q(z)$ 通常选择易于处理的分布族，称为变分分布族</li>
</ol>
<hr>
<p><strong>步骤</strong></p>
<ol>
<li>定义变分分布族，选择一个简单的分布族 $Q(z,\theta)$ ，其中 $\theta$ 是变分参数</li>
<li><p>目标是最小化 $Q(z,\theta)$ 与 $P(z\vert x)$ 之间的 KL 散度，如下</p>
<script type="math/tex; mode=display">
 KL(Q(z,\theta)\Vert P(z\vert x))=E_{Q(z,\theta)}[\log\frac{Q(z,\theta)}{P(z\vert x)}]</script></li>
<li><p>由于 $P(z\vert x)$ 难以计算，通常优化其等价形式</p>
<script type="math/tex; mode=display">
 \mathcal{L}(\theta)=E_{Q(z,\theta)}[\log{P(z\vert x)}-\log{Q(z,\theta)}]</script><ul>
<li>$\mathcal{L}(\theta)$ 被称为证据下界 ELBO</li>
</ul>
</li>
<li><p>通过梯度上升等优化算法，最大化 ELBO</p>
<script type="math/tex; mode=display">
 \theta^\star=\underset{\theta}{\arg\max}\mathcal{L}(\theta)</script><ul>
<li>由于优化过程中需要计算梯度 $\nabla_\theta\mathcal{L}(\theta)=\nabla_\theta E_{Q(z,\theta)}[\log{P(z\vert x)}-\log{Q(z,\theta)}]$ ，一般会使用重参数化技巧（Reparameterization Trick）或评分函数估计（Score Function Estimator）来计算梯度</li>
</ul>
</li>
<li>优化完成之后，得到变分分布 $Q(z,\theta^\star)$ 作为后验分布 $P(z\vert x)$ 的近似</li>
</ol>
<hr>
<p><strong>优点</strong></p>
<ul>
<li>相比 MCMC，变分推断通常更快，适合大规模数据</li>
<li>变分推断是确定性方法，避免了 MCMC 的随机性</li>
</ul>
<hr>
<p><strong>缺点</strong></p>
<ul>
<li>变分分布族的选择可能引入偏差，导致近似不准确</li>
<li>优化过程可能陷入局部最优</li>
<li>需要对联合分布 $P(x,z)$ 进行建模</li>
</ul>
<hr>
<h3 id="密度估计的方法"><a href="#密度估计的方法" class="headerlink" title="密度估计的方法"></a>密度估计的方法</h3><ul>
<li>参数化的方法，假设数据服从某种已知的概率分布（如高斯分布），然后通过估计分布参数来拟合数据<ul>
<li>高斯分布</li>
<li>混合高斯模型</li>
</ul>
</li>
<li>非参数化方法，不对数据的分布做任何假设，直接从数据中估计密度函数<ul>
<li>直方图法（Histogram）</li>
<li>核密度估计（Kernel Density Estimation, KDE）</li>
<li>K 近邻密度估计（K-Nearest Neighbors, KNN）</li>
</ul>
</li>
<li>基于模型的方法，利用机器学习模型直接估计密度函数<ul>
<li>自回归模型（Autoregressive Models）</li>
<li>归一化流（Normalizing Flows）</li>
<li>变分自编码器（VAE）</li>
<li>生成对抗网络（Generative Adversarial Networks, GAN）</li>
</ul>
</li>
<li>其他方法<ul>
<li>最大熵密度估计</li>
<li>贝叶斯密度估计<ul>
<li>使用贝叶斯方法对密度函数进行估计</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="高斯分布密度估计"><a href="#高斯分布密度估计" class="headerlink" title="高斯分布密度估计"></a>高斯分布密度估计</h3><p>高斯分布（正态分布）密度估计是一种参数化方法，假设数据服从高斯分布，并通过估计分布的参数（均值和方差）来拟合数据</p>
<hr>
<p><strong>高斯分布</strong></p>
<p>高斯分布的概率密度函数为</p>
<script type="math/tex; mode=display">
p(x\vert \mu,\sigma^2)=\frac{1}{\sqrt{2\pi\sigma^2}}\exp(-\frac{(x-\mu)^2}{2\sigma^2})</script><ul>
<li>$\mu$ 是均值</li>
<li>$\sigma^2$ 是方差</li>
</ul>
<hr>
<p><strong>高斯分布的步骤</strong></p>
<ol>
<li>假设输入数据 $x:\{x_1,…x_n\}$ 独立分布，并且服从高斯分布 $\mathcal{N}(\mu,\sigma^2)$</li>
<li><p>估计参数，使用最大似然估计计算均值和方差</p>
<script type="math/tex; mode=display">
 \mu=\frac{1}{n}\sum_i^nx_i\\\sigma^2=\frac{1}{n}\sum_i^n(x_i-\mu)^2</script></li>
<li><p>将估计的均值和方差带入高斯分布的概率密度函数，得到密度函数 $\hat{p}(x)$</p>
</li>
<li>可视化结果：绘制原始数据的直方图和估计的高斯分布曲线</li>
</ol>
<hr>
<p><strong>优点</strong></p>
<ul>
<li>简单高效，计算速度快</li>
<li>对于服从高斯分布的数据，估计结果准确</li>
</ul>
<hr>
<p><strong>缺点</strong></p>
<ul>
<li>假设数据服从高斯分布，可能不适用于复杂数据（如多峰分布）</li>
<li>对于非高斯分布的数据，估计结果可能不准确</li>
</ul>
<hr>
<h3 id="混合高斯模型"><a href="#混合高斯模型" class="headerlink" title="混合高斯模型"></a>混合高斯模型</h3><p>混合高斯模型（Gaussian Mixture Model, GMM）是一种强大的密度估计方法，适用于数据分布复杂（如多峰分布）的情况，假设数据是由多个高斯分布混合而成，通过估计每个高斯分布的参数（均值、方差和混合系数）来拟合数据</p>
<hr>
<p><strong>模型定义</strong></p>
<p>混合高斯模型的概率密度函数为</p>
<script type="math/tex; mode=display">
p(x)=\sum_k^K\pi_k\cdot\mathcal{N}(x\vert \mu_k,\sigma_k)</script><ul>
<li>$K$ 是高斯分布的数量</li>
<li>$\pi_k$ 是第 $k$ 个高斯分布的混合系数，满足 $\sum_k^K\pi_k=1$</li>
<li><p>$\mathcal{N}(x\vert \mu_k,\sigma_k)$ 是第 $k$ 个高斯分布的概率密度函数</p>
<script type="math/tex; mode=display">
  \mathcal{N}(x\vert \mu_k,\sigma_k)=\frac{1}{(2\pi)^{d/2}\vert\sigma_k\vert^{1/2}}\exp(-\frac{1}{2}(x-\mu_k)^T\sigma_k^{-1}(x-\mu_k))</script></li>
</ul>
<hr>
<p><strong>混合高斯模型密度估计的步骤</strong></p>
<ol>
<li>初始化每个高斯分布的均值 $\mu_k$ ，协方差矩阵 $\sigma_k$ 和混合系数 $\pi_k$</li>
<li><p>E 步：计算每个数据点 $x_i$ 属于第 $k$ 个高斯分布的后验概率</p>
<script type="math/tex; mode=display">
 \gamma_{ik}=\frac{\pi_k\mathcal{N}(x_i\vert \mu_k,\sigma_k)}{\sum_j^K\pi_j\mathcal{N}(x_i\vert \mu_j,\sigma_j)}</script></li>
<li><p>M 步：更新参数</p>
<script type="math/tex; mode=display">
 \pi_k=\frac{1}{n}\sum_i^n\gamma_{ik}\\\mu_k=\frac{\sum_i^n\gamma_{ik}x_i}{\sum_i^n\gamma_{ik}}\\\sigma_k=\frac{\sum_i^n\gamma_{ik}(x_i-\mu_k)(x_i-\mu_k)^T}{\sum_i^n\gamma_{ik}}</script></li>
<li><p>迭代重复 E 步和 M 步，直到参数收敛或达到最大迭代次数</p>
</li>
<li>使用估计的参数计算混合高斯模型的概率密度函数</li>
</ol>
<hr>
<p><strong>优点</strong></p>
<ul>
<li>可以拟合复杂的多峰分布</li>
<li>灵活性强，适用于多种数据分布</li>
</ul>
<hr>
<p><strong>缺点</strong></p>
<ul>
<li>计算复杂度较高，尤其是高维数据</li>
<li>对初始参数敏感，可能收敛到局部最优解</li>
</ul>
<hr>
<h3 id="直方图法密度估计"><a href="#直方图法密度估计" class="headerlink" title="直方图法密度估计"></a>直方图法密度估计</h3><p>直方图法（Histogram）是一种简单直观的非参数化密度估计方法，通过将数据空间划分为若干区间，统计每个区间内的样本数量来估计概率密度函数</p>
<hr>
<p><strong>直方图法定义</strong></p>
<p>直方图法将数据空间划分为若干个区间，统计每个区间内样本的数量，然后除以总样本数和区间密度，得到每个区间的概率密度</p>
<p>得到概率密度函数的估计公式</p>
<script type="math/tex; mode=display">
\hat{p}(x)=\frac{\text{区间内样本的数量}}{nh}</script><ul>
<li>$n$ 是总样本数</li>
<li>$h$ 是区间宽度</li>
</ul>
<hr>
<p><strong>直方图密度估计的步骤</strong></p>
<ol>
<li>划分区间<ol>
<li>将数据范围划分为若干个等宽的区间</li>
<li>区间数量 $k$ 可以通过经验公式确定， $k=\log_2n+1$ ，其中 $n$ 是样本数量</li>
</ol>
</li>
<li>统计每个区间内的样本数量</li>
<li>用每个区间的样本数量除以总样本数和区间宽度，得到概率密度</li>
<li>绘制直方图，横轴为区间，纵轴为概率密度</li>
</ol>
<hr>
<p><strong>优点</strong></p>
<ul>
<li>简单直观，易于实现</li>
<li>计算速度快</li>
</ul>
<hr>
<p><strong>缺点</strong></p>
<ul>
<li>结果依赖于区间的划分，区间宽度选择对结果影响较大</li>
<li>密度估计不够平滑，可能丢失数据的细节信息</li>
</ul>
<hr>
<h3 id="核密度估计"><a href="#核密度估计" class="headerlink" title="核密度估计"></a>核密度估计</h3><p>核密度估计（Kernel Density Estimation，KDE）是一种非参数化密度估计方法，通过对每个数据点放置一个核函数并将所有核函数叠加，得到平滑的概率密度函数</p>
<hr>
<p><strong>和密度估计的概率密度函数</strong></p>
<script type="math/tex; mode=display">
\hat{p}(x)=\frac{1}{nh}\sum_{i=1}^nK(\frac{x-x_i}{h})</script><ul>
<li>$n$ 是样本数量</li>
<li>$h$ 是带宽，控制核函数的宽度</li>
<li>$K$ 是核函数</li>
</ul>
<hr>
<p><strong>核密度估计的步骤</strong></p>
<ol>
<li>选择核函数</li>
<li>选择带宽，带宽 $h$ 的选择对结果影响较大<ol>
<li>小带宽：核函数较窄，密度估计更关注局部细节，可能导致过拟合</li>
<li>大带宽：核函数较宽，密度估计更平滑，可能导致欠拟合</li>
</ol>
</li>
<li>计算密度函数：对每个数据点 $x_i$ 在 $x$ 处计算核函数的值，并将所有核函数的值相加，得到密度估计</li>
<li>绘制核密度估计曲线</li>
</ol>
<hr>
<p><strong>核函数选择方法</strong></p>
<ul>
<li>高斯核适用于大多数场景，平滑性好 $K(u)=\frac{1}{\sqrt{2\pi}}\exp(-\frac{1}{2}u^2)$</li>
<li>均匀核适用于离散数据，计算简单 $K(u)=\left\{\begin{aligned}&amp;\frac{1}{2}&amp;\vert u\vert\leq1\\&amp;0&amp;\vert u\vert&gt;1\end{aligned}\right.$</li>
<li>三角核介于高斯核和均匀核之间，平滑性较好 $K(u)=\left\{\begin{aligned}&amp;1-\vert u\vert&amp;\vert u\vert\leq1\\&amp;0&amp;\vert u\vert&gt;1\end{aligned}\right.$</li>
<li>Epanechnikov 核在均方误差意义下最优，计算效率高 $K(u)=\left\{\begin{aligned}&amp;\frac{3}{4}(1-u^2)&amp;\vert u\vert\leq1\\&amp;0&amp;\vert u\vert&gt;1\end{aligned}\right.$</li>
<li>二次核比 Epanechnikov 核更平滑，计算复杂度较高 $K(u)=\left\{\begin{aligned}&amp;\frac{15}{16}(1-u^2)^2&amp;\vert u\vert\leq1\\&amp;0&amp;\vert u\vert&gt;1\end{aligned}\right.$</li>
<li>余弦核适用于周期性数据 $K(u)=\left\{\begin{aligned}&amp;\frac{\pi}{4}\cos(\frac{\pi u}{2})&amp;\vert u\vert\leq1\\&amp;0&amp;\vert u\vert&gt;1\end{aligned}\right.$</li>
<li>指数核适用于长尾分布 $K(u)=\frac{1}{2}\exp(-\vert u\vert)$</li>
</ul>
<hr>
<p><strong>带宽的选择</strong></p>
<ul>
<li><p>通过简单的经验公式快速估计带宽，适用于初步分析</p>
<ul>
<li><p>Silverman 规则</p>
<script type="math/tex; mode=display">
  h=0.9\min(\sigma,\frac{IQR}{1.34})n^{-1/5}</script><ul>
<li>$\sigma$ 是样本标准差</li>
<li>$IQR$ 是样本的四分位距，就是第三四分位数（所有数值由小到大排列后第 25% 的数字）与第一四分位数的差距（所有数值由小到大排列后第 75% 的数字）</li>
<li>$n$ 是样本数量</li>
</ul>
</li>
<li><p>Scott 规则</p>
<script type="math/tex; mode=display">
  h=1.06\sigma n^{-1/5}</script></li>
</ul>
</li>
<li><p>交叉验证法</p>
<ul>
<li><p>最小化均方误差 MSE</p>
<script type="math/tex; mode=display">
  h=\arg\min(MISE(h))</script><ul>
<li>其中 $MISE$ 是积分均方误差 $MISE=\int(\hat{p}_h(x)-p(x))^2dx$</li>
</ul>
</li>
<li><p>最小化交叉验证</p>
<script type="math/tex; mode=display">
  h=\underset{h}{\arg\min}(CV(h))\\CV(h)=\int\hat{p}_h(x)^2dx-\frac{2}{n}\sum_i^n\hat{p}_{h,-i}(x_i)</script><ul>
<li>$CV(h)$ 是交叉验证得分</li>
<li>$\hat{p}_{h,-i}$ 是去掉第 $i$ 个样本之后的密度估计</li>
</ul>
</li>
</ul>
</li>
<li>插件法：通过估计密度函数的导数来选择带宽<ul>
<li>Sheather-Jones 插件法：通过迭代估计密度函数的二阶导数，选择最优带宽，但是公式比较复杂，比经验公式更准确</li>
</ul>
</li>
<li><p>最大似然法：通过最大化密度估计的似然函数选择带宽</p>
<script type="math/tex; mode=display">
  h=\underset{h}{\arg\max}(\prod_i^n\hat{p}_h(x_i))</script><ul>
<li>这种方法容易过拟合，不推荐使用</li>
</ul>
</li>
</ul>
<hr>
<p><strong>优点</strong></p>
<ul>
<li>结果平滑，能够更好地反映数据的分布</li>
<li>无需假设数据分布，适用于复杂数据</li>
</ul>
<hr>
<p><strong>缺点</strong></p>
<ul>
<li>计算复杂度较高，尤其是大规模数据</li>
<li>带宽选择对结果影响较大</li>
</ul>
<hr>
<h3 id="K-近邻密度估计"><a href="#K-近邻密度估计" class="headerlink" title="K 近邻密度估计"></a>K 近邻密度估计</h3><p>K 近邻密度估计（K-Nearest Neighbors Density Estimation，KNN-DE） 是一种非参数化密度估计方法，基于数据点的局部邻域信息来估计概率密度函数。与核密度估计不同，K 近邻密度估计的带宽是自适应的，取决于每个数据点的局部密度</p>
<hr>
<p><strong>K 近邻密度估计函数</strong></p>
<p>对于数据点 $x$ 密度估计公式为</p>
<script type="math/tex; mode=display">
\hat{p}(x)=\frac{k}{nV(R_k)}</script><ul>
<li>$k$ 是近邻数量</li>
<li>$n$ 是总样本数</li>
<li>$R_k$ 是 $x$ 到第 $k$ 个最近邻的距离</li>
<li>$V(R_k)$ 是以 $R_k$ 为半径的超球体体积<ul>
<li>一维 $V(R_k)=2R_k$</li>
<li>二维 $V(R_k)=\pi R_k^2$</li>
<li>在 $d$ 维情况下 $V(R_k)=\frac{\pi^{d/2}}{\Gamma(d/2+1)}R_k^d$ ，其中 $\Gamma(\alpha)=\int_0^\infty x^{\alpha-1}e^{-x}dx$ 是伽马函数</li>
</ul>
</li>
</ul>
<hr>
<p><strong>步骤</strong></p>
<ol>
<li>选择近邻的数量 $k$ ，选择对结果影响较大，通常通过交叉验证或经验公式确定</li>
<li>计算每个数据点的 $R_k$</li>
<li>利用上述密度估计函数计算每个数据点的密度</li>
<li>绘制密度估计曲线</li>
</ol>
<hr>
<p><strong>K 值的作用</strong></p>
<ul>
<li>k 值小：<ul>
<li>密度估计更关注局部细节，可能捕捉到噪声</li>
<li>结果波动较大，容易过拟合</li>
</ul>
</li>
<li>k 值大：<ul>
<li>密度估计更平滑，可能丢失数据的局部特征</li>
<li>结果过于平滑，容易欠拟合</li>
</ul>
</li>
</ul>
<hr>
<p><strong>K 值的选择</strong></p>
<ul>
<li><p>经验公式法，通过简单的经验公式快速估计 $k$ 值，适用于初步分析</p>
<script type="math/tex; mode=display">
  k\approx\sqrt{n}</script><ul>
<li>$n$ 是样本数量</li>
</ul>
</li>
<li><p>交叉验证法，通过优化某种准则选择最优 $k$ 值</p>
<ul>
<li>将数据集分为训练集和验证集</li>
<li><p>对于每个候选的 $k$ 值，计算密度估计的对数似然</p>
<script type="math/tex; mode=display">
L=\sum_i^n\log\hat{p}_k(x_i)</script></li>
<li><p>$\hat{p}_k$ 是对应 $k$ 值的密度估计函数</p>
</li>
<li>结果准确但是计算复杂度高</li>
</ul>
</li>
<li>肘部法：通过绘制 $k$ 值与某种指标（如密度估计的方差）的关系图，选择肘部点作为最优 $k$ 值<ul>
<li>计算不同 $k$ 值下的密度估计方差</li>
<li>绘制 $k$ 值与方差之间的关系图</li>
<li>选择方差下降速度明显减缓的肘部点</li>
<li>简单易懂，但是需要主观判断肘部点</li>
</ul>
</li>
<li>网格搜索法：通过网格搜索和交叉验证选择最优 $k$ 值<ul>
<li>定义 $k$ 值的候选范围，例如 $k\in[1,100]$</li>
<li>对于每个 $k$ 值，使用交叉验证计算密度估计的对数似然</li>
<li>选择使对数似然最大的 $k$ 值</li>
<li>结果准确，但是计算复杂度高</li>
</ul>
</li>
</ul>
<hr>
<p><strong>优点</strong></p>
<ul>
<li>自适应带宽：带宽 $R_k$ 根据局部密度自适应调整，适合非均匀分布的数据</li>
<li>无需假设数据分布：完全依赖数据本身，适用于复杂分布</li>
</ul>
<hr>
<p><strong>缺点</strong></p>
<ul>
<li>计算复杂度高：需要计算每个数据点的 $k$ 近邻距离，时间复杂度为 $O(n^2)$</li>
<li>结果可能不够平滑：密度估计曲线可能呈现阶梯状</li>
</ul>
<hr>
<p><strong>K 近邻密度估计的改进</strong></p>
<p>在 $k$ 近邻密度估计的基础上，使用核函数对密度估计进行平滑处理</p>
<script type="math/tex; mode=display">
\hat{p}(x)=\frac{1}{n}\sum_i^n\frac{1}{R_k(x_i)}K(\frac{x-x_i}{R_k(x_i)})</script><p>其中 $K$ 是核函数， $R_k(x_i)$ 是 $x_i$ 的第 $k$ 个最近邻距离</p>
<hr>
<h3 id="自回归模型"><a href="#自回归模型" class="headerlink" title="自回归模型"></a>自回归模型</h3><p>自回归模型（Autoregressive Model，AR） 是一种用于密度估计的生成模型，通过对数据的条件概率分布进行建模来估计联合概率密度函数。自回归模型的核心思想是将高维数据的联合分布分解为一系列条件分布的乘积，逐步生成数据</p>
<hr>
<p><strong>自回归模型定义</strong></p>
<p>自回归模型假设数据的联合概率密度函数可以分解为一系列条件概率分布的乘积</p>
<script type="math/tex; mode=display">
p(x)=\prod_i^dp(x_i\vert x_1,...x_{i-1})</script><ul>
<li>$x=(x_1,…x_d)$ 是 $d$ 维数据</li>
<li>$p(x_i\vert x_1,…x_{i-1})$ 是第 $i$ 个维度的条件概率分布</li>
</ul>
<hr>
<p><strong>自回归模型密度估计的步骤</strong></p>
<ol>
<li>对数据进行标准化或归一化处理，将数据划分为训练集和测试集</li>
<li>选择用于建模条件概率分布的模型</li>
<li>对每个维度 $i$ ，训练模型以预测 $x_i$ 的条件分布 $p(x_i\vert x_1,…x_{i-1})$</li>
<li>使用训练好的模型计算联合概率密度函数 $p(x)=\prod_i^dp(x_i\vert x_1,…x_{i-1})$</li>
<li>使用测试集评估模型的性能</li>
</ol>
<hr>
<p><strong>优点</strong></p>
<ul>
<li>灵活性高：可以建模复杂的条件分布</li>
<li>可扩展性强：适用于高维数据</li>
<li>生成能力强：可以用于生成新样本</li>
</ul>
<hr>
<p><strong>缺点</strong></p>
<ul>
<li>计算复杂度高：需要逐步计算条件概率分布</li>
<li>训练难度大：需要大量数据和计算资源</li>
</ul>
<hr>
<h3 id="归一化流"><a href="#归一化流" class="headerlink" title="归一化流"></a>归一化流</h3><p>归一化流（Normalizing Flows，NF） 是一种强大的密度估计方法，通过一系列可逆变换将简单分布（如高斯分布）映射到复杂分布，从而实现对复杂数据分布的建模。归一化流的核心思想是通过可逆变换将数据从原始空间转换到一个隐空间，并在隐空间中计算概率密度</p>
<hr>
<p><strong>归一化流的概率密度函数</strong></p>
<script type="math/tex; mode=display">
p(x)=p_z(f(x))\vert \det(\frac{\partial f(x)}{\partial x})\vert</script><ul>
<li>$f$ 是可逆变换</li>
<li>$p_z$ 是隐空间的简单分布</li>
<li>$\det(\frac{\partial f(x)}{\partial x})$ 是变换的雅可比行列式，用于保持概率密度的一致性</li>
</ul>
<hr>
<p><strong>归一化流密度估计的步骤</strong></p>
<ol>
<li>选择隐空间的简单分布 $p_z$</li>
<li>设计一系列可逆变换 $f$ ，将数据从原始空间映射到隐空间</li>
<li>通过上述公式使用变换的逆函数和雅可比行列式计算原始空间的概率密度</li>
<li><p>通过最大化对数似然函数训练模型</p>
<script type="math/tex; mode=display">
 \log p(x)=\log p_z(f(x))+\log\vert\det(\frac{\partial f(x)}{\partial x})\vert</script></li>
<li><p>从隐空间生成样本，并通过逆变换映射到原始空间</p>
</li>
</ol>
<hr>
<p><strong>归一化流的可逆函数</strong></p>
<ul>
<li><p>Affine Coupling Layer 仿射耦合层</p>
<ul>
<li>通过将输入数据分为两部分，保持其中一部分不变，另一部分通过仿射变换（加法、乘法）来修改</li>
<li><p>对于输入 $x={x_1,x_2}$ （数据分块） ，仿射耦合层的变换可以表示为</p>
<script type="math/tex; mode=display">
y_1=x_1\\y_2=x_2\cdot\exp(s(x_1))+t(x_1)</script></li>
<li><p>其中 $s$ 和 $t$ 都是基于 $x_1$ 的参数化函数</p>
</li>
</ul>
</li>
<li><p>Real NVP (Real-valued Non-Volume Preserving) / Masked Autoregressive Flow (MAF) 一种基于仿射耦合层的结构，通过特定的mask操作将输入数据分为两部分，使得每次变换只影响数据的部分维度</p>
<ul>
<li><p>例如对于上述的仿射耦合层的变换，数据分块通过掩码完成，例如这里掩码通过向量 $b$ 来表示，上述公式化简为</p>
<script type="math/tex; mode=display">
y=bx+(1-b)(x\cdot\exp(s(bx))+t(bx))</script></li>
</ul>
</li>
<li><p>Invertible 1x1 Convolutions  一种用于图像数据的可逆卷积变换，通过对输入图像进行 1x1 卷积操作实现可逆性，通过正交矩阵（可逆）保证了其可逆性，并且不会影响数据的维度</p>
</li>
<li>Residual Flows 采用了残差结构，在每一步变换时，通过添加一个残差项来保证变换的可逆性（每次变换都通过一个加法操作来保持其可逆性）</li>
<li>Spline-based Flows 通过使用光滑的插值来建模可逆的映射，特别适合处理高维数据，通过使用特定的光滑函数来学习复杂的变换，且通过特殊的参数化保证可逆性</li>
</ul>
<hr>
<p><strong>优点</strong></p>
<ul>
<li>精确计算概率密度：可以精确计算数据的概率密度</li>
<li>生成能力强：可以生成新样本</li>
<li>灵活性高：可以建模复杂的分布</li>
</ul>
<hr>
<p><strong>缺点</strong></p>
<ul>
<li>计算复杂度高：需要计算雅可比行列式</li>
<li>设计复杂：需要设计可逆变换</li>
</ul>
<hr>
<h3 id="变分自编码器"><a href="#变分自编码器" class="headerlink" title="变分自编码器"></a>变分自编码器</h3><p>变分自编码器（Variational Autoencoder, VAE）是一种基于概率生成模型的深度学习方法，广泛用于密度估计、数据生成和表示学习，通过变分推断近似数据的潜在分布，并利用编码器-解码器结构实现数据的生成和重构</p>
<hr>
<p><strong>变分自编码器密度估计函数</strong></p>
<p>密度估计的目标是建模数据的概率分布 $p(x)$ ，其中 $x$ 是观测数据，通过引入潜在变量 $z$ 将建模数据的概率分布建模为</p>
<script type="math/tex; mode=display">
p(x)=\int p(x\vert z)p(z)dz</script><ul>
<li>$p(z)$ 是潜在变量的先验分布，通常假设为标准正态分布 $\mathcal{N}(0,I)$</li>
<li>$p(x\vert z)$ 是生成模型，由解码器参数化</li>
</ul>
<p>直接计算 $p(x)$ 积分难以求解，VAE 通过变分推断来近似这一分布</p>
<hr>
<p><strong>变分推断</strong></p>
<p>VAE 通过变分判断来近似真实后验分布 $p(z\vert x)$ </p>
<ol>
<li>引入变分分布，使用一个由编码器实现的参数化的分布 $q(z\vert x)$ ，来近似真实后验概率 $p(z\vert x)$</li>
<li><p>优化目标：最大化证据下界，近似化解码器生成的数据与原始数据</p>
<script type="math/tex; mode=display">
 ELBO=\mathbb{E}_{q(z\vert x)}\log p(x\vert z)-KL(q(z\vert x)\Vert p(z))</script><ul>
<li>第一项是重构误差，衡量解码器生成的数据与原始数据的相似度</li>
<li>第二项是 KL 散度，衡量变分分布 $q(z\vert x)$ 与先验分布 $p(z)$ 的差异</li>
</ul>
</li>
</ol>
<p>通过最大化 ELBO，VAE 间接优化了数据的对数似然 $\log p(x)$</p>
<hr>
<p><strong>VAE 的密度估计步骤</strong></p>
<ol>
<li>编码器：将输入数据 $x$ 映射到潜在空间的分布参数，输出均值和方差，表示潜在变量 $z$ 的分布 $q(z\vert x)$</li>
<li>从 $q(z\vert x)$ 中采样潜在变量 $z=\mu+\sigma\epsilon$ ，其中 $\epsilon\sim\mathcal{N}(0,I)$</li>
<li>解码器：将采样得到的潜在变量 $z$ 输入到解码器中，解码器将 $z$ 映射回数据空间，生成 $p(x\vert z)$</li>
<li>优化最大化证据下界</li>
<li><p>利用上述密度估计函数，通过蒙特卡罗采样近似计算数据的概率密度</p>
<script type="math/tex; mode=display">
 p(x)\approx\frac{1}{L}\sum_i^Lp(x\vert z_i)\quad z_i\sim q(z\vert x)</script><ul>
<li>其中 $L$ 是采样次数</li>
</ul>
</li>
</ol>
<hr>
<p><strong>优点</strong></p>
<ul>
<li>显式概率模型：直接建模数据的概率分布，适合密度估计任务</li>
<li>潜在表示：通过学习潜在变量，能够捕捉数据的低维结构</li>
<li>生成能力：可以从 $p(z)$ 采样生成新数据</li>
</ul>
<hr>
<p><strong>缺点</strong></p>
<ul>
<li>近似误差：变分推断引入的近似可能导致密度估计不准确</li>
<li>生成质量：生成的样本可能不如GAN（生成对抗网络）清晰</li>
<li>计算复杂度：需要采样和蒙特卡罗近似，计算成本较高</li>
</ul>
<hr>
<p><strong>改进方法</strong></p>
<ul>
<li>使用混合高斯分布或标准化流（Normalizing Flow）替代标准正态分布</li>
<li>使用归一化流或层次化变分分布来提高 $q(z\vert x)$ 的表达能力</li>
<li>正则化，例如 KL 散度退火或信息瓶颈，防止过拟合</li>
<li>将VAE与其他生成模型（如GAN）结合，提升生成质量和密度估计精度</li>
</ul>
<hr>
<h3 id="变分贝叶斯自编码器"><a href="#变分贝叶斯自编码器" class="headerlink" title="变分贝叶斯自编码器"></a>变分贝叶斯自编码器</h3><p>变分贝叶斯自编码器（Variational Bayesian Autoencoder, VBAE）是变分自编码器（VAE）的扩展，结合了贝叶斯推断的思想，能够更灵活地建模数据分布和潜在变量的不确定性</p>
<hr>
<p><strong>变分贝叶斯自编码器的核心思想</strong></p>
<p>变分贝叶斯自编码器在 VAE 的基础上引入了贝叶斯推断，对模型参数（如编码器和解码器的权重）也进行概率建模，而不是像传统 VAE 那样使用确定性参数</p>
<ul>
<li>模型参数的概率化：将编码器和解码器的权重视为随机变量，赋予其先验分布</li>
<li>变分推断：通过变分分布近似模型参数和潜在变量的后验分布</li>
</ul>
<p>这种方法能更好地捕捉模型的不确定性，提高密度估计的鲁棒性</p>
<hr>
<p><strong>模型结构</strong></p>
<p>VBAE 的模型结构如下</p>
<ul>
<li>编码器：将输入数据映射到潜在变量的分布参数，得到潜在变量分布 $q(z\vert x)$</li>
<li>解码器：将潜在变量 $z$ 映射回数据空间，生成分布 $p(x\vert z)$</li>
<li>贝叶斯参数：编码器和解码器的权重 $\theta$ 被建模为随机变量，赋予先验分布 $p(\theta)$</li>
</ul>
<hr>
<p><strong>变分推断</strong></p>
<p>VBAE 的目标是近似联合后验分布 $p(z,\theta\vert x)$ 。由于直接计算后验分布不可行，VBAE 使用变分推断来近似</p>
<ul>
<li>变分分布：引入变分分布 $q(z,\theta\vert x)$ 来近似真实后验 $p(z,\theta\vert x)$</li>
<li>分解假设：通常假设 $q(z,\theta\vert x)=q(z\vert x)q(\theta)$ 即潜在变量和模型参数是独立的</li>
<li><p>优化目标：最大化证据下界</p>
<script type="math/tex; mode=display">
  ELBO=\mathbb{E}_{q(z,\theta\vert x)}\log p(x\vert z,\theta)-KL(q(z\vert x)\Vert p(z))-KL(q(\theta)\Vert p(\theta))</script><ul>
<li>第一项是重构误差，衡量生成数据与原始数据的相似度</li>
<li>第二项是潜在变量的 KL 散度，衡量 $q(z\vert x)$ 与先验 $p(z)$ 的差异</li>
<li>第三项是模型参数的 KL 散度，衡量 $q(\theta)$ 与先验 $p(\theta)$ 的差异</li>
<li>最大化 ELBO，同时优化了潜在变量和模型参数的后验分布</li>
</ul>
</li>
</ul>
<hr>
<p><strong>变分贝叶斯自编码器密度估计的步骤</strong></p>
<ol>
<li>编码器：将输入数据 $x$ 映射到潜在变量的分布参数 $q(z\vert x)$</li>
<li>采样：从 $q(z\vert x)$ 和 $q(\theta)$ 中采样潜在变量 $z$ 和模型参数 $\theta$</li>
<li>解码器：使用采样的 $z$ 和 $\theta$ 生成 $p(x\vert z,\theta)$</li>
<li><p>通过蒙特卡罗采样近似计算数据的概率密度</p>
<script type="math/tex; mode=display">
 p(x)\approx\frac{1}{L}\sum_i^Lp(x\vert z_i,\theta_i)\quad z_i\sim q(z\vert x),\theta_i\sim q(\theta)</script><ul>
<li>$L$ 是采样次数</li>
</ul>
</li>
</ol>
<hr>
<p><strong>优点</strong></p>
<ul>
<li>通过对模型参数进行贝叶斯建模，VBAE 能够更好地量化模型的不确定性</li>
<li>贝叶斯方法对过拟合具有更强的鲁棒性</li>
<li>可以结合更复杂的先验分布和变分分布，提高模型的表达能力</li>
</ul>
<hr>
<p><strong>缺点</strong></p>
<ul>
<li>计算复杂度高</li>
<li>由于 VBAE 的优化目标是非凸的，可能导致训练过程陷入局部最优</li>
<li>对先验分布的选择和变分分布的形式等非常敏感，调参过程复杂</li>
</ul>
<hr>
<p><strong>改进</strong></p>
<ul>
<li>使用混合高斯分布或标准化流（Normalizing Flow）替代简单的先验分布</li>
<li>使用层次化变分分布或依赖结构来提高变分分布的灵活性</li>
<li>使用随机梯度下降优化 ELBO，提高训练效率</li>
<li>正则化 ELBO 函数，如 KL 散度退火或信息瓶颈，防止过拟合</li>
</ul>
<hr>
<h3 id="生成对抗网络"><a href="#生成对抗网络" class="headerlink" title="生成对抗网络"></a>生成对抗网络</h3><p>生成对抗网络（Generative Adversarial Networks，GAN），与一般的生成式模型不同，GAN 不直接建模 $p(x)$ ，而是通过一个神经网络学习从隐变量 $z$ 到数据 $x$ 的映射，称为生成器，然后将生成的样本交给判别网络判断是否是真实的样本</p>
<hr>
<p><strong>基本原理</strong></p>
<p>GAN 由两个神经网络组成</p>
<ul>
<li>生成器：将随机噪声 $z$ 映射到数据空间，生成样本 $G(z)$</li>
<li>判别器：区分真实数据 $x$ 和生成数据 $G(z)$</li>
</ul>
<p>GAN 的训练目标是一个极小极大博弈</p>
<script type="math/tex; mode=display">
\underset{G}{\min}\underset{D}{\max}\mathbb{E}_{x\sim p(x)}\log D(x)+\mathbb{E}_{z\sim p(z)}\log(1-D(G(z)))</script><ul>
<li>$p(x)$ 是真实数据分布</li>
<li>$p(z)$ 是噪声分布</li>
<li>$p_G(x)$ 是生成数据分布</li>
</ul>
<hr>
<p><strong>基于 GAN 的密度估计方法</strong></p>
<p>由于 GAN 本身不直接支持密度估计，但研究者提出了多种方法来实现这一目标</p>
<ul>
<li><p>基于生成器的密度估计</p>
<ul>
<li><p>逆映射方法：通过训练一个额外的逆映射网络，将数据 $x$ 映射回噪声空间 $z$ ，然后利用噪声分布 $p(z)$ 计算密度</p>
<script type="math/tex; mode=display">
  p(x)\approx p(z)\vert\det(\frac{\partial G(z)}{\partial z})\vert^{-1}</script><ul>
<li>其中 $z=G^{-1}(x)$</li>
</ul>
</li>
<li>标准化流：将生成器设计为可逆的标准化流模型，从而可以直接计算概率密度</li>
</ul>
</li>
<li><p>基于判别器的密度估计</p>
<ul>
<li><p>能量模型：将判别器 $D(x)$ 视为能量函数，定义数据的非归一化概率密度如下</p>
<script type="math/tex; mode=display">
  p(x)\propto\exp(-E(x))\quad E(x)=-\log D(x)</script><ul>
<li>最后通过归一化计算概率密度</li>
</ul>
</li>
<li><p>密度比估计：利用判别器估计真实数据分布 $p(x)$ 和生成数据分布 $p_G(x)$ 的密度比</p>
<script type="math/tex; mode=display">
  \frac{p(x)}{p_G(x)}\approx\frac{D(x)}{1-D(x)}</script></li>
</ul>
</li>
<li><p>基于采样的密度估计</p>
<ul>
<li>蒙特卡罗采样：从生成器中采样大量样本，利用核密度估计等方法近似真实数据分布</li>
<li>重要性采样：通过生成器生成样本，并利用判别器计算重要性权重，从而估计密度</li>
</ul>
</li>
<li>混合模型<ul>
<li>VAE-GAN 混合模型：将变分自编码器（VAE）与 GAN 结合，利用 VAE 的显式密度模型和 GAN 的生成能力，实现密度估计</li>
<li>Flow-GAN 混合模型：将标准化流与 GAN 结合，利用标准化流的可逆性计算概率密度</li>
</ul>
</li>
</ul>
<hr>
<p><strong>优点</strong></p>
<ul>
<li>高质量生成样本：GAN 生成的样本通常比 VAE 更清晰、更逼真</li>
<li>灵活性：GAN 可以建模复杂的数据分布，适用于高维数据</li>
</ul>
<hr>
<p><strong>缺点</strong></p>
<ul>
<li>计算复杂度高：基于 GAN 的密度估计方法通常需要额外的网络或复杂的采样过程</li>
<li>训练不稳定性：GAN 的训练过程容易出现模式崩溃和不稳定性</li>
<li>无显式密度模型：需要额外的技术（如逆映射或标准化流）来实现密度估计</li>
</ul>
<hr>
<p><strong>改进方法</strong></p>
<p>为了提高 GAN 在密度估计中的性能，有如下几种改进方法</p>
<ul>
<li>可逆生成器：设计可逆的生成器结构，如标准化流。</li>
<li>正则化技术：如梯度惩罚（Gradient Penalty）或谱归一化（Spectral Normalization），提高训练稳定性</li>
<li>混合模型：将 GAN 与其他生成模型（如 VAE 或标准化流）结合，提升密度估计能力</li>
</ul>
<hr>
<h3 id="最大熵密度估计"><a href="#最大熵密度估计" class="headerlink" title="最大熵密度估计"></a>最大熵密度估计</h3><p>最大熵密度估计（Maximum Entropy Density Estimation）是一种基于信息论的统计方法，用于从有限的已知信息中推断出最合理的概率分布</p>
<p>最大熵密度估计在所有满足已知约束条件的概率分布中，选择熵最大的分布作为估计结果，这种方法在缺乏完整信息的情况下，能够提供一种最不偏不倚的估计</p>
<hr>
<p><strong>最大熵原理</strong></p>
<p>最大熵原理的核心思想就是在已知部分信息（如期望值和方差等）的情况下，选择熵最大的分布作为估计结果</p>
<p>熵是衡量分布不确定性的指标，熵最大的分布意味着在已知约束下对未知信息做出了最少的假设</p>
<p>在数学上，对于一个一维的连续型的随机变量，其概率密度分布函数为 $p(x)$ ，该变量的熵定义为</p>
<script type="math/tex; mode=display">
H(x)=-\int p(x)\log p(x)dx</script><p>对于离散型的随机变量，概率密度分布为</p>
<script type="math/tex; mode=display">
H(x)=\sum_ip(x_i)\log(p(x_i))</script><hr>
<p><strong>最大熵原理密度估计步骤</strong></p>
<p>最大熵密度估计的目标是找到一个概率分布 $p(x)$ ，使其在满足已知约束条件的同时，最大化熵 $H(p)$</p>
<ol>
<li>假设已知一些关于分布的约束条件，例如<ul>
<li>对于已知的函数 $f_i(x)$ 期望值 $E[f_i(x)]=\mu_i\quad i=(1,2,…m)$</li>
<li>归一化条件 $\int p(x)dx=1$</li>
</ul>
</li>
<li><p>最大化熵密度估计可以表示为以下约束优化问题</p>
<script type="math/tex; mode=display">
 \underset{p(x)}{\max}H(x)=-\int p(x)\log p(x)dx\\s.t.\int p(x)f_i(x)dx=\mu_i\\\int p(x)dx=1</script></li>
<li><p>通过拉格朗日乘数法，可以将上述约束优化问题转化为无约束优化问题，引入拉格朗日乘数 $\lambda_0$ 和 $\lambda_i$ ，构建拉格朗日函数</p>
<script type="math/tex; mode=display">
 \mathcal{L}(p,\lambda_0,\lambda_1)=-\int p(x)\log p(x)dx+\lambda_0(\int p(x)dx-1)+\sum_i^m\lambda_i(\int p(x)f_i(x)dx-\mu_i)</script></li>
<li><p>求解上述拉格朗日函数，对 $p(x)$ 求导并且使导数为 0，可以得到最大熵分布的形式</p>
<script type="math/tex; mode=display">
 p(x)=\frac{1}{Z}\exp(-\sum_i^m\lambda_if_i(x))\\Z=\int\exp(-\sum_i^m\lambda_if_i(x))dx</script></li>
</ol>
<hr>
<p><strong>最大熵分布的性质</strong></p>
<ul>
<li>在给定约束条件下，最大熵分布是唯一的</li>
<li>通过选择不同的约束条件，可以得到不同的最大熵分布<ul>
<li>如果约束条件是均值和方差，则最大熵分布是高斯分布</li>
<li>如果约束条件是均值，则最大熵分布是指数分布</li>
</ul>
</li>
<li>最大熵分布属于指数族分布 $p(x)\propto\exp(\lambda^Tf(x))$</li>
</ul>
<hr>
<p><strong>优点</strong></p>
<ul>
<li>在已知约束下，最大熵分布对未知信息做出了最少的假设</li>
<li>可以通过选择不同的约束条件，适应不同的应用场景</li>
<li>最大熵分布是唯一满足约束条件且熵最大的分布</li>
</ul>
<hr>
<p><strong>缺点</strong></p>
<ul>
<li>求解拉格朗日乘数和归一化常数可能需要数值方法，计算复杂度较高</li>
<li>约束条件的选择对结果影响较大，需要领域知识</li>
</ul>
<hr>
<h3 id="贝叶斯密度估计"><a href="#贝叶斯密度估计" class="headerlink" title="贝叶斯密度估计"></a>贝叶斯密度估计</h3><p>贝叶斯密度估计（Bayesian Density Estimation）是一种基于贝叶斯统计理论的概率密度估计方法，将概率密度函数的参数视为随机变量，并通过先验分布和观测数据来推断后验分布，从而得到概率密度的估计</p>
<hr>
<p><strong>核心思想</strong></p>
<ul>
<li>将概率密度函数的参数 $\theta$ 视作随机变量，赋予其先验分布为 $p(\theta)$</li>
<li>对于观测数据 $X:\{x_1,…x_n\}$ ，通过贝叶斯定理计算参数的后验分布 $p(\theta\vert X)$</li>
<li>基于后验分布，对概率密度函数 $p(x\vert\theta)$ 进行推断</li>
</ul>
<script type="math/tex; mode=display">
p(\theta\vert X)=\frac{p(X\vert\theta)p(\theta)}{p(X)}</script><ul>
<li>$p(X\vert\theta)$ 是似然函数，表示在参数 $\theta$ 下观测到数据 $X$ 的概率</li>
<li>$p(\theta)$ 是参数的先验分布</li>
<li>$p(X)$ 是边缘似然，用于归一化后验分布</li>
</ul>
<hr>
<p><strong>贝叶斯密度估计的步骤</strong></p>
<ol>
<li>选择一个参数化的概率密度函数 $p(x\vert\theta)$ ，例如高斯分布，混合高斯分布等</li>
<li>为参数 $\theta$ 指定一个先验分布 $p(\theta)$ ，这个可以基于领域知识选择</li>
<li><p>利用观测的数据 $X$ ，通过贝叶斯定理计算后验分布，后验分布反映的是在观测数据的基础上对 $\theta$ 的认知</p>
<script type="math/tex; mode=display">
 p(\theta\vert X)\propto p(X\vert\theta)p(\theta)</script></li>
<li><p>基于后验概率分布 $p(\theta\vert X)$ 推断新数据点的预测分布 $p(x\vert X)$</p>
<script type="math/tex; mode=display">
 p(x\vert X)=\int p(x\vert\theta)p(\theta\vert X)d\theta</script><ul>
<li>这一步可以通过马尔可夫链蒙特卡罗或变分推断来近似计算</li>
</ul>
</li>
</ol>
<hr>
<p><strong>贝叶斯密度估计的方法</strong></p>
<ul>
<li>参数化方法<ul>
<li>高斯分布</li>
<li>混合高斯分布</li>
</ul>
</li>
<li>非参数化方法<ul>
<li>狄利克雷过程混合模型</li>
<li>高斯过程密度估计</li>
</ul>
</li>
<li>核密度估计的贝叶斯扩展<ul>
<li>贝叶斯核密度估计</li>
</ul>
</li>
</ul>
<hr>
<p><strong>基于高斯分布的贝叶斯密度估计</strong></p>
<p>高斯分布的概率密度函数为</p>
<script type="math/tex; mode=display">
p(x\vert \mu,\sigma^2)=\frac{1}{\sqrt{2\pi\sigma^2}}\exp(-\frac{(x-\mu)^2}{2\sigma^2})</script><p>对于多维数据，高斯分布的概率密度函数为</p>
<script type="math/tex; mode=display">
p(x\vert \mu,\Sigma)=\frac{1}{(2\pi)^{d/2}\vert\Sigma\vert^{1/2}}\exp(-\frac{1}{2}(x-\mu)^T\Sigma^{-1}(x-\mu))</script><ul>
<li>$\mu$ 是均值向量</li>
<li>$\sigma^2$ 是方差</li>
<li>$\Sigma$ 是协方差矩阵</li>
<li>$d$ 是数据维度</li>
</ul>
<p>在高斯分布贝叶斯密度估计中，将高斯分布的参数 $\mu,\sigma,\Sigma$ 视为随机变量，并赋予其先验分布。通过观测数据，利用贝叶斯定理计算参数的后验分布，从而推断概率密度函数</p>
<ol>
<li>计算先验分布，为高斯分布的参数 $\mu$ 和 $\sigma^2$ 指定先验分布<ol>
<li>均值：通常选择高斯分布 $\mu\sim\mathcal{N}(\mu_0,\sigma_0^2)$</li>
<li>方差：通常选择逆伽马分布 $\sigma^2\sim Inv-Gamma(\alpha,\beta)$ 或者对数正态分布</li>
<li>协方差矩阵：通常选择逆威沙特分布</li>
</ol>
</li>
<li><p>计算后验分布，利用观测数据 $X:\{x_1,…x_n\}$ ，通过贝叶斯定理计算参数的后验分布</p>
<ol>
<li><p>对于一维高斯分布</p>
<script type="math/tex; mode=display">
 p(\mu,\sigma^2\vert X)\propto p(X\vert\mu,\sigma^2)p(\mu)p(\sigma^2)</script></li>
<li><p>对于多维高斯分布</p>
<script type="math/tex; mode=display">
 p(\mu,\Sigma\vert X)\propto p(X\vert\mu,\Sigma)p(\mu)p(\Sigma)</script></li>
</ol>
</li>
<li><p>推断概率密度，基于后验分布 $p(\mu,\sigma^2\vert X)$ 或 $p(\mu,\Sigma\vert X)$ 推断概率密度函数 $p(x\vert X)$</p>
<ol>
<li><p>对于一维高斯分布</p>
<script type="math/tex; mode=display">
 p(x\vert X)=\int p(x\vert\mu,\sigma^2)p(\mu,\sigma^2\vert X)d\mu d\sigma^2</script></li>
<li><p>对于多维高斯分布</p>
<script type="math/tex; mode=display">
 p(x\vert X)=\int p(x\vert\mu,\Sigma)p(\mu,\Sigma\vert X)d\mu d\Sigma</script></li>
<li><p>这一步通常需要通过数值方法或解析近似来计算</p>
</li>
</ol>
</li>
</ol>
<hr>
<p><strong>基于混合高斯分布的贝叶斯密度估计</strong></p>
<p>混合高斯分布的概率密度函数为</p>
<script type="math/tex; mode=display">
p(x\vert\Theta)=\sum_k^K\pi_k\mathcal{N}(x\vert\mu_k,\Sigma_k)</script><ul>
<li>$x$ 是观测数据</li>
<li>$K$ 是高斯分布的数量</li>
<li>$\pi_k$ 是第 $k$ 个高斯分布的混合系数，满足 $\pi_k\geq0,\sum_k^K\pi_k=1$</li>
<li>$\mathcal{N}(x\vert\mu_k,\Sigma_k)$ 是第 $k$ 个高斯分布的概率密度函数</li>
<li>$\Theta=\{\pi_k,\mu_k,\Sigma_k\}_k^K$ 是混合高斯分布的参数集合</li>
</ul>
<p>步骤</p>
<ol>
<li>对混合高斯分布的参数集合 $\Theta$ 设置先验分布<ul>
<li>混合系数 $\pi_k$ 选择狄利克雷分布作为先验 $p(\pi)=Dirichlet(\pi\vert\alpha)$</li>
<li>均值 $\mu_k$ 选择高斯分布作为先验 $p(\mu_k)=\mathcal{N}(\mu_k\vert m_0,S_0)$</li>
<li>协方差矩阵 $\Sigma_k$ 通常选择逆威沙特分布 $p(\Sigma_k)=W^{-1}(\Sigma_k\vert v_0,\Psi_0)$</li>
</ul>
</li>
<li><p>对于给定数据 $X:\{x_1,…x_n\}$ 混合高斯分布的似然函数</p>
<script type="math/tex; mode=display">
 p(X\vert\Theta)=\prod_i^n\sum_k^K\pi_k\mathcal{N}(x_i\vert\mu_k,\Sigma_k)</script></li>
<li><p>根据贝叶斯定理计算参数的后验分布</p>
<script type="math/tex; mode=display">
 p(\Theta\vert X)\propto p(X\vert\Theta)p(\theta)</script><ul>
<li>这一步可以通过蒙特卡罗采样或变分推断来近似计算</li>
</ul>
</li>
<li><p>基于后验分布，计算新数据点 $x^\star$ 的概率密度</p>
<script type="math/tex; mode=display">
 p(x^\star\vert X)=\int p(x^\star\vert\Theta)p(\Theta\vert X)d\Theta</script></li>
</ol>
<hr>
<p><strong>基于狄利克雷过程混合模型的贝叶斯密度估计</strong></p>
<p>狄利克雷过程混合模型（Dirichlet Process Mixture Model, DPMM）是一种非参数贝叶斯模型，常用于密度估计和聚类分析，结合了狄利克雷过程（Dirichlet Process, DP）和混合模型的特点，能够自动确定数据中的聚类数量，适合处理复杂的数据分布</p>
<p>DPMM的核心是将狄利克雷过程与混合模型结合，假设数据来自无限混合分布，模型设定如下</p>
<ul>
<li>基分布 $G_0$ 参数 $\theta$ 的先验分布</li>
<li>集中参数 $\alpha$ 控制新聚类的生成概率， $\alpha$ 越大，聚类数量越多</li>
<li>混合分布 $G$ 从狄利克雷过程 $DP(\alpha,G_0)$ 中生成</li>
<li>数据生成分布 $F(\theta)$ 是给定参数 $\theta$ 数据 $x$ 的分布</li>
</ul>
<p>目标是估计数据的概率密度函数 $p(x)$</p>
<script type="math/tex; mode=display">
p(x)=\int p(x\vert\theta)p(\theta)d\theta</script><ul>
<li>$p(x\vert\theta)$ 是数据生成分布</li>
<li>$p(\theta)$ 是参数的后验分布</li>
<li>DPMM 是非参数模型， $p(\theta)$ 通过狄利克雷过程生成，因此密度估计需要从后验分布中采样</li>
</ul>
<p>DPMM 的贝叶斯密度估计步骤如下</p>
<ol>
<li>初始化<ul>
<li>设定超参数 $\alpha$ 和基分布 $G_0$</li>
<li>初始化聚类分配和参数</li>
</ul>
</li>
<li><p>使用 MCMC 方法迭代更新每个数据点的聚类分配，对于数据点 $x_i$</p>
<ol>
<li><p>计算其分配到现有聚类 $k$ 的概率</p>
<script type="math/tex; mode=display">
 p(z_i=k\vert z_{-i},x_i)\propto \frac{n_k}{n-1+\alpha}p(x_i\vert\theta_k)</script><ul>
<li>$n_k$ 是聚类 $k$ 中数据点的数量</li>
<li>$z_{-i}$ 是其他数据点的聚类分配</li>
<li>$p(x_i\vert\theta_k)$ 是数据点 $x_i$ 在聚类 $k$ 下的似然函数</li>
</ul>
</li>
<li><p>计算其分配到新聚类的概率</p>
<script type="math/tex; mode=display">
 p(z_i=new\vert z_{-i},x_i)\propto\frac{\alpha}{n-1+\alpha}\int p(x_i\vert\theta)dG_0(\theta)</script></li>
</ol>
</li>
<li><p>对于每个聚类 $k$ ，从其后验分布中采样参数 $\theta_k$</p>
<script type="math/tex; mode=display">
 \theta_k\sim p(\theta_k\vert\{x_i:z_i=k\},G_0)</script><ul>
<li>具体形式取决于基分布 $G_0$ 和数据生成分布 $F(\theta)$</li>
</ul>
</li>
<li>重复上述迭代，得到稳定的聚类分配和参数</li>
<li><p>基于采样结果，估计数据的概率密度函数 $p(x)$</p>
<script type="math/tex; mode=display">
 p(x)\approx\frac{1}{T}\sum_t^Tp(x\vert\theta^t)</script><ul>
<li>$T$ 是采样次数</li>
<li>$\theta^t$ 是第 $t$ 次采样得到的参数</li>
</ul>
</li>
<li><p>对于新数据点 $x^\star$ ，其密度估计为</p>
<script type="math/tex; mode=display">
 p(x^\star)\approx\frac{1}{T}\sum_t^Tp(x^\star\vert\theta^t)</script></li>
</ol>
<hr>
<p><strong>基于高斯过程的贝叶斯密度估计</strong></p>
<p>基于高斯过程（Gaussian Process, GP）的贝叶斯密度估计是一种非参数方法，利用高斯过程的性质来估计未知的概率密度函数，高斯过程是一种强大的工具，能够对函数进行建模，并通过贝叶斯推断提供后验分布</p>
<p>高斯过程是定义在连续域上的无限维高斯分布，完全由其均值函数 $m(x)$ 和协方差函数 $k(x,x^\prime)$ 确定，对于任意有限点集 $\{x_1,…x_n\}$ ，函数值 $f(x_1),…f(x_n)$ 服从多元高斯分布，在密度估计中，通常假设均值函数 $m(x)=0$</p>
<script type="math/tex; mode=display">
f\sim \mathcal{GP}(m(x),k(x,x^\prime))</script><p>密度估计的目标是估计未知的概率密度函数 $p(x)$ </p>
<ol>
<li>给定一组独立同分布的观测数据 $X:\{x_1,…x_n\}$ </li>
<li><p>高斯过程是一种随机过程，适合建模函数分布，将 $\log p(x)$ 建模为高斯过程</p>
<script type="math/tex; mode=display">
 \log p(x)\sim\mathcal{GP}(m(x),k(x,x^\prime))</script><ul>
<li>$m(x)$ 是均值函数，常设为常数或零</li>
<li>$k(x,x^\prime)$ 是协方差函数（核函数），用于控制函数的平滑性</li>
</ul>
</li>
<li><p>由于 $p(x)$ 是概率密度函数，满足非负性核积分归一化条件，似然函数基于观测函数定义，如下</p>
<script type="math/tex; mode=display">
 \mathcal{L}=\prod_i^np(x_i)\\\log\mathcal{L}=\sum_i^n\log p(x_i)</script></li>
<li><p>后验推断，通过贝叶斯定理，得到后验分布为</p>
<script type="math/tex; mode=display">
 p(\log p(x)\vert X)\propto p(X\vert \log p(x))p(\log p(x))</script><ul>
<li>使用变分推断或马尔可夫链蒙特卡罗来近似后验分布</li>
</ul>
</li>
<li>通过后验分布 $p(\log p(x)\vert X)$ 可以对密度函数 $\log p(x)$ 进行推断，再通过指数变换得到 $p(x)$ 的估计，以下几种方法<ul>
<li>计算 $\log p(x)$ 的后验均值作为估计值</li>
<li>找到使后验分布最大的 $\log p(x)$</li>
<li>使用马尔可夫链蒙特卡洛（MCMC）或变分推断等方法从后验分布中采样，得到 $\log p(x)$ 的近似分布</li>
</ul>
</li>
</ol>
<hr>
<p><strong>贝叶斯核密度估计</strong></p>
<p>贝叶斯核密度估计（Bayesian Kernel Density Estimation, BKDE）是一种结合贝叶斯推断和核密度估计的非参数密度估计方法。它通过引入先验分布和后验分布，能够更好地处理小样本数据，并提供对密度估计的不确定性量化</p>
<ol>
<li><p>对于给定样本 $X:\{x_1,…x_n\}$ 和密度估计的公式为</p>
<script type="math/tex; mode=display">
 f(x)=\frac{1}{nh}\sum_i^nK(\frac{x-x_i}{h})</script><ul>
<li>$K$ 是核函数</li>
<li>$h$ 是带宽，用于控制平滑程度</li>
</ul>
</li>
<li>假设密度函数 $f(x)$ 的先验分布为某个随机过程的混合模型，先验分布反映了对密度函数的初始假设</li>
<li><p>对于给定样本 $X:\{x_1,…x_n\}$ 似然函数可以表示为</p>
<script type="math/tex; mode=display">
 p(\{x_i\}\vert f)=\prod_{i=1}^n f(x_i)</script></li>
<li><p>根据贝叶斯定理，计算后验分布为</p>
<script type="math/tex; mode=display">
 p(f\vert\{x_i\})\propto p(\{x_i\}\vert f)p(f)</script></li>
<li><p>通过后验分布 $p(f\vert\{x_i\})$ 可以对密度函数 $f(x)$ 进行推断，以下几种方法</p>
<ul>
<li>计算 $f(x)$ 的后验均值作为估计值</li>
<li>找到使后验分布最大的 $f(x)$</li>
<li>使用马尔可夫链蒙特卡洛（MCMC）或变分推断等方法从后验分布中采样，得到 $f(x)$ 的近似分布</li>
</ul>
</li>
</ol>
<hr>
<p><strong>优点</strong></p>
<ul>
<li>贝叶斯方法能够提供参数和概率密度的后验分布，从而量化估计的不确定性</li>
<li>通过选择不同的先验分布和概率密度模型，可以适应不同的应用场景</li>
<li>可以利用领域知识指定先验分布，提高估计的准确性</li>
</ul>
<hr>
<p><strong>缺点</strong></p>
<ul>
<li>贝叶斯方法通常需要复杂的数值计算或近似推断（如变分推断）。</li>
<li>先验分布的选择可能对结果产生影响</li>
</ul>
<hr>
<h3 id="方法选择"><a href="#方法选择" class="headerlink" title="方法选择"></a>方法选择</h3><ul>
<li>低维数据：核密度估计（KDE）、直方图法</li>
<li>高维数据：归一化流、变分自编码器（VAE）、自回归模型</li>
<li>简单分布：参数化方法（如高斯分布）</li>
<li>复杂分布：非参数化方法（如KDE）或基于模型的方法（如归一化流）</li>
</ul>
<hr>
<h3 id="密度估计的评估"><a href="#密度估计的评估" class="headerlink" title="密度估计的评估"></a>密度估计的评估</h3><ul>
<li>对数似然（Log-Likelihood）：评估模型在测试数据上的对数似然值，值越大越好</li>
<li>KL散度（Kullback-Leibler Divergence）：衡量估计分布与真实分布之间的差异</li>
<li>可视化：绘制估计的密度函数，直观评估其与真实分布的接近程度</li>
</ul>
<hr>
<h2 id="异常检测"><a href="#异常检测" class="headerlink" title="异常检测"></a>异常检测</h2><p>机器学习异常检测是一种用于识别数据集中异常或罕见事件的技术。这些异常可能是数据中的错误、欺诈行为、设备故障或其他不寻常的模式</p>
<hr>
<h3 id="需要用到的知识"><a href="#需要用到的知识" class="headerlink" title="需要用到的知识"></a>需要用到的知识</h3><p><strong>ARIMA 模型</strong></p>
<p>ARIMA（AutoRegressive Integrated Moving Average） 是一种经典的时间序列预测模型，广泛应用于时间序列分析和预测。ARIMA 模型结合了自回归（AR）、差分（I）和移动平均（MA）三个部分，能够捕捉时间序列的趋势和季节性</p>
<ul>
<li><p>AR 自回归，利用时间序列的历史值预测未来值</p>
<script type="math/tex; mode=display">
  y_t=c+\phi_1y_{t-1}+\cdots+\phi_py_{t-p}+\epsilon_t</script></li>
<li><p>I 差分，通过差分使时间序列平稳</p>
<script type="math/tex; mode=display">
  \Delta y_t=y_t-y_{t-1}</script></li>
<li><p>MA 移动平均，利用历史预测误差改进预测</p>
<script type="math/tex; mode=display">
  y_t=c+\epsilon_t+\theta_1\epsilon_{t-1}+\cdots+\theta_q\epsilon_{t-q}</script></li>
<li><p>ARIMA 模型的数学表示为 $\mathrm{ARIMA}(p,d,q)$</p>
</li>
<li>$p$ 是自回归阶数</li>
<li>$d$ 是差分阶数</li>
<li>$q$ 是移动平均阶数</li>
</ul>
<hr>
<p><strong>LSTM 模型</strong></p>
<p>LSTM（Long Short-Term Memory） 是一种特殊的循环神经网络（RNN），专门设计用于解决长序列数据中的梯度消失和梯度爆炸问题，LSTM 通过引入记忆单元和门控机制（输入门、遗忘门、输出门），能够有效地捕捉时间序列中的长期依赖关系</p>
<p>LSTM 的核心思想是通过引入记忆单元和门控机制，选择性地记住或遗忘信息。LSTM 单元的结构包括以下几个部分</p>
<ul>
<li>记忆单元，是 LSTM 的核心，用于存储长期信息<ul>
<li>通过门控机制，记忆单元可以选择性的更新或遗忘信息</li>
</ul>
</li>
<li><p>遗忘门，决定哪些信息需要从记忆单元中遗忘</p>
<script type="math/tex; mode=display">
  f_t=\sigma(W_f\cdot[h_{t-1},x_t]+b_f)</script><ul>
<li>$f_t$ 是遗忘门的输出</li>
<li>$\sigma$ 是 Sigmoid 激活函数</li>
<li>$W_f$ 是权重矩阵</li>
<li>$h_{t-1}$ 是前一时刻的隐藏状态</li>
<li>$x_t$ 是当前时刻的输入</li>
<li>$b_f$ 是偏置项</li>
</ul>
</li>
<li><p>输入门，决定哪些新信息需要存储到记忆单元中</p>
<script type="math/tex; mode=display">
  i_t=\sigma(W_i\cdot[h_{t-1},x_t]+b_i)\\\tilde{C}_t=\tanh(W_C\cdot[h_{t-1},x_t]+b_C)</script><ul>
<li>$i_t$ 是输入门的输出</li>
<li>$\tilde{C}_t$ 是候选记忆单元状态</li>
</ul>
</li>
<li><p>更新记忆单元，结合遗忘门和输入门的输出，更新记忆单元状态</p>
<script type="math/tex; mode=display">
  C_t=f_t\cdot C_{t-1}+i_t\cdot\tilde{C}_t</script><ul>
<li>$C_t$ 是当前时刻的记忆单元状态</li>
</ul>
</li>
<li><p>输出门，决定哪些信息需要输出到隐藏状态</p>
<script type="math/tex; mode=display">
  o_t=\sigma(W_o\cdot[h_{t-1},x_t]+b_o)\\h_t=o_t\tanh(C_t)</script><ul>
<li>$o_t$ 是输出门的输出</li>
<li>$h_t$ 是当前时刻的隐藏状态</li>
</ul>
</li>
</ul>
<hr>
<p><strong>Prophet 模型</strong></p>
<p>Prophet 是由 Facebook 开发的一种时间序列预测工具，适用于具有强烈季节性和趋势的时间序列数据。Prophet 的设计目标是简单易用，同时能够灵活地捕捉时间序列中的趋势、季节性和节假日效应</p>
<p>Prophet 模型将时间序列分解为三个主要部分</p>
<ul>
<li>趋势：描述时间序列的长期变化趋势，支持两种趋势模型<ul>
<li>线性趋势：适用于线性增长或下降的趋势</li>
<li>饱和增长趋势：适用于具有饱和点的增长趋势</li>
</ul>
</li>
<li>季节性：描述时间序列中的周期变化，支持多种季节性模式<ul>
<li>年季节性：每年季节性变化</li>
<li>周季节性：每周季节性变化</li>
<li>日季节性：每日季节性变化</li>
</ul>
</li>
<li>节假日效用：描述节假日对时间序列的影响</li>
<li><p>模型的数学表示为</p>
<script type="math/tex; mode=display">
  y(t)=g(t)+s(t)+h(t)+\epsilon(t)</script><ul>
<li>$y(t)$ 是时间序列的观测值</li>
<li>$g(t)$ 是趋势项</li>
<li>$s(t)$ 是季节性项</li>
<li>$h(t)$ 是节假日效应</li>
<li>$\epsilon(t)$ 是误差项</li>
</ul>
</li>
</ul>
<hr>
<p><strong>STL 模型</strong></p>
<p>STL（Seasonal and Trend decomposition using Loess） 是一种时间序列分解方法，能够将时间序列分解为趋势、季节性和残差三个部分，STL 的核心思想是通过局部加权回归来捕捉时间序列的趋势和季节性，适用于具有强烈季节性和趋势的时间序列数据</p>
<p>STL 模型将时间序列分解为三个部分</p>
<ul>
<li>趋势，描述时间序列的长期变化趋势，通过局部加权回归拟合趋势</li>
<li>季节性，描述时间序列的周期性变化，通过局部加权回归拟合季节性</li>
<li>残差，描述时间序列中无法被趋势和季节性解释的部分，通过原始时间序列减去趋势和季节性得到</li>
<li><p>模型的数学表示为</p>
<script type="math/tex; mode=display">
  y(t)=T(t)+S(t)+R(t)</script><ul>
<li>$y(t)$ 是时间序列的观测值</li>
<li>$T(t)$ 是趋势项</li>
<li>$S(t)$ 是季节性</li>
<li>$R(t)$ 是残差项</li>
</ul>
</li>
</ul>
<hr>
<h3 id="异常检测的类型"><a href="#异常检测的类型" class="headerlink" title="异常检测的类型"></a>异常检测的类型</h3><ul>
<li>点检测：单个数据点与大多数数据明显不同</li>
<li>上下文检测：在特定上下文中，数据点表现异常，但在其他上下文中可能是正常的</li>
<li>集体检测：一组数据点作为一个整体表现出异常行为，尽管单个点可能并不异常</li>
</ul>
<hr>
<h3 id="异常检测的评估指标"><a href="#异常检测的评估指标" class="headerlink" title="异常检测的评估指标"></a>异常检测的评估指标</h3><ul>
<li>准确率：正确分类的样本占所有样本数的比例，但是存在局限性</li>
<li>精确率：在模型预测为正类的样本实际为正类的比例</li>
<li>召回率：在所有真正的正类中，被模型预测为正类的比例</li>
<li><p>F1 分数：精确率和召回率的调和值，用于评估模型的稳健性，用于多分类问题和目标检测等。F1 分数位于 0 到 1 之间</p>
<ul>
<li>F1 越接近 1 表示模型的性能越好，即模型在精确率和召回率上都表现得很好</li>
<li><p>F1 越接近 0 表示模型的性能越差</p>
<script type="math/tex; mode=display">
F1=\frac{2\times precision\times recall}{precision+recall}</script></li>
</ul>
</li>
<li><p>AUC（Area Under Curve）：ROC 曲线下的面积，主要用于评估样本不均衡的情况。ROC 曲线以假正例率（FPR）为横轴，真正例率（TPR）为纵轴绘制</p>
<ul>
<li>假正例率：被错误分类为正样本的负样本占所有实际负样本的比例</li>
<li>真正例率：被正确分类为正样本的正样本占所有实际正样本的比例</li>
<li>取值范围为 0.5 到 1，AUC 值越接近 1，表示模型性能越好，即模型能更好的区分正负样本</li>
</ul>
</li>
<li>混淆矩阵：一个二维矩阵，用于战士模型预测结果与实际标签之间的关系。通过混淆矩阵，可以计算出准确率，精确率和召回率等指标，并且诊断模型问题。混淆矩阵一般包括以下四个元素<ul>
<li>真正例（True Positives, TP）：模型正确地将正类预测为正类的数量</li>
<li>假正例（False Positives, FP）：模型错误地将负类预测为正类的数量</li>
<li>假负例（False Negatives, FN）：模型错误地将正类预测为负类的数量</li>
<li>真负例（True Negatives, TN）：模型正确地将负类预测为负类的数量</li>
</ul>
</li>
</ul>
<hr>
<h3 id="统计方法异常检测"><a href="#统计方法异常检测" class="headerlink" title="统计方法异常检测"></a>统计方法异常检测</h3><ul>
<li><p>单变量高斯分布异常检测方法</p>
<ul>
<li><p>高斯分布是连续概率分布，其概率密度函数为</p>
<script type="math/tex; mode=display">
  p(x;\mu,\sigma^2)=\frac{1}{\sqrt{2\pi}\sigma}\exp(-\frac{(x-\mu)^2}{2\sigma^2})</script></li>
<li><p>选择一个阈值 $\epsilon$ ，如果 $p(x)&lt;\epsilon$ 则认为该数据点是异常点，它可以通过验证集或经验值确定</p>
</li>
</ul>
</li>
<li><p>多变量高斯分布异常检测方法</p>
<ul>
<li><p>多变量高斯分布是连续概率分布，其概率密度函数如下，其中 $n$ 是特征维度</p>
<script type="math/tex; mode=display">
  p(x;\mu,\Sigma)=\frac{1}{(2\pi)^{n/2}\vert\Sigma\vert^{1/2}}\exp(-\frac{1}{2}(x-\mu)^T\Sigma^{-1}(x-\mu))</script></li>
<li><p>选择一个阈值 $\epsilon$ ，如果 $p(x)&lt;\epsilon$ 则认为该数据点是异常点，它可以通过验证集或经验值确定</p>
</li>
</ul>
</li>
<li>箱线图异常检测方法<ul>
<li>计算数据的第一四分位数 $Q_1$ ，中位数 $Q_2$ 和第三四分位数 $Q_3$</li>
<li>计算四分距 $IQR=Q_3-Q_1$</li>
<li>确定异常值的阈值 $[Q_1-1.5IQR,Q_3+1.5IQR]$</li>
<li>任何不在范围内的数据点都被视作异常值</li>
</ul>
</li>
<li><p>Z-Score 异常检测方法</p>
<ul>
<li><p>计算数据集的均值和标准差</p>
<script type="math/tex; mode=display">
  \mu=\frac{1}{n}\sum_i^nx_i\\\sigma=\sqrt{\frac{1}{n}\sum_i^n(x_i-\mu)^2}</script></li>
<li><p>对于每个数据点 $x$ 计算其 Z-Score</p>
<script type="math/tex; mode=display">
  z=\frac{x-\mu}{\sigma}</script></li>
<li><p>一般将阈值 $\epsilon$ 设置为 3，可以根据具体场景调整</p>
</li>
<li>如果 $\vert z\vert&gt;\epsilon$ 则认为该数据点为异常点</li>
</ul>
</li>
</ul>
<hr>
<h3 id="基于距离的方法"><a href="#基于距离的方法" class="headerlink" title="基于距离的方法"></a>基于距离的方法</h3><ul>
<li>K 近邻异常检测方法<ul>
<li>选择最近邻居的数量 $k$<ul>
<li>较小的 $k$ 会导致对局部异常敏感，可能增加噪声的影响</li>
<li>较大的 $k$ 对全局异常敏感，可能忽略局部异常</li>
</ul>
</li>
<li>对于每个数据点，计算其与所有其他数据点的距离</li>
<li>对于每个数据点，找到其最近邻的 $k$ 个邻居</li>
<li>计算异常得分，有下面两中方法<ul>
<li>使用与第 $k$ 个邻居之间的距离作为异常得分</li>
<li>使用与 $k$ 个邻居的平均距离作为异常得分</li>
</ul>
</li>
<li>设定阈值，如果异常得分高于阈值，则被视作异常点</li>
</ul>
</li>
<li><p>局部异常因子异常检测方法</p>
<ul>
<li>选择最近邻居的数量 $k$<ul>
<li>较小的 $k$ 会导致对局部异常敏感，可能增加噪声的影响</li>
<li>较大的 $k$ 对全局异常敏感，可能忽略局部异常</li>
</ul>
</li>
<li>对每个数据点 $x$ ，计算其 k-距离，是该数据点到第 $k$ 个最近邻居的距离，记作 $kd(x)$</li>
<li><p>对每个数据点 $x$ ，计算与邻居的可达距离</p>
<script type="math/tex; mode=display">
  rd_k(x,y)=\max(kd(x),d(x,y))</script><ul>
<li>$d(x,y)$ 是数据点 $x$ 与 $y$ 之间的距离</li>
</ul>
</li>
<li><p>对每个数据点 $x$ ，计算其局部可达密度</p>
<script type="math/tex; mode=display">
  LRD_k(x)=\frac{1}{(\frac{\sum_{y\in N_k(x)}rd_k(x,y)}{\vert N_k(x)\vert})}</script><ul>
<li>$N_k(x)$ 是 $x$ 的 k 个最近邻居</li>
</ul>
</li>
<li><p>对于数据点 $x$ ，计算其局部异常因子</p>
<script type="math/tex; mode=display">
  LOF_k(x)\frac{\sum_{y\in N_k(x)}\frac{LRD_k(y)}{LRD_k(x)}}{\vert N_k(x)\vert}</script><ul>
<li>如果 $LOF_k(x)\approx1$ 说明该点的局部密度与其邻居相似</li>
<li>如果 $LOF_k(x)&gt;1$ 说明该点的局部密度低于其邻居，可能是异常点</li>
</ul>
</li>
<li>设定阈值 $\epsilon$ ，若 $LOF_k(x)&gt;\epsilon$ ，则该点被视作异常点</li>
</ul>
</li>
<li>基于 PCA 异常检测方法<ul>
<li>对输入的高维数据进行标准化处理，使每个特征的均值为 0，方差为 1</li>
<li>计算数据的协方差矩阵，并对其进行特征值分解</li>
<li>选择前 $k$ 个主成分，将数据投影到低维空间</li>
<li>将降维后的数据重构回原始空间</li>
<li>计算原始数据与重构数据之间的误差</li>
<li>设定阈值 $\epsilon$ ，若误差值大于阈值，则该点被视作异常点</li>
</ul>
</li>
</ul>
<hr>
<h3 id="基于聚类的方法"><a href="#基于聚类的方法" class="headerlink" title="基于聚类的方法"></a>基于聚类的方法</h3><ul>
<li>K-means 聚类异常检测方法<ul>
<li>选择最近邻居的数量 $k$<ul>
<li>较小的 $k$ 会导致簇内数据点分布较广，异常点不易识别</li>
<li>较大的 $k$ 导致簇内数据点分布较窄，异常点容易被识别</li>
</ul>
</li>
<li>使用 K-means 算法将数据划分为 $k$ 个簇，并计算每个簇的中心</li>
<li>对于每个数据点，计算其与所属簇中心的距离</li>
<li>根据距离分布设定阈值 $\epsilon$ ，若距离大于 $\epsilon$ 则认为该点是异常点</li>
</ul>
</li>
<li>DBSCAN 异常检测方法<ul>
<li>初始化：选择邻域半径 $\epsilon$ 和最小点数 $MinPts$</li>
<li>对于每个点，计算其在 $\epsilon$ 半径内的邻居数量，如果邻居数量 $\geq MinPts$ 则标记为核心点</li>
<li>从核心点出发，将所有密度可达的点归为一个簇</li>
<li>未被分配到任何簇的点标记为噪声点也就是异常点</li>
</ul>
</li>
</ul>
<hr>
<h3 id="基于密度的方法"><a href="#基于密度的方法" class="headerlink" title="基于密度的方法"></a>基于密度的方法</h3><ul>
<li>孤立森林异常检测方法<ul>
<li>建立孤立树<ul>
<li>随机选择一个特征和一个分割值</li>
<li>递归地将数据划分为左右两个子空间，直到数据点被完全隔离或者树达到最大深度</li>
</ul>
</li>
<li>构建多棵孤立树，形成孤立森林</li>
<li>对于每个数据点，计算其在所有树种地平均路径长度</li>
<li>根据路径长度计算异常分数为 $s(x,n)=2^{-\frac{E(h(x))}{c(n)}}$<ul>
<li>$E(h(x))$ 是数据点 $x$ 在所有树种的平均路径长度</li>
<li>$c(n)$ 是归一化因子，用于调整路径长度的期望值</li>
</ul>
</li>
<li>判断异常点<ul>
<li>异常分数接近 1 的点被认为是异常点</li>
<li>异常分数接近 0 的点被认为是正常点</li>
</ul>
</li>
</ul>
</li>
<li>One-Class SVM 异常检测方法<ul>
<li>输入未标注的数据，假设大部分数据都是正常的</li>
<li>使用核函数将数据映射到高维空间</li>
<li>在高维空间中寻找一个超平面，使得大部分数据点位于该超平面</li>
<li>计算每个数据点到决策边界的距离，距离越远异常分数越高</li>
<li>设定阈值 $\epsilon$ ，若异常值大于阈值，则标记为异常点</li>
</ul>
</li>
</ul>
<hr>
<h3 id="基于深度学习的方法"><a href="#基于深度学习的方法" class="headerlink" title="基于深度学习的方法"></a>基于深度学习的方法</h3><ul>
<li>自编码器异常检测方法<ul>
<li>输入未标注的数据集，假设大部分数据都是正常的</li>
<li>使用正常数据训练自编码器，使其能够较好的重构正常数据<ul>
<li>编码器：将输入数据压缩为低维表示</li>
<li>解码器：从低维表示重构原始数据</li>
</ul>
</li>
<li>对每个数据点，计算其输入与重构输出之间的误差<ul>
<li>正常数据通常能够被自编码器较好地重构，因此重构误差较低</li>
<li>异常数据由于与训练数据的分布不同，重构误差较高</li>
</ul>
</li>
<li>设定阈值 $\epsilon$ ，若重构误差值大于阈值，则标记为异常点</li>
</ul>
</li>
<li>生成对抗网络异常检测方法<ul>
<li>输入未标注的数据集，假设大部分数据是正常的</li>
<li>使用正常数据训练 GAN，使生成器能够生成与正常数据相似的样本<ul>
<li>生成器：生成与真实数据相似的假数据</li>
<li>判别器：区分真实数据与生成器生成的假数据</li>
</ul>
</li>
<li>对于每个数据点，计算其异常分数<ul>
<li>训练 GAN 使其能够生成正常数据的分布。</li>
<li>异常数据由于与正常数据的分布不同，判别器会将其识别为异常</li>
<li>生成器无法很好地重构异常数据</li>
</ul>
</li>
<li>设定阈值 $\epsilon$ ，若异常分数值大于阈值，则标记为异常点</li>
</ul>
</li>
<li>变分自编码器异常检测方法<ul>
<li>输入未标注的数据集，假设大部分数据是正常的</li>
<li>使用正常数据训练 VAE，使其能够较好地重构正常数据<ul>
<li>编码器：将输入数据映射到潜在空间的均值和方差</li>
<li>解码器：从潜在空间采样并重构原始数据</li>
</ul>
</li>
<li>对每个数据点，计算其输入与重构输出之间的误差<ul>
<li>正常的数据一般能被 VAE 较好地重构，重构误差较低</li>
<li>异常数据由于与训练数据的分布不同，重构误差较高</li>
</ul>
</li>
<li>设定阈值 $\epsilon$ ，若重构误差值大于阈值，则标记为异常点</li>
</ul>
</li>
</ul>
<hr>
<h3 id="时间序列异常检测"><a href="#时间序列异常检测" class="headerlink" title="时间序列异常检测"></a>时间序列异常检测</h3><ul>
<li>ARIMA 模型异常检测方法<ul>
<li>输入时间序列数据</li>
<li>检查时间序列是否平稳，如果不平稳就进行差分</li>
<li>选择合适地 ARIMA 参数来训练模型</li>
<li>使用训练好的模型预测时间序列地未来值</li>
<li>计算预测值与实际值之间的残差</li>
<li>设定阈值 $\epsilon$ ，若残差值大于阈值，则标记为异常点</li>
</ul>
</li>
<li>LSTM 长短期记忆网络异常检测方法<ul>
<li>输入时间序列数据</li>
<li>将数据划分为训练集和测试集</li>
<li>对数据进行标准化或归一化</li>
<li>将时间序列数据转换为监督学习问题</li>
<li>构建 LSTM 模型，使用训练集训练模型</li>
<li>使用训练好的模型预测时间序列的未来值</li>
<li>计算预测值与实际值之间的误差</li>
<li>设定阈值 $\epsilon$ ，若误差值大于阈值，则标记为异常点</li>
</ul>
</li>
<li>Prophet 异常检测方法<ul>
<li>输入时间序列数据，包含两列数据，时间戳 $ds$ 和观测值 $y$</li>
<li>使用 Prophet 拟合时间序列数据，捕捉趋势和季节性</li>
<li>使用训练好的模型预测时间序列的未来值</li>
<li>计算预测值与实际值之间的残差</li>
<li>设定阈值 $\epsilon$ ，若残差值大于阈值，则标记为异常点</li>
</ul>
</li>
<li>STL 异常检测方法<ul>
<li>输入时间序列数据</li>
<li>使用 STL 方法将时间序列分解为趋势，季节性和残差</li>
<li>计算残差项的统计特性</li>
<li>根据残差的分布，设定异常检测的阈值</li>
<li>将残差超过阈值的点标记为异常点</li>
</ul>
</li>
</ul>
<hr>
<h3 id="异常检测方法的对比选择"><a href="#异常检测方法的对比选择" class="headerlink" title="异常检测方法的对比选择"></a>异常检测方法的对比选择</h3><div class="table-container">
<table>
<thead>
<tr>
<th>方法</th>
<th>适用场景</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>高斯分布</td>
<td>单变量数据，正态分布数据，多变量数据</td>
<td>简单易用，计算效率高，无需标注数据</td>
<td>对非正态分布数据效果差</td>
</tr>
<tr>
<td>箱线图</td>
<td>单变量数据</td>
<td>简单直观，适合初步分析，无需标注数据</td>
<td>仅适用于单变量数据，对多变量数据无效</td>
</tr>
<tr>
<td>Z-Score</td>
<td>单变量数据，正态分布数据</td>
<td>简单易用，计算效率高</td>
<td>对非正态分布数据效果差</td>
</tr>
<tr>
<td>K 近邻</td>
<td>低维数据，点异常</td>
<td>简单直观，适合局部异常检测</td>
<td>对高维数据效果差，计算复杂度高</td>
</tr>
<tr>
<td>局部异常因子</td>
<td>低维数据，局部异常</td>
<td>能够检测局部异常，适合密度不均匀的数据</td>
<td>对高维数据效果差，计算复杂度高</td>
</tr>
<tr>
<td>K-means 聚类</td>
<td>低维数据，集体异常</td>
<td>简单易用，适合聚类分析</td>
<td>对异常点敏感，需要预先指定簇数量</td>
</tr>
<tr>
<td>DBSCAN</td>
<td>低维数据，点异常</td>
<td>能够识别任意形状的簇</td>
<td>对参数敏感，不适用于高维数据</td>
</tr>
<tr>
<td>孤立森林</td>
<td>高维数据，点异常</td>
<td>高效，无需标注数据</td>
<td>对局部异常检测效果差</td>
</tr>
<tr>
<td>One-Class SVM</td>
<td>高维数据，低比例异常</td>
<td>对低比例异常敏感</td>
<td>对参数敏感，训练时间较长</td>
</tr>
<tr>
<td>自编码器</td>
<td>高维数据，非线性数据</td>
<td>能够捕捉复杂的数据分布</td>
<td>训练时间较长，对参数敏感</td>
</tr>
<tr>
<td>生成对抗网络</td>
<td>图像数据，复杂分布数据</td>
<td>能够生成高质量的数据</td>
<td>训练不稳定，计算复杂度高</td>
</tr>
<tr>
<td>变分自编码器</td>
<td>高维数据，非线性数据</td>
<td>能够捕捉概率分布</td>
<td>训练时间较长，对参数敏感</td>
</tr>
<tr>
<td>ARIMA 模型</td>
<td>时间序列数据，点异常</td>
<td>简单易用，适合线性时间序列</td>
<td>对非线性关系建模能力有限</td>
</tr>
<tr>
<td>LSTM 长短期记忆网络</td>
<td>时间序列数据，上下文异常</td>
<td>能够捕捉长期依赖关系</td>
<td>训练时间较长，需要大量数据</td>
</tr>
<tr>
<td>Prophet</td>
<td>时间序列数据，季节性和趋势</td>
<td>自动捕捉趋势和季节性，支持节假日效应</td>
<td>对非线性关系建模能力有限</td>
</tr>
<tr>
<td>STL</td>
<td>时间序列数据，季节性和趋势</td>
<td>能够分解时间序列，适合季节性和趋势分析</td>
<td>对非线性关系建模能力有限</td>
</tr>
</tbody>
</table>
</div>
<hr>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>落
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://luo25177.github.io/2025/03/02/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E9%9D%9E%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/" title="机器学习-非监督学习">https://luo25177.github.io/2025/03/02/机器学习-非监督学习/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/Blog_NexT/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" rel="tag"># 机器学习</a>
              <a href="/Blog_NexT/tags/%E9%9D%9E%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/" rel="tag"># 非监督学习</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/Blog_NexT/2025/02/28/%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83/" rel="prev" title="概率分布">
      <i class="fa fa-chevron-left"></i> 概率分布
    </a></div>
      <div class="post-nav-item">
    <a href="/Blog_NexT/2025/03/09/%E8%B6%85%E5%89%8D%E5%92%8C%E6%BB%9E%E5%90%8E%E8%A1%A5%E5%81%BF%E5%99%A8/" rel="next" title="超前和滞后补偿器">
      超前和滞后补偿器 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%81%9A%E7%B1%BB"><span class="nav-number">1.</span> <span class="nav-text">聚类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%B7%E6%9C%AC%E7%9A%84%E8%B7%9D%E7%A6%BB%E5%BA%A6%E9%87%8F"><span class="nav-number">1.1.</span> <span class="nav-text">样本的距离度量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%81%9A%E7%B1%BB%E6%80%A7%E8%83%BD%E8%AF%84%E4%BC%B0"><span class="nav-number">1.2.</span> <span class="nav-text">聚类性能评估</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#K-means%E7%AE%97%E6%B3%95"><span class="nav-number">1.3.</span> <span class="nav-text">K-means算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B1%82%E6%AC%A1%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95"><span class="nav-number">1.4.</span> <span class="nav-text">层次聚类算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%86%E5%BA%A6%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95"><span class="nav-number">1.5.</span> <span class="nav-text">密度聚类算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%B1%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95"><span class="nav-number">1.6.</span> <span class="nav-text">谱聚类算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AB%98%E6%96%AF%E6%B7%B7%E5%90%88%E6%A8%A1%E5%9E%8B-GMM"><span class="nav-number">1.7.</span> <span class="nav-text">高斯混合模型 GMM</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E7%B3%8A-C-means-%E7%AE%97%E6%B3%95"><span class="nav-number">1.8.</span> <span class="nav-text">模糊 C-means 算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%99%8D%E7%BB%B4"><span class="nav-number">2.</span> <span class="nav-text">降维</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%B8%E5%87%BD%E6%95%B0"><span class="nav-number">2.1.</span> <span class="nav-text">核函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%99%8D%E7%BB%B4%E6%96%B9%E6%B3%95%E7%9A%84%E9%80%89%E6%8B%A9"><span class="nav-number">2.2.</span> <span class="nav-text">降维方法的选择</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90"><span class="nav-number">2.3.</span> <span class="nav-text">主成分分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%B8%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90"><span class="nav-number">2.4.</span> <span class="nav-text">核主成分分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E5%88%A4%E5%88%AB%E5%88%86%E6%9E%90"><span class="nav-number">2.5.</span> <span class="nav-text">线性判别分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#t-%E5%88%86%E5%B8%83%E9%82%BB%E5%9F%9F%E5%B5%8C%E5%85%A5"><span class="nav-number">2.6.</span> <span class="nav-text">t-分布邻域嵌入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E7%BC%96%E7%A0%81%E5%99%A8"><span class="nav-number">2.7.</span> <span class="nav-text">自编码器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8B%AC%E7%AB%8B%E6%88%90%E5%88%86%E5%88%86%E6%9E%90"><span class="nav-number">2.8.</span> <span class="nav-text">独立成分分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E7%BB%B4%E7%BC%A9%E6%94%BE"><span class="nav-number">2.9.</span> <span class="nav-text">多维缩放</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#UMAP"><span class="nav-number">2.10.</span> <span class="nav-text">UMAP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Truncated-SVD"><span class="nav-number">2.11.</span> <span class="nav-text">Truncated SVD</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%9E%E8%B4%9F%E7%9F%A9%E9%98%B5%E5%88%86%E8%A7%A3"><span class="nav-number">2.12.</span> <span class="nav-text">非负矩阵分解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9A%8F%E6%9C%BA%E6%8A%95%E5%BD%B1"><span class="nav-number">2.13.</span> <span class="nav-text">随机投影</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E8%81%94%E8%A7%84%E5%88%99%E5%AD%A6%E4%B9%A0"><span class="nav-number">3.</span> <span class="nav-text">关联规则学习</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">3.1.</span> <span class="nav-text">一些基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%A5%E9%AA%A4"><span class="nav-number">3.2.</span> <span class="nav-text">步骤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Apriori-%E7%AE%97%E6%B3%95"><span class="nav-number">3.3.</span> <span class="nav-text">Apriori 算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#FP-Growth-%E7%AE%97%E6%B3%95"><span class="nav-number">3.4.</span> <span class="nav-text">FP-Growth 算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Eclat-%E7%AE%97%E6%B3%95"><span class="nav-number">3.5.</span> <span class="nav-text">Eclat 算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%9F%E6%88%90%E5%85%B3%E8%81%94%E8%A7%84%E5%88%99%E7%A4%BA%E4%BE%8B"><span class="nav-number">3.6.</span> <span class="nav-text">生成关联规则示例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%86%E5%BA%A6%E4%BC%B0%E8%AE%A1"><span class="nav-number">4.</span> <span class="nav-text">密度估计</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E9%93%BE%E8%92%99%E7%89%B9%E5%8D%A1%E7%BD%97"><span class="nav-number">4.1.</span> <span class="nav-text">马尔可夫链蒙特卡罗</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E5%88%86%E6%8E%A8%E6%96%AD"><span class="nav-number">4.2.</span> <span class="nav-text">变分推断</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%86%E5%BA%A6%E4%BC%B0%E8%AE%A1%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">4.3.</span> <span class="nav-text">密度估计的方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AB%98%E6%96%AF%E5%88%86%E5%B8%83%E5%AF%86%E5%BA%A6%E4%BC%B0%E8%AE%A1"><span class="nav-number">4.4.</span> <span class="nav-text">高斯分布密度估计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%B7%E5%90%88%E9%AB%98%E6%96%AF%E6%A8%A1%E5%9E%8B"><span class="nav-number">4.5.</span> <span class="nav-text">混合高斯模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B4%E6%96%B9%E5%9B%BE%E6%B3%95%E5%AF%86%E5%BA%A6%E4%BC%B0%E8%AE%A1"><span class="nav-number">4.6.</span> <span class="nav-text">直方图法密度估计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%B8%E5%AF%86%E5%BA%A6%E4%BC%B0%E8%AE%A1"><span class="nav-number">4.7.</span> <span class="nav-text">核密度估计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#K-%E8%BF%91%E9%82%BB%E5%AF%86%E5%BA%A6%E4%BC%B0%E8%AE%A1"><span class="nav-number">4.8.</span> <span class="nav-text">K 近邻密度估计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%9B%9E%E5%BD%92%E6%A8%A1%E5%9E%8B"><span class="nav-number">4.9.</span> <span class="nav-text">自回归模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BD%92%E4%B8%80%E5%8C%96%E6%B5%81"><span class="nav-number">4.10.</span> <span class="nav-text">归一化流</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E5%88%86%E8%87%AA%E7%BC%96%E7%A0%81%E5%99%A8"><span class="nav-number">4.11.</span> <span class="nav-text">变分自编码器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E5%88%86%E8%B4%9D%E5%8F%B6%E6%96%AF%E8%87%AA%E7%BC%96%E7%A0%81%E5%99%A8"><span class="nav-number">4.12.</span> <span class="nav-text">变分贝叶斯自编码器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%9F%E6%88%90%E5%AF%B9%E6%8A%97%E7%BD%91%E7%BB%9C"><span class="nav-number">4.13.</span> <span class="nav-text">生成对抗网络</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E5%A4%A7%E7%86%B5%E5%AF%86%E5%BA%A6%E4%BC%B0%E8%AE%A1"><span class="nav-number">4.14.</span> <span class="nav-text">最大熵密度估计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%AF%86%E5%BA%A6%E4%BC%B0%E8%AE%A1"><span class="nav-number">4.15.</span> <span class="nav-text">贝叶斯密度估计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E9%80%89%E6%8B%A9"><span class="nav-number">4.16.</span> <span class="nav-text">方法选择</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%86%E5%BA%A6%E4%BC%B0%E8%AE%A1%E7%9A%84%E8%AF%84%E4%BC%B0"><span class="nav-number">4.17.</span> <span class="nav-text">密度估计的评估</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B"><span class="nav-number">5.</span> <span class="nav-text">异常检测</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9C%80%E8%A6%81%E7%94%A8%E5%88%B0%E7%9A%84%E7%9F%A5%E8%AF%86"><span class="nav-number">5.1.</span> <span class="nav-text">需要用到的知识</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="nav-number">5.2.</span> <span class="nav-text">异常检测的类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E7%9A%84%E8%AF%84%E4%BC%B0%E6%8C%87%E6%A0%87"><span class="nav-number">5.3.</span> <span class="nav-text">异常检测的评估指标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%9F%E8%AE%A1%E6%96%B9%E6%B3%95%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B"><span class="nav-number">5.4.</span> <span class="nav-text">统计方法异常检测</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E8%B7%9D%E7%A6%BB%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">5.5.</span> <span class="nav-text">基于距离的方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E8%81%9A%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">5.6.</span> <span class="nav-text">基于聚类的方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E5%AF%86%E5%BA%A6%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">5.7.</span> <span class="nav-text">基于密度的方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">5.8.</span> <span class="nav-text">基于深度学习的方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B"><span class="nav-number">5.9.</span> <span class="nav-text">时间序列异常检测</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E6%96%B9%E6%B3%95%E7%9A%84%E5%AF%B9%E6%AF%94%E9%80%89%E6%8B%A9"><span class="nav-number">5.10.</span> <span class="nav-text">异常检测方法的对比选择</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="落"
      src="/Blog_NexT/images/avatar.png">
  <p class="site-author-name" itemprop="name">落</p>
  <div class="site-description" itemprop="description">茶凉言尽，月上柳梢</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/Blog_NexT/archives/">
        
          <span class="site-state-item-count">120</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/Blog_NexT/categories/">
          
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/Blog_NexT/tags/">
          
        <span class="site-state-item-count">116</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Luo25177" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Luo25177" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:beloved25177@126.com" title="E-Mail → mailto:beloved25177@126.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2024 – 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">落</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">1.2m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">18:43</span>
  <img src="https://gcore.jsdelivr.net/gh/CNhuazhu/TuChuang4/blog/备案图标.png">
  <a href="http://www.beian.miit.gov.cn/" target="_blank">豫ICP备2024056598号-1</a>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/Blog_NexT/lib/anime.min.js"></script>
  <script src="/Blog_NexT/lib/velocity/velocity.min.js"></script>
  <script src="/Blog_NexT/lib/velocity/velocity.ui.min.js"></script>

<script src="/Blog_NexT/js/utils.js"></script>

<script src="/Blog_NexT/js/motion.js"></script>


<script src="/Blog_NexT/js/schemes/pisces.js"></script>


<script src="/Blog_NexT/js/next-boot.js"></script>




  




  
<script src="/Blog_NexT/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
