<!DOCTYPE html>
<html lang="zh-CN">
<script src="/Blog_NexT/js/snow.js"></script>
<script src="/Blog_NexT/js/forbiden.js"></script>
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.1.1">
  <link rel="icon" type="image/png" sizes="32x32" href="/Blog_NexT/images/logo4.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/Blog_NexT/images/logo4.png">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">

<link rel="stylesheet" href="/Blog_NexT/css/main.css">


<link rel="stylesheet" href="/Blog_NexT/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"luo25177.github.io","root":"/Blog_NexT/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="数据结构 C&#x2F;C++">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构">
<meta property="og:url" content="https://luo25177.github.io/2024/03/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/index.html">
<meta property="og:site_name" content="LuosBlog">
<meta property="og:description" content="数据结构 C&#x2F;C++">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://luo25177.github.io/Blog_NexT/2024/03/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/Untitled.png">
<meta property="og:image" content="https://luo25177.github.io/Blog_NexT/2024/03/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/doublelist.png">
<meta property="og:image" content="https://luo25177.github.io/Blog_NexT/2024/03/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/Untitled%201.png">
<meta property="og:image" content="https://luo25177.github.io/Blog_NexT/2024/03/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/Untitled%202.png">
<meta property="og:image" content="https://luo25177.github.io/Blog_NexT/2024/03/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/Untitled%203.png">
<meta property="og:image" content="https://luo25177.github.io/Blog_NexT/2024/03/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/matrix.png">
<meta property="og:image" content="https://luo25177.github.io/Blog_NexT/2024/03/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/map.png">
<meta property="article:published_time" content="2024-03-19T11:38:32.000Z">
<meta property="article:modified_time" content="2025-04-02T12:23:47.840Z">
<meta property="article:author" content="落">
<meta property="article:tag" content="C">
<meta property="article:tag" content="Cpp">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://luo25177.github.io/Blog_NexT/2024/03/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/Untitled.png">

<link rel="canonical" href="https://luo25177.github.io/2024/03/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>数据结构 | LuosBlog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/Blog_NexT/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">LuosBlog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/Blog_NexT/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-引导">

    <a href="/Blog_NexT/../" rel="section"><i class="fas fa-heart fa-fw"></i>引导</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/Blog_NexT/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/Blog_NexT/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/Blog_NexT/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-友链">

    <a href="/Blog_NexT/links/" rel="section"><i class="fa fa-link fa-fw"></i>友链</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://luo25177.github.io/2024/03/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/Blog_NexT/images/avatar.jpg">
      <meta itemprop="name" content="落">
      <meta itemprop="description" content="茶凉言尽，月上柳梢">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuosBlog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          数据结构
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-03-19 19:38:32" itemprop="dateCreated datePublished" datetime="2024-03-19T19:38:32+08:00">2024-03-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-04-02 20:23:47" itemprop="dateModified" datetime="2025-04-02T20:23:47+08:00">2025-04-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/Blog_NexT/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">编程语言</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>53k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>48 分钟</span>
            </span>
            <div class="post-description">数据结构 C/C++</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p><a target="_blank" rel="noopener" href="https://github.com/Luo25177/DataStruct">github仓库</a></p>
<h2 id="链表">链表</h2>
<h3 id="单向链表">单向链表</h3>
<p><img src="/Blog_NexT/2024/03/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/Untitled.png" alt="Untitled"></p>
<p>单向链表每次查找只能从前向后查找，单向的，只会有一个指针并且指向下一个节点。所以每个节点只能找到自己后面的节点，但是无法找到之前的链表。</p>
<p>对于<strong>循环</strong>链表，最末端的节点会指向头节点，形成首尾相接的循环。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// File Name: mylist.c</span></span><br><span class="line"><span class="comment">// Author: Dragon</span></span><br><span class="line"><span class="comment">// mail: [beloved25177@126.com](mailto:beloved25177@126.com)</span></span><br><span class="line"><span class="comment">// Created Time: Mon 25 Sep 2023 20:34:40 CST</span></span><br><span class="line"><span class="comment">// Description: 单向链表 insert remove new delete</span></span><br><span class="line"><span class="comment">//------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ListNode(T) typedef struct listnode_##T&#123;\</span></span><br><span class="line"><span class="meta">  struct listnode_##T* next;\</span></span><br><span class="line"><span class="meta">  T val;\</span></span><br><span class="line"><span class="meta">&#125;listnode_##T;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> listnode(T) listnode_##T</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NewListNode(T) listnode_##T* newListNode_##T(T val)&#123;\</span></span><br><span class="line"><span class="meta">  listnode_##T *node = (listnode_##T *) malloc(sizeof(listnode_##T));\</span></span><br><span class="line"><span class="meta">  node-&gt;next = NULL;\</span></span><br><span class="line"><span class="meta">  node-&gt;val = val;\</span></span><br><span class="line"><span class="meta">  return node;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> newListNode(T) newListNode_##T</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DeleteListNode(T) void deleteListNode_##T(listnode_##T *node)&#123;\</span></span><br><span class="line"><span class="meta">  free(node);\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> deleteListNode(T) deleteListNode_##T</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LinkedList(T) typedef struct linkedlist_##T&#123;\</span></span><br><span class="line"><span class="meta">  struct listnode_##T *head;\</span></span><br><span class="line"><span class="meta">  struct listnode_##T *tail;\</span></span><br><span class="line"><span class="meta">  int length;\</span></span><br><span class="line"><span class="meta">  T val;\</span></span><br><span class="line"><span class="meta">  void (*insert)(struct linkedlist_##T *list, int index, listnode_##T* node);\</span></span><br><span class="line"><span class="meta">  void (*remove)(struct linkedlist_##T *list, int index);\</span></span><br><span class="line"><span class="meta">  void (*merge)(struct linkedlist_##T *dst, struct linkedlist_##T *src, int dstbegin, int srcbegin, int srcend);\</span></span><br><span class="line"><span class="meta">  void (*clear)(struct linkedlist_##T *list);\</span></span><br><span class="line"><span class="meta">  int (*isempty)(struct linkedlist_##T *list);\</span></span><br><span class="line"><span class="meta">&#125;linkedlist_##T;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> linkedlist(T) linkedlist_##T</span></span><br><span class="line"><span class="comment">// insert at the front of index node</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Insert(T) void insert_##T(linkedlist_##T* list, int index, listnode_##T* node)&#123;\</span></span><br><span class="line"><span class="meta">  listnode_##T *iterator = list-&gt;head;\</span></span><br><span class="line"><span class="meta">  while(iterator-&gt;next != list-&gt;tail &amp;&amp; index--)&#123;\</span></span><br><span class="line"><span class="meta">    iterator = iterator-&gt;next;\</span></span><br><span class="line"><span class="meta">  &#125;\</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span>(index &gt; 0)printf(<span class="string">&quot;index has out of range, but will insert tail\n&quot;</span>);\</span></span><br><span class="line"><span class="meta">  node-&gt;next = iterator-&gt;next;\</span></span><br><span class="line"><span class="meta">  list-&gt;length++;\</span></span><br><span class="line"><span class="meta">  iterator-&gt;next = node;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="comment">// remove the next of iterator</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Remove(T) void remove_##T(linkedlist_##T* list, int index)&#123;\</span></span><br><span class="line"><span class="meta">  listnode_##T *iterator = list-&gt;head;\</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span>(!list-&gt;length)&#123;\</span></span><br><span class="line"><span class="meta">    printf(<span class="string">&quot;this list is empty, can&#x27;t remove node\n&quot;</span>);\</span></span><br><span class="line"><span class="meta">    return;\</span></span><br><span class="line"><span class="meta">  &#125;\</span></span><br><span class="line"><span class="meta">  index--;\</span></span><br><span class="line"><span class="meta">  while(iterator-&gt;next != list-&gt;tail &amp;&amp; index-- &gt; 0)&#123;\</span></span><br><span class="line"><span class="meta">    iterator = iterator-&gt;next;\</span></span><br><span class="line"><span class="meta">  &#125;\</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span>(index != 0)&#123;\</span></span><br><span class="line"><span class="meta">    printf(<span class="string">&quot;index has out of range, can&#x27;t remove node\n&quot;</span>);\</span></span><br><span class="line"><span class="meta">    return;\</span></span><br><span class="line"><span class="meta">  &#125;\</span></span><br><span class="line"><span class="meta">  listnode_##T *node = iterator-&gt;next;\</span></span><br><span class="line"><span class="meta">  iterator-&gt;next = iterator-&gt;next-&gt;next;\</span></span><br><span class="line"><span class="meta">  free(node);\</span></span><br><span class="line"><span class="meta">  list-&gt;length--;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="comment">// 都是以节点之后开始的</span></span><br><span class="line"><span class="comment">// [srcbegin, srcend) 节点id从1开始</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Merge(T) void merge_##T(linkedlist_##T *dst, struct linkedlist_##T *src, int dstbegin, int srcbegin, int srcend)&#123;\</span></span><br><span class="line"><span class="meta">  listnode_##T *dstit = dst-&gt;head;\</span></span><br><span class="line"><span class="meta">  listnode_##T *srcit = src-&gt;head;\</span></span><br><span class="line"><span class="meta">  while(dstit-&gt;next != dst-&gt;tail &amp;&amp; dstbegin-- &gt; 0) dstit = dstit-&gt;next;\</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span>(dstbegin &gt; 0) printf(<span class="string">&quot;dstbegin has out of range, so merge begin at the tail\n&quot;</span>);\</span></span><br><span class="line"><span class="meta">  listnode_##T *copybegin;\</span></span><br><span class="line"><span class="meta">  listnode_##T *copyend;\</span></span><br><span class="line"><span class="meta">  int copylength = 0;\</span></span><br><span class="line"><span class="meta">  while(srcit-&gt;next != src-&gt;tail)&#123;\</span></span><br><span class="line"><span class="meta">    srcit = srcit-&gt;next;\</span></span><br><span class="line"><span class="meta">    srcbegin--;\</span></span><br><span class="line"><span class="meta">    srcend--;\</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span>(srcend &lt;= 0)break;\</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span>(srcbegin == 0)&#123;\</span></span><br><span class="line"><span class="meta">      copybegin = newListNode(T)(srcit-&gt;val);\</span></span><br><span class="line"><span class="meta">      copyend = copybegin;\</span></span><br><span class="line"><span class="meta">      copylength++;\</span></span><br><span class="line"><span class="meta">    &#125;\</span></span><br><span class="line"><span class="meta">    <span class="keyword">else</span> <span class="keyword">if</span>(srcbegin &lt; 0)&#123;\</span></span><br><span class="line"><span class="meta">      listnode_##T *node = newListNode(T)(srcit-&gt;val);\ </span></span><br><span class="line">      copyend-&gt;next = node;\</span><br><span class="line">      copyend = copyend-&gt;next;\</span><br><span class="line">      copylength++;\</span><br><span class="line">    &#125;\</span><br><span class="line">  &#125;\</span><br><span class="line">  <span class="keyword">if</span>(srcbegin &gt; <span class="number">0</span>)&#123;\</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;srcbegin has out of range, so stop merge\n&quot;</span>);\</span><br><span class="line">    <span class="keyword">return</span>;\</span><br><span class="line">  &#125;\</span><br><span class="line">  copyend-&gt;next = dstit-&gt;next;\</span><br><span class="line">  dstit-&gt;next = copybegin;\</span><br><span class="line">  dst-&gt;length += copylength;\</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Clear(T) void clear_##T(linkedlist_##T *list)&#123;\</span></span><br><span class="line"><span class="meta">  listnode_##T *it = list-&gt;head;\</span></span><br><span class="line"><span class="meta">  while(it-&gt;next != list-&gt;tail)&#123;\</span></span><br><span class="line"><span class="meta">    listnode_##T *deletenode = it-&gt;next;\</span></span><br><span class="line"><span class="meta">    it-&gt;next = it-&gt;next-&gt;next;\</span></span><br><span class="line"><span class="meta">    free(deletenode);\</span></span><br><span class="line"><span class="meta">  &#125;\</span></span><br><span class="line"><span class="meta">  list-&gt;length = 0;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Isempty(T) int isempty_##T(linkedlist_##T *list)&#123;\</span></span><br><span class="line"><span class="meta">  return list-&gt;head-&gt;next == list-&gt;tail;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NewLinkedList(T) linkedlist_##T *newLinkedList_##T()&#123;\</span></span><br><span class="line"><span class="meta">  linkedlist_##T *list = (linkedlist_##T *)malloc(sizeof(linkedlist_##T));\</span></span><br><span class="line"><span class="meta">  list-&gt;head = (listnode_##T *)malloc(sizeof(listnode_##T));\</span></span><br><span class="line"><span class="meta">  list-&gt;head-&gt;val = 0;\</span></span><br><span class="line"><span class="meta">  list-&gt;tail = (listnode_##T *)malloc(sizeof(listnode_##T));\</span></span><br><span class="line"><span class="meta">  list-&gt;tail-&gt;val = 0;\</span></span><br><span class="line"><span class="meta">  list-&gt;length = 0;\</span></span><br><span class="line"><span class="meta">  list-&gt;head-&gt;next = list-&gt;tail;\</span></span><br><span class="line"><span class="meta">  list-&gt;tail-&gt;next = NULL;\</span></span><br><span class="line"><span class="meta">  list-&gt;insert = insert_##T;\</span></span><br><span class="line"><span class="meta">  list-&gt;remove = remove_##T;\</span></span><br><span class="line"><span class="meta">  list-&gt;merge = merge_##T;\</span></span><br><span class="line"><span class="meta">  list-&gt;clear = clear_##T;\</span></span><br><span class="line"><span class="meta">  list-&gt;isempty = isempty_##T;\</span></span><br><span class="line"><span class="meta">  return list;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> newLinkedList(T) newLinkedList_##T()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DeleteLinkedList(T) void deleteLinkList_##T(linkedlist_##T *list)&#123;\</span></span><br><span class="line"><span class="meta">  listnode_##T *iterator = list-&gt;head;\</span></span><br><span class="line"><span class="meta">  while(iterator)&#123;\</span></span><br><span class="line"><span class="meta">    listnode_##T *deletenode = iterator;\</span></span><br><span class="line"><span class="meta">    iterator = iterator-&gt;next;\</span></span><br><span class="line"><span class="meta">    free(deletenode);\</span></span><br><span class="line"><span class="meta">  &#125;\</span></span><br><span class="line"><span class="meta">  free(list);\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> deleteLinkedList(T) deleteLinkList_##T</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFINELIST(T) ListNode(T)\</span></span><br><span class="line"><span class="meta">  NewListNode(T)\</span></span><br><span class="line"><span class="meta">  DeleteListNode(T)\</span></span><br><span class="line"><span class="meta">  LinkedList(T)\</span></span><br><span class="line"><span class="meta">  Insert(T)\</span></span><br><span class="line"><span class="meta">  Remove(T)\</span></span><br><span class="line"><span class="meta">  Merge(T)\</span></span><br><span class="line"><span class="meta">  Clear(T)\</span></span><br><span class="line"><span class="meta">  Isempty(T)\</span></span><br><span class="line"><span class="meta">  NewLinkedList(T)\</span></span><br><span class="line"><span class="meta">  DeleteLinkedList(T)</span></span><br><span class="line"></span><br><span class="line">DEFINELIST(<span class="type">int</span>)</span><br><span class="line">DEFINELIST(<span class="type">char</span>)</span><br><span class="line">DEFINELIST(<span class="type">float</span>)</span><br><span class="line">DEFINELIST(<span class="type">double</span>)</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  linkedlist(<span class="type">int</span>) *<span class="built_in">list</span> = newLinkedList(<span class="type">int</span>);</span><br><span class="line">  linkedlist(<span class="type">int</span>) *list1 = newLinkedList(<span class="type">int</span>);</span><br><span class="line">  listnode(<span class="type">int</span>) *node = newListNode(<span class="type">int</span>)(<span class="number">1</span>);</span><br><span class="line">  listnode(<span class="type">int</span>) *node1 = newListNode(<span class="type">int</span>)(<span class="number">2</span>);</span><br><span class="line">  <span class="built_in">list</span>-&gt;insert(<span class="built_in">list</span>, <span class="number">0</span>, node);</span><br><span class="line">  <span class="built_in">list</span>-&gt;insert(<span class="built_in">list</span>, <span class="number">1</span>, node1);</span><br><span class="line">  listnode(<span class="type">int</span>) *node2 = newListNode(<span class="type">int</span>)(<span class="number">3</span>);</span><br><span class="line">  listnode(<span class="type">int</span>) *node3 = newListNode(<span class="type">int</span>)(<span class="number">4</span>);</span><br><span class="line">  list1-&gt;insert(list1, <span class="number">0</span>, node2);</span><br><span class="line">  list1-&gt;insert(list1, <span class="number">1</span>, node3);</span><br><span class="line">  <span class="comment">// while(iterator != list1-&gt;tail)&#123;</span></span><br><span class="line">  <span class="comment">//   printf(&quot;%d\n&quot;, iterator-&gt;val);</span></span><br><span class="line">  <span class="comment">//   iterator = iterator-&gt;next;</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">  <span class="built_in">list</span>-&gt;merge(<span class="built_in">list</span>, list1, <span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">  listnode(<span class="type">int</span>) *iterator = <span class="built_in">list</span>-&gt;head-&gt;next;</span><br><span class="line">  <span class="keyword">while</span>(iterator != <span class="built_in">list</span>-&gt;tail)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, iterator-&gt;val);</span><br><span class="line">    iterator = iterator-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">list</span>-&gt;remove(<span class="built_in">list</span>, <span class="number">0</span>);</span><br><span class="line">  iterator = <span class="built_in">list</span>-&gt;head-&gt;next;</span><br><span class="line">  <span class="keyword">while</span>(iterator != <span class="built_in">list</span>-&gt;tail)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, iterator-&gt;val);</span><br><span class="line">    iterator = iterator-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  deleteLinkedList(<span class="type">int</span>)(<span class="built_in">list</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="双向循环链表">双向循环链表</h3>
<p><img src="/Blog_NexT/2024/03/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/doublelist.png" alt="doublelist"></p>
<p>链表中有两个指针(pre, next)，并且指向前一个节点和后一个节点。头节点的前指针(pre)指向尾节点，并且尾节点的后指针(next)指向头节点，形成循环。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// File Name: mydoublelist.c</span></span><br><span class="line"><span class="comment">// Author: Dragon</span></span><br><span class="line"><span class="comment">// mail: [beloved25177@126.com](mailto:beloved25177@126.com)</span></span><br><span class="line"><span class="comment">// Created Time: Thu 28 Sep 2023 14:34:59 CST</span></span><br><span class="line"><span class="comment">// Description: 双向链表</span></span><br><span class="line"><span class="comment">//------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ListNode(T) typedef struct ListNode_##T&#123;\</span></span><br><span class="line"><span class="meta">  struct ListNode_##T *pre;\</span></span><br><span class="line"><span class="meta">  struct ListNode_##T *next;\</span></span><br><span class="line"><span class="meta">  T val;\</span></span><br><span class="line"><span class="meta">&#125;ListNode_##T;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> listnode(T) ListNode_##T</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NewListNode(T) ListNode_##T *newListNode_##T(T val)&#123;\</span></span><br><span class="line"><span class="meta">  ListNode_##T *node = (ListNode_##T *) malloc(sizeof(ListNode_##T));\</span></span><br><span class="line"><span class="meta">  node-&gt;next = NULL;\</span></span><br><span class="line"><span class="meta">  node-&gt;pre = NULL;\</span></span><br><span class="line"><span class="meta">  node-&gt;val = val;\</span></span><br><span class="line"><span class="meta">  return node;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DeleteListNode(T) void deleteListNode_##T(ListNode_##T *node)&#123;\</span></span><br><span class="line"><span class="meta">  free(node);\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> newListNode(T) newListNode_##T</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> deleteListNode(T) deleteListNode_##T</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DoubleList(T) typedef struct doublelist_##T&#123;\</span></span><br><span class="line"><span class="meta">  ListNode_##T *head;\</span></span><br><span class="line"><span class="meta">  ListNode_##T *tail;\</span></span><br><span class="line"><span class="meta">  int length;\</span></span><br><span class="line"><span class="meta">  void (*insert)(struct doublelist_##T *doublelist, int index, ListNode_##T *node);\</span></span><br><span class="line"><span class="meta">  void (*remove)(struct doublelist_##T *doublelist, int index);\</span></span><br><span class="line"><span class="meta">  void (*merge)(struct doublelist_##T *dst, struct doublelist_##T *src, int dstbegin, int srcbegin, int srcend);\</span></span><br><span class="line"><span class="meta">  void (*clear)(struct doublelist_##T *list);\</span></span><br><span class="line"><span class="meta">  void (*isempty)(struct doublelist_##T *list);\</span></span><br><span class="line"><span class="meta">&#125;doublelist_##T;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> doublelist(T) doublelist_##T</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Insert(T) void insert_##T(doublelist_##T *doublelist, int index, ListNode_##T *node)&#123;\</span></span><br><span class="line"><span class="meta">  ListNode_##T *iterator = doublelist-&gt;head;\</span></span><br><span class="line"><span class="meta">  while(iterator != doublelist-&gt;tail &amp;&amp; index--)&#123;\</span></span><br><span class="line"><span class="meta">    iterator = iterator-&gt;next;\</span></span><br><span class="line"><span class="meta">  &#125;\</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span>(!index)\</span></span><br><span class="line"><span class="meta">    printf(<span class="string">&quot;index has out of range and will insert front of tail\n&quot;</span>);\</span></span><br><span class="line"><span class="meta">  node-&gt;next = iterator-&gt;next;\</span></span><br><span class="line"><span class="meta">  node-&gt;pre = iterator;\</span></span><br><span class="line"><span class="meta">  iterator-&gt;next-&gt;pre = node;\</span></span><br><span class="line"><span class="meta">  iterator-&gt;next = node;\</span></span><br><span class="line"><span class="meta">  doublelist-&gt;length++;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Remove(T) void remove_##T(doublelist_##T *doublelist, int index)&#123;\</span></span><br><span class="line"><span class="meta">  ListNode_##T *iterator = doublelist-&gt;head;\</span></span><br><span class="line"><span class="meta">  while(iterator != doublelist-&gt;tail &amp;&amp; index--)&#123;\</span></span><br><span class="line"><span class="meta">    iterator = iterator-&gt;next;\</span></span><br><span class="line"><span class="meta">  &#125;\</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span>(index &gt;= 0)&#123;\</span></span><br><span class="line"><span class="meta">    printf(<span class="string">&quot;index has out of range, can&#x27;t remove any node\n&quot;</span>);\</span></span><br><span class="line"><span class="meta">    return;\</span></span><br><span class="line"><span class="meta">  &#125;\</span></span><br><span class="line"><span class="meta">  iterator-&gt;pre-&gt;next = iterator-&gt;next;\</span></span><br><span class="line"><span class="meta">  iterator-&gt;next-&gt;pre = iterator-&gt;pre;\</span></span><br><span class="line"><span class="meta">  iterator-&gt;pre = NULL;\</span></span><br><span class="line"><span class="meta">  iterator-&gt;next = NULL;\</span></span><br><span class="line"><span class="meta">  free(iterator);\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Merge(T) void merge_##T(struct doublelist_##T *dst, struct doublelist_##T *src, int dstbegin, int srcbegin, int srcend)&#123;\</span></span><br><span class="line"><span class="meta">  ListNode_##T *dstit = dst-&gt;head;\</span></span><br><span class="line"><span class="meta">  ListNode_##T *srcit = src-&gt;head;\</span></span><br><span class="line"><span class="meta">  while(dstit-&gt;next != dst-&gt;tail &amp;&amp; dstbegin-- &gt; 0) dstit = dstit-&gt;next;\</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span>(dstbegin &gt; 0) printf(<span class="string">&quot;dstbegin has out of range, so merge begin at the tail\n&quot;</span>);\</span></span><br><span class="line"><span class="meta">  ListNode_##T *copybegin;\</span></span><br><span class="line"><span class="meta">  ListNode_##T *copyend;\</span></span><br><span class="line"><span class="meta">  int copylength = 0;\</span></span><br><span class="line"><span class="meta">  while(srcit-&gt;next != src-&gt;tail)&#123;\</span></span><br><span class="line"><span class="meta">    srcit = srcit-&gt;next;\</span></span><br><span class="line"><span class="meta">    srcbegin--;\</span></span><br><span class="line"><span class="meta">    srcend--;\</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span>(srcend &lt;= 0)break;\</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span>(srcbegin == 0)&#123;\</span></span><br><span class="line"><span class="meta">      copybegin = newListNode(T)(srcit-&gt;val);\</span></span><br><span class="line"><span class="meta">      copyend = copybegin;\</span></span><br><span class="line"><span class="meta">      copylength++;\</span></span><br><span class="line"><span class="meta">    &#125;\</span></span><br><span class="line"><span class="meta">    <span class="keyword">else</span> <span class="keyword">if</span>(srcbegin &lt; 0)&#123;\</span></span><br><span class="line"><span class="meta">      ListNode_##T *node = newListNode(T)(srcit-&gt;val);\</span></span><br><span class="line"><span class="meta">      copyend-&gt;next = node;\</span></span><br><span class="line"><span class="meta">      node-&gt;pre = copyend;\</span></span><br><span class="line"><span class="meta">      copyend = copyend-&gt;next;\</span></span><br><span class="line"><span class="meta">      copylength++;\</span></span><br><span class="line"><span class="meta">    &#125;\</span></span><br><span class="line"><span class="meta">  &#125;\</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span>(srcbegin &gt; 0)&#123;\</span></span><br><span class="line"><span class="meta">    printf(<span class="string">&quot;srcbegin has out of range, so stop merge\n&quot;</span>);\</span></span><br><span class="line"><span class="meta">    return;\</span></span><br><span class="line"><span class="meta">  &#125;\</span></span><br><span class="line"><span class="meta">  dstit-&gt;next-&gt;pre = copyend;\</span></span><br><span class="line"><span class="meta">  copyend-&gt;next = dstit-&gt;next;\</span></span><br><span class="line"><span class="meta">  copybegin-&gt;pre = dstit;\</span></span><br><span class="line"><span class="meta">  dstit-&gt;next = copybegin;\</span></span><br><span class="line"><span class="meta">  dst-&gt;length += copylength;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Clear(T) void clear_##T(doublelist_##T *list)&#123;\</span></span><br><span class="line"><span class="meta">  while(list-&gt;head-&gt;next != list-&gt;tail)&#123;\</span></span><br><span class="line"><span class="meta">    ListNode_##T *deletenode = list-&gt;head-&gt;next;\</span></span><br><span class="line"><span class="meta">    list-&gt;head-&gt;next = list-&gt;head-&gt;next-&gt;next;\</span></span><br><span class="line"><span class="meta">    free(deletenode);\</span></span><br><span class="line"><span class="meta">  &#125;\</span></span><br><span class="line"><span class="meta">  list-&gt;tail-&gt;pre = list-&gt;head;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NewDoubleList(T) doublelist_##T *newDoubleList_##T()&#123;\</span></span><br><span class="line"><span class="meta">  doublelist_##T *doublelist = (doublelist_##T *) malloc(sizeof(doublelist_##T));\</span></span><br><span class="line"><span class="meta">  doublelist-&gt;head = (ListNode_##T *) malloc(sizeof(ListNode_##T));\</span></span><br><span class="line"><span class="meta">  doublelist-&gt;tail = (ListNode_##T *) malloc(sizeof(ListNode_##T));\</span></span><br><span class="line"><span class="meta">  doublelist-&gt;head-&gt;next = doublelist-&gt;tail;\</span></span><br><span class="line"><span class="meta">  doublelist-&gt;head-&gt;pre = doublelist-&gt;tail;\</span></span><br><span class="line"><span class="meta">  doublelist-&gt;tail-&gt;next = doublelist-&gt;head;\</span></span><br><span class="line"><span class="meta">  doublelist-&gt;tail-&gt;pre = doublelist-&gt;head;\</span></span><br><span class="line"><span class="meta">  doublelist-&gt;length = 0;\</span></span><br><span class="line"><span class="meta">  doublelist-&gt;insert = insert_##T;\</span></span><br><span class="line"><span class="meta">  doublelist-&gt;remove = remove_##T;\</span></span><br><span class="line"><span class="meta">  doublelist-&gt;clear = clear_##T;\</span></span><br><span class="line"><span class="meta">  doublelist-&gt;merge = merge_##T;\</span></span><br><span class="line"><span class="meta">  return doublelist;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DeleteDoubleList(T) void deleteDoubleList_##T(doublelist_##T *doublelist)&#123;\</span></span><br><span class="line"><span class="meta">  ListNode_##T *iterator = doublelist-&gt;head;\</span></span><br><span class="line"><span class="meta">  while(iterator)&#123;\</span></span><br><span class="line"><span class="meta">    ListNode_##T *deleteNode = iterator;\</span></span><br><span class="line"><span class="meta">    iterator = iterator-&gt;next;\</span></span><br><span class="line"><span class="meta">    free(deleteNode);\</span></span><br><span class="line"><span class="meta">  &#125;\</span></span><br><span class="line"><span class="meta">  free(doublelist);\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> newDoubleList(T) newDoubleList_##T</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> deleteDoubleList(T) deleteDoubleList_##T</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFINEDOUBLELIST(T) ListNode(T)\</span></span><br><span class="line"><span class="meta">  NewListNode(T)\</span></span><br><span class="line"><span class="meta">  DeleteListNode(T)\</span></span><br><span class="line"><span class="meta">  DoubleList(T)\</span></span><br><span class="line"><span class="meta">  Insert(T)\</span></span><br><span class="line"><span class="meta">  Remove(T)\</span></span><br><span class="line"><span class="meta">  Clear(T)\</span></span><br><span class="line"><span class="meta">  Merge(T)\</span></span><br><span class="line"><span class="meta">  NewDoubleList(T)\</span></span><br><span class="line"><span class="meta">  DeleteDoubleList(T)</span></span><br><span class="line"></span><br><span class="line">DEFINEDOUBLELIST(<span class="type">int</span>)</span><br><span class="line">DEFINEDOUBLELIST(<span class="type">char</span>)</span><br><span class="line">DEFINEDOUBLELIST(<span class="type">float</span>)</span><br><span class="line">DEFINEDOUBLELIST(<span class="type">double</span>)</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  doublelist(<span class="type">int</span>) *<span class="built_in">list</span> = newDoubleList(<span class="type">int</span>)();</span><br><span class="line">  doublelist(<span class="type">int</span>) *list1 = newDoubleList(<span class="type">int</span>)();</span><br><span class="line">  listnode(<span class="type">int</span>) *node = newListNode(<span class="type">int</span>)(<span class="number">10</span>);</span><br><span class="line">  listnode(<span class="type">int</span>) *node1 = newListNode(<span class="type">int</span>)(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">list</span>-&gt;insert(<span class="built_in">list</span>, <span class="number">0</span>, node);</span><br><span class="line">  <span class="built_in">list</span>-&gt;insert(<span class="built_in">list</span>, <span class="number">1</span>, node1);</span><br><span class="line">  listnode(<span class="type">int</span>) *node2 = newListNode(<span class="type">int</span>)(<span class="number">3</span>);</span><br><span class="line">  listnode(<span class="type">int</span>) *node3 = newListNode(<span class="type">int</span>)(<span class="number">4</span>);</span><br><span class="line">  list1-&gt;insert(list1, <span class="number">0</span>, node2);</span><br><span class="line">  list1-&gt;insert(list1, <span class="number">1</span>, node3);</span><br><span class="line">  <span class="built_in">list</span>-&gt;merge(<span class="built_in">list</span>, list1, <span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">  listnode(<span class="type">int</span>) *iterator = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">  <span class="keyword">while</span>(iterator-&gt;next != <span class="built_in">list</span>-&gt;tail)&#123;</span><br><span class="line">    iterator = iterator-&gt;next;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, iterator-&gt;val);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">list</span>-&gt;remove(<span class="built_in">list</span>, <span class="number">1</span>);</span><br><span class="line">  iterator = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">  <span class="keyword">while</span>(iterator-&gt;next != <span class="built_in">list</span>-&gt;tail)&#123;</span><br><span class="line">    iterator = iterator-&gt;next;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, iterator-&gt;val);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">free</span>(<span class="built_in">list</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="跳表">跳表</h3>
<p><img src="/Blog_NexT/2024/03/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/Untitled%201.png" alt="Untitled"></p>
<p>是一种随机化的数据结构，实质上就是一种可以进行二分查找的有序链表。跳表在原有的有序链表上面增加了多级索引，通过索引来实现快速查找。跳表不仅能提高搜索性能，同时也可以提高插入和删除操作的性能</p>
<p>这种随机的数据结构，可以看做是一个二叉树的变种，它在性能上与红黑树、AVL树很相近；但是Skip List(跳跃列表)的实现相比前两者要简单很多</p>
<p>从功能角度来看，跳跃表就像在链表之上架起了查询的“高速公路”，可以在普通链表上快速的查找到所要的元素。在查找元素时，跳表能够提供 O(log n) 的时间复杂度</p>
<p>对于一个链表来说，需要查找某个元素必须从头向后扫描，直到找到该元素或者扫描到完整的链表。</p>
<p>但是对于一个有序链表，可以提取出来其中的某些节点作为索引值，可以更快的找到所需要的元素，如上图</p>
<p>要想实现比较快的查找，可以通过构建索引，使得每一个 K 级节点都有 K + 1 个指针，分别跳过 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>K</mi></msup><mo>−</mo><mn>1</mn><mo separator="true">,</mo><msup><mn>2</mn><mrow><mi>K</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msup><mn>2</mn><mn>0</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^K-1,2^{K-1}-1,...,2^0-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.924661em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">K</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.035771em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">K</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.008548em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 个节点，这样就可以实现较快查找。</p>
<p>但是这个构建是静态的，并不能保证动态（插入或者删除节点）稳定性。所以可以首先确定一个实数 p，使得 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>&lt;</mo><mi>p</mi><mo>&lt;</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">0&lt;p&lt;1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7335400000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 并且要求在跳表中具有 K 级指针的节点所占的比例为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>100</mn><msup><mn>2</mn><mrow><mi>K</mi><mo>+</mo><mn>1</mn></mrow></msup></mfrac></mrow><annotation encoding="application/x-tex">\frac{100}{2^{K+1}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1969729999999998em;vertical-align:-0.35186499999999993em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.648135em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7740928571428571em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">K</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35186499999999993em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> 。这样每当插入新的节点时，那这个节点就有 50% 概率为 0 级节点，有…这就维持了跳跃表的平衡。</p>
<p>上述实现时，可以利用随机数 0~1，如果是 1 就加一个等级，一直到出现 0 为止。然后将节点插入到链表中</p>
<h2 id="数组">数组</h2>
<p><img src="/Blog_NexT/2024/03/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/Untitled%202.png" alt="Untitled"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// File Name: myarray.c</span></span><br><span class="line"><span class="comment">// Author: Dragon</span></span><br><span class="line"><span class="comment">// mail: [beloved25177@126.com](mailto:beloved25177@126.com)</span></span><br><span class="line"><span class="comment">// Created Time: Wed 27 Sep 2023 08:23:46 CST</span></span><br><span class="line"><span class="comment">// Description:</span></span><br><span class="line"><span class="comment">//------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Array(T) typedef struct array_##T&#123;\</span></span><br><span class="line"><span class="meta">  T *val;\</span></span><br><span class="line"><span class="meta">&#125;array_##T;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> array(T) array_##T</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NewArray(T) array_##T *newArray_##T(int size)&#123;\</span></span><br><span class="line"><span class="meta">  array(T) *array = (array_##T *)malloc(sizeof(array_##T));\</span></span><br><span class="line"><span class="meta">  array-&gt;val = (T *)malloc(sizeof(T) * size);\</span></span><br><span class="line"><span class="meta">  return array;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> newArray(T) newArray_##T</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DeleteArray(T) void deleteArray_##T(array_##T *array)&#123;\</span></span><br><span class="line"><span class="meta">  free(array-&gt;val);\</span></span><br><span class="line"><span class="meta">  free(array);\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> deleteArray(T) deleteArray_##T</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFINEARRAY(T) Array(T)\</span></span><br><span class="line"><span class="meta">NewArray(T)\</span></span><br><span class="line"><span class="meta">DeleteArray(T)</span></span><br><span class="line"></span><br><span class="line">DEFINEARRAY(<span class="type">int</span>)</span><br><span class="line">DEFINEARRAY(<span class="type">char</span>)</span><br><span class="line">DEFINEARRAY(<span class="type">float</span>)</span><br><span class="line">DEFINEARRAY(<span class="type">double</span>)</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="built_in">array</span>(<span class="type">int</span>) *a = newArray(<span class="type">int</span>)(<span class="number">10</span>);</span><br><span class="line">  *(a-&gt;val) = <span class="number">1</span>;</span><br><span class="line">  *(a-&gt;val + <span class="number">1</span>) = <span class="number">2</span>;</span><br><span class="line">  *(a-&gt;val + <span class="number">2</span>) = <span class="number">3</span>;</span><br><span class="line">  *(a-&gt;val + <span class="number">3</span>) = <span class="number">4</span>;</span><br><span class="line">  a-&gt;val[<span class="number">4</span>] = <span class="number">5</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *(a-&gt;val));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *(a-&gt;val + <span class="number">1</span>));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *(a-&gt;val + <span class="number">2</span>));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *(a-&gt;val + <span class="number">3</span>));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a-&gt;val[<span class="number">4</span>]);</span><br><span class="line"></span><br><span class="line">  deleteArray(<span class="type">int</span>)(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="队列">队列</h2>
<p>先进先出</p>
<h3 id="循环队列">循环队列</h3>
<p>固定长度的循环队列，在一般项目中比较常用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// File Name: myqueue.c</span></span><br><span class="line"><span class="comment">// Author: Dragon</span></span><br><span class="line"><span class="comment">// mail: [beloved25177@126.com](mailto:beloved25177@126.com)</span></span><br><span class="line"><span class="comment">// Created Time: Wed 27 Sep 2023 09:06:03 CST</span></span><br><span class="line"><span class="comment">// Description:</span></span><br><span class="line"><span class="comment">//------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Queue(T) typedef struct queue_##T&#123;\</span></span><br><span class="line"><span class="meta">  T *val;\</span></span><br><span class="line"><span class="meta">  int head;\</span></span><br><span class="line"><span class="meta">  int tail;\</span></span><br><span class="line"><span class="meta">  int size;\</span></span><br><span class="line"><span class="meta">  int (*maxsize)(struct queue_##T* queue);\</span></span><br><span class="line"><span class="meta">  int (*getsize)(struct queue_##T* queue);\</span></span><br><span class="line"><span class="meta">  int (*isempty)(struct queue_##T* queue);\</span></span><br><span class="line"><span class="meta">  int (*isfull)(struct queue_##T* queue);\</span></span><br><span class="line"><span class="meta">  void (*push)(struct queue_##T* queue, T val);\</span></span><br><span class="line"><span class="meta">  void (*pop)(struct queue_##T* queue);\</span></span><br><span class="line"><span class="meta">  T (*top)(struct queue_##T* queue);\</span></span><br><span class="line"><span class="meta">  void (*clear)(struct queue_##T *queue);\</span></span><br><span class="line"><span class="meta">&#125;queue_##T;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> queue(T) queue_##T</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Maxsize(T) int maxsize_##T(queue_##T *queue)&#123;return queue-&gt;size;&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Getsize(T) int getsize_##T(queue_##T *queue)&#123;\</span></span><br><span class="line"><span class="meta">  int size = queue-&gt;tail - queue-&gt;head;\</span></span><br><span class="line"><span class="meta">  while(size <span class="string">&lt; 0)size += queue-&gt;</span>size;\</span></span><br><span class="line"><span class="meta">  while(size &gt; queue-&gt;size)size -= queue-&gt;size;\</span></span><br><span class="line"><span class="meta">  return size;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Isempty(T) int isempty_##T(queue_##T *queue)&#123;\</span></span><br><span class="line"><span class="meta">  return queue-&gt;head == queue-&gt;tail;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Isfull(T) int isfull_##T(queue_##T *queue)&#123;\</span></span><br><span class="line"><span class="meta">  return queue-&gt;tail == (queue-&gt;head - 1 &gt;= 0? queue-&gt;head - 1 : queue-&gt;head - 1 + queue-&gt;size);\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Push(T) void push_##T(queue_##T *queue, T val)&#123;\</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span>(queue-&gt;tail == (queue-&gt;head - 1 &gt;= 0? queue-&gt;head - 1 : queue-&gt;head - 1 + queue-&gt;size))return;\</span></span><br><span class="line"><span class="meta">  queue-&gt;val[queue-&gt;tail] = val;\</span></span><br><span class="line"><span class="meta">  queue-&gt;tail += 1;\</span></span><br><span class="line"><span class="meta">  queue-&gt;tail %= queue-&gt;size;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Pop(T) void pop_##T(queue_##T *queue)&#123;\</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span>(queue-&gt;head == queue-&gt;tail)&#123;\</span></span><br><span class="line"><span class="meta">    printf(<span class="string">&quot;this queue is empty&quot;</span>);\</span></span><br><span class="line"><span class="meta">    return;\</span></span><br><span class="line"><span class="meta">  &#125;\</span></span><br><span class="line"><span class="meta">  queue-&gt;head++;\</span></span><br><span class="line"><span class="meta">  queue-&gt;head %= queue-&gt;size;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Top(T) T top_##T(queue_##T *queue)&#123;\</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span>(queue-&gt;head == queue-&gt;tail)&#123;\</span></span><br><span class="line"><span class="meta">    printf(<span class="string">&quot;this queue is empty&quot;</span>);\</span></span><br><span class="line"><span class="meta">    return (T)0;\</span></span><br><span class="line"><span class="meta">  &#125;\</span></span><br><span class="line"><span class="meta">  return queue-&gt;val[queue-&gt;head];\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Clear(T) void clear_##T(queue_##T *queue)&#123;\</span></span><br><span class="line"><span class="meta">  queue-&gt;head = 0;\</span></span><br><span class="line"><span class="meta">  queue-&gt;tail = 0;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NewQueue(T) queue_##T *newqueue_##T(int size)&#123;\</span></span><br><span class="line"><span class="meta">  queue_##T *queue = (queue_##T *) malloc(sizeof(queue_##T));\</span></span><br><span class="line"><span class="meta">  queue-&gt;val = (T *) malloc(sizeof(T) * size);\</span></span><br><span class="line"><span class="meta">  queue-&gt;size = size;\</span></span><br><span class="line"><span class="meta">  queue-&gt;head = 0;\</span></span><br><span class="line"><span class="meta">  queue-&gt;tail = 0;\</span></span><br><span class="line"><span class="meta">  queue-&gt;maxsize = maxsize_##T;\</span></span><br><span class="line"><span class="meta">  queue-&gt;getsize = getsize_##T;\</span></span><br><span class="line"><span class="meta">  queue-&gt;isempty = isempty_##T;\</span></span><br><span class="line"><span class="meta">  queue-&gt;isfull = isfull_##T;\</span></span><br><span class="line"><span class="meta">  queue-&gt;push = push_##T;\</span></span><br><span class="line"><span class="meta">  queue-&gt;pop = pop_##T;\</span></span><br><span class="line"><span class="meta">  queue-&gt;top = top_##T;\</span></span><br><span class="line"><span class="meta">  queue-&gt;clear = clear_##T;\</span></span><br><span class="line"><span class="meta">  return queue;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> newqueue(T) newqueue_##T</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DeleteQueue(T) void deletequeue_##T(queue_##T* queue)&#123;\</span></span><br><span class="line"><span class="meta">  free(queue-&gt;val);\</span></span><br><span class="line"><span class="meta">  free(queue);\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> deletequeue(T) deletequeue_##T</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFINEQUEUE(T) Queue(T)\</span></span><br><span class="line"><span class="meta">  Maxsize(T)\</span></span><br><span class="line"><span class="meta">  Getsize(T)\</span></span><br><span class="line"><span class="meta">  Isempty(T)\</span></span><br><span class="line"><span class="meta">  Isfull(T)\</span></span><br><span class="line"><span class="meta">  Push(T)\</span></span><br><span class="line"><span class="meta">  Pop(T)\</span></span><br><span class="line"><span class="meta">  Top(T)\</span></span><br><span class="line"><span class="meta">  Clear(T)\</span></span><br><span class="line"><span class="meta">  NewQueue(T)\</span></span><br><span class="line"><span class="meta">  DeleteQueue(T)</span></span><br><span class="line"></span><br><span class="line">DEFINEQUEUE(<span class="type">int</span>)</span><br><span class="line">DEFINEQUEUE(<span class="type">char</span>)</span><br><span class="line">DEFINEQUEUE(<span class="type">float</span>)</span><br><span class="line">DEFINEQUEUE(<span class="type">double</span>)</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="built_in">queue</span>(<span class="type">int</span>) *<span class="built_in">queue</span> = newqueue(<span class="type">int</span>)(<span class="number">10</span>);</span><br><span class="line">  <span class="built_in">queue</span>-&gt;push(<span class="built_in">queue</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">queue</span>-&gt;push(<span class="built_in">queue</span>, <span class="number">2</span>);</span><br><span class="line">  <span class="built_in">queue</span>-&gt;push(<span class="built_in">queue</span>, <span class="number">3</span>);</span><br><span class="line">  <span class="built_in">queue</span>-&gt;push(<span class="built_in">queue</span>, <span class="number">4</span>);</span><br><span class="line">  <span class="keyword">while</span>(!<span class="built_in">queue</span>-&gt;isempty(<span class="built_in">queue</span>))&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">queue</span>-&gt;top(<span class="built_in">queue</span>));</span><br><span class="line">    <span class="built_in">queue</span>-&gt;pop(<span class="built_in">queue</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  deletequeue(<span class="type">int</span>)(<span class="built_in">queue</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可扩充的双向循环队列</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// File Name: myqueue.c</span></span><br><span class="line"><span class="comment">// Author: Dragon</span></span><br><span class="line"><span class="comment">// mail: [beloved25177@126.com](mailto:beloved25177@126.com)</span></span><br><span class="line"><span class="comment">// Created Time: Wed 27 Sep 2023 09:06:03 CST</span></span><br><span class="line"><span class="comment">// Description:</span></span><br><span class="line"><span class="comment">//------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Queue(T) typedef struct queue_##T&#123;\</span></span><br><span class="line"><span class="meta">  void* start;\</span></span><br><span class="line"><span class="meta">  void* end;\</span></span><br><span class="line"><span class="meta">  T* ptr;\</span></span><br><span class="line"><span class="meta">  int size;\</span></span><br><span class="line"><span class="meta">  void (*push)(struct queue_##T *queue, T val);\</span></span><br><span class="line"><span class="meta">  void (*pop)(struct queue_##T *queue);\</span></span><br><span class="line"><span class="meta">  T (*top)(struct queue_##T* queue);\</span></span><br><span class="line"><span class="meta">&#125;queue_##T;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> queue(T) queue_##T</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Push(T) void push_##T(queue_##T *queue, T val)&#123;\</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span>(queue-&gt;ptr == queue-&gt;end)&#123;\</span></span><br><span class="line"><span class="meta">    T *newstart = (T *) malloc(2 *  queue-&gt;size);\</span></span><br><span class="line"><span class="meta">    memcpy(newstart, queue-&gt;start, queue-&gt;size);\</span></span><br><span class="line"><span class="meta">    free(queue-&gt;start);\</span></span><br><span class="line"><span class="meta">    queue-&gt;start = newstart;\</span></span><br><span class="line"><span class="meta">    queue-&gt;end = queue-&gt;start + queue-&gt;size * 2;\</span></span><br><span class="line"><span class="meta">    queue-&gt;ptr = queue-&gt;start + queue-&gt;size;\</span></span><br><span class="line"><span class="meta">    queue-&gt;size = 2 * queue-&gt;size;\</span></span><br><span class="line"><span class="meta">  &#125;\</span></span><br><span class="line"><span class="meta">  memmove(queue-&gt;ptr, &amp;val, sizeof(T));\</span></span><br><span class="line"><span class="meta">  queue-&gt;ptr += 1;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Pop(T) void pop_##T(queue_##T *queue)&#123;\</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span>((void *)queue-&gt;ptr == queue-&gt;start)return;\</span></span><br><span class="line"><span class="meta">  memmove(queue-&gt;start, queue-&gt;start + sizeof(T), queue-&gt;end - queue -&gt;start -  sizeof(T));\</span></span><br><span class="line"><span class="meta">  queue-&gt;ptr -=1;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Top(T) T top_##T(queue_##T *queue)&#123;\</span></span><br><span class="line"><span class="meta">  T data;\</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span>((void *)queue-&gt;ptr - queue-&gt;start &lt; sizeof(T))return 0;\</span></span><br><span class="line"><span class="meta">  memmove(&amp;data, queue-&gt;start, sizeof(T));\</span></span><br><span class="line"><span class="meta">  return data;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NewQueue(T) queue_##T *newqueue_##T()&#123;\</span></span><br><span class="line"><span class="meta">  queue_##T *queue = (queue_##T *) malloc(sizeof(queue_##T));\</span></span><br><span class="line"><span class="meta">  queue-&gt;start = malloc(sizeof(T) * 32);\</span></span><br><span class="line"><span class="meta">  queue-&gt;size = 32 * sizeof(T);\</span></span><br><span class="line"><span class="meta">  queue-&gt;end = queue-&gt;start + queue-&gt;size;\</span></span><br><span class="line"><span class="meta">  queue-&gt;ptr = queue-&gt;start;\</span></span><br><span class="line"><span class="meta">  queue-&gt;push = push_##T;\</span></span><br><span class="line"><span class="meta">  queue-&gt;pop = pop_##T;\</span></span><br><span class="line"><span class="meta">  queue-&gt;top = top_##T;\</span></span><br><span class="line"><span class="meta">  return queue;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> newqueue(T) newqueue_##T</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DeleteQueue(T) void deletequeue_##T(queue_##T* queue)&#123;\</span></span><br><span class="line"><span class="meta">  free(queue-&gt;start);\</span></span><br><span class="line"><span class="meta">  free(queue);\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> deletequeue(T) deletequeue_##T</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFINEQUEUE(T) Queue(T)\</span></span><br><span class="line"><span class="meta">  Push(T)\</span></span><br><span class="line"><span class="meta">  Pop(T)\</span></span><br><span class="line"><span class="meta">  Top(T)\</span></span><br><span class="line"><span class="meta">  NewQueue(T)\</span></span><br><span class="line"><span class="meta">  DeleteQueue(T)</span></span><br><span class="line"></span><br><span class="line">DEFINEQUEUE(<span class="type">int</span>)</span><br><span class="line">DEFINEQUEUE(<span class="type">char</span>)</span><br><span class="line">DEFINEQUEUE(<span class="type">float</span>)</span><br><span class="line">DEFINEQUEUE(<span class="type">double</span>)</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="built_in">queue</span>(<span class="type">int</span>) *<span class="built_in">queue</span> = newqueue(<span class="type">int</span>)();</span><br><span class="line">  <span class="type">int</span> i = <span class="number">33</span>;</span><br><span class="line">  <span class="keyword">while</span> (i--)</span><br><span class="line">    <span class="built_in">queue</span>-&gt;push(<span class="built_in">queue</span>, i);</span><br><span class="line">  i = <span class="number">33</span>;</span><br><span class="line">  <span class="keyword">while</span> (i--)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">queue</span>-&gt;top(<span class="built_in">queue</span>));</span><br><span class="line">    <span class="built_in">queue</span>-&gt;pop(<span class="built_in">queue</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  deletequeue(<span class="type">int</span>)(<span class="built_in">queue</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="优先可扩充队列"><strong>优先可扩充队列</strong></h3>
<p>根据特定的算法来实现排序，并且在每次插入元素时进行二分查找，找到合适的位置存入数据</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// File Name: priorityqueue.c</span></span><br><span class="line"><span class="comment">// Author: Dragon</span></span><br><span class="line"><span class="comment">// mail: [beloved25177@126.com](mailto:beloved25177@126.com)</span></span><br><span class="line"><span class="comment">// Created Time: Wed 04 Oct 2023 08:41:25 CST</span></span><br><span class="line"><span class="comment">// Description:  优先级队列</span></span><br><span class="line"><span class="comment">//------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DefaultCompare(T) int compare_##T(const T a, const T b)&#123;\</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span>(a &lt; b) return 1;\</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span>(a == b) return 0;\</span></span><br><span class="line"><span class="meta">  return -1;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line">DefaultCompare(<span class="type">int</span>)</span><br><span class="line">DefaultCompare(<span class="type">char</span>)</span><br><span class="line">DefaultCompare(<span class="type">float</span>)</span><br><span class="line">DefaultCompare(<span class="type">double</span>)</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> defaultcompare(T) compare_##T</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PriorityQueue(T) typedef struct priority_queue_##T&#123;\</span></span><br><span class="line"><span class="meta">  void *start;\</span></span><br><span class="line"><span class="meta">  void *end;\</span></span><br><span class="line"><span class="meta">  T *ptr;\</span></span><br><span class="line"><span class="meta">  int (*compare)(const T a, const T b);\</span></span><br><span class="line"><span class="meta">  void (*push)(struct priority_queue_##T *queue, const T val);\</span></span><br><span class="line"><span class="meta">  void (*pop)(struct priority_queue_##T *queue);\</span></span><br><span class="line"><span class="meta">  T (*top)(struct priority_queue_##T *queue);\</span></span><br><span class="line"><span class="meta">  T (*getval)(struct priority_queue_##T *queue, int index);\</span></span><br><span class="line"><span class="meta">  int (*find)(struct priority_queue_##T *queue, const T val);\</span></span><br><span class="line"><span class="meta">  int (*size)(struct priority_queue_##T *queue);\</span></span><br><span class="line"><span class="meta">  int (*maxsize)(struct priority_queue_##T *queue);\</span></span><br><span class="line"><span class="meta">  int (*isempty)(struct priority_queue_##T *queue);\</span></span><br><span class="line"><span class="meta">  void (*clear)(struct priority_queue_##T *queue);\</span></span><br><span class="line"><span class="meta">  void (*merge)(struct priority_queue_##T *dst, struct priority_queue_##T *src, int srcbegin, int srcend);\</span></span><br><span class="line"><span class="meta">&#125;priority_queue_##T;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> priorityqueue(T) priority_queue_##T</span></span><br><span class="line"><span class="comment">// Binary search sort insert</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Push(T) void push_##T(priority_queue_##T *queue, const T val)&#123;\</span></span><br><span class="line"><span class="meta">  int size = queue-&gt;ptr - (T *) queue-&gt;start;\</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span>(queue-&gt;ptr == queue-&gt;end)&#123;\</span></span><br><span class="line"><span class="meta">    void *newstart = malloc(sizeof(T) * size * 2);\</span></span><br><span class="line"><span class="meta">    memcpy(newstart, queue-&gt;start, size * sizeof(T));\</span></span><br><span class="line"><span class="meta">    queue-&gt;start = newstart;\</span></span><br><span class="line"><span class="meta">    queue-&gt;end = newstart + size * 2 * sizeof(T);\</span></span><br><span class="line"><span class="meta">    queue-&gt;ptr = newstart + size * sizeof(T);\</span></span><br><span class="line"><span class="meta">  &#125;\</span></span><br><span class="line"><span class="meta">  int left = 0, right = size;\</span></span><br><span class="line"><span class="meta">  while(right &gt; left)&#123;\</span></span><br><span class="line"><span class="meta">    int mid = (right + left) &gt;&gt; 1;\</span></span><br><span class="line"><span class="meta">    T *it = (T *) queue-&gt;start + mid;\</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span>(queue-&gt;compare(*it, val) &gt; 0) right = mid - 1;\</span></span><br><span class="line"><span class="meta">    <span class="keyword">else</span> <span class="keyword">if</span>(queue-&gt;compare(*it, val) &lt; 0) left = mid + 1;\</span></span><br><span class="line"><span class="meta">    <span class="keyword">else</span> &#123;\</span></span><br><span class="line"><span class="meta">      left = mid;\</span></span><br><span class="line"><span class="meta">      break;\</span></span><br><span class="line"><span class="meta">    &#125;\</span></span><br><span class="line"><span class="meta">  &#125;\</span></span><br><span class="line"><span class="meta">  memmove(queue-&gt;start + (left + 1) * sizeof(T), queue-&gt;start + (left + 0) * sizeof(T), (size - left) * sizeof(T));\</span></span><br><span class="line"><span class="meta">  *((T *) queue-&gt;start + left + 0) = val;\</span></span><br><span class="line"><span class="meta">  queue-&gt;ptr += 1;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Pop(T) void pop_##T(priority_queue_##T *queue)&#123;\</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span>(queue-&gt;start == (void *) queue-&gt;ptr)&#123;\</span></span><br><span class="line"><span class="meta">    printf(<span class="string">&quot;this queue has been empty\n&quot;</span>);\</span></span><br><span class="line"><span class="meta">    return;\</span></span><br><span class="line"><span class="meta">  &#125;\</span></span><br><span class="line"><span class="meta">  memcpy(queue-&gt;start, queue-&gt;start + sizeof(T), (queue-&gt;end - queue-&gt;start - 1));\</span></span><br><span class="line"><span class="meta">  queue-&gt;ptr -= 1;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Top(T) T top_##T(priority_queue_##T *queue)&#123;\</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span>(queue-&gt;start == (void *) queue-&gt;ptr)&#123;\</span></span><br><span class="line"><span class="meta">    printf(<span class="string">&quot;this queue has been empty\n&quot;</span>);\</span></span><br><span class="line"><span class="meta">    return (T) 0;\</span></span><br><span class="line"><span class="meta">  &#125;\</span></span><br><span class="line"><span class="meta">  T val = *((T *) queue-&gt;start);\</span></span><br><span class="line"><span class="meta">  return val;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Size(T) int size_##T(priority_queue_##T *queue)&#123;\</span></span><br><span class="line"><span class="meta">  return queue-&gt;ptr - (T *) queue-&gt;start;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Maxsize(T) int maxsize_##T(priority_queue_##T *queue)&#123;\</span></span><br><span class="line"><span class="meta">  return (T *) queue-&gt;end - (T *) queue-&gt;start;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Isempty(T) int isempty_##T(priority_queue_##T *queue)&#123;\</span></span><br><span class="line"><span class="meta">  return queue-&gt;start == (void *) queue-&gt;ptr;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Clear(T) void clear_##T(priority_queue_##T *queue)&#123;\</span></span><br><span class="line"><span class="meta">  queue-&gt;ptr = queue-&gt;start;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Find(T) int find_##T(priority_queue_##T *queue, const T val)&#123;\</span></span><br><span class="line"><span class="meta">  int size = queue-&gt;ptr - (T *) queue-&gt;start;\</span></span><br><span class="line"><span class="meta">  int left = 0, right = size - 1;\</span></span><br><span class="line"><span class="meta">  while(right &gt; left)&#123;\</span></span><br><span class="line"><span class="meta">    int mid = (left + right) &gt;&gt; 1;\</span></span><br><span class="line"><span class="meta">    T *it = (T *) queue-&gt;start + mid;\</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span>(queue-&gt;compare(*it, val) &gt; 0) right = mid - 1;\</span></span><br><span class="line"><span class="meta">    <span class="keyword">else</span> <span class="keyword">if</span>(queue-&gt;compare(*it, val) &lt; 0) left = mid + 1;\</span></span><br><span class="line"><span class="meta">    <span class="keyword">else</span> return mid;\</span></span><br><span class="line"><span class="meta">  &#125;\</span></span><br><span class="line"><span class="meta">  return -1;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GetVal(T) T getval_##T(priority_queue_##T *queue, int index)&#123;\</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span>(index * sizeof(T) + queue-&gt;start &gt; (void *) queue-&gt;ptr)&#123;\</span></span><br><span class="line"><span class="meta">    printf(<span class="string">&quot;index has out of range\n&quot;</span>);\</span></span><br><span class="line"><span class="meta">    return (T) 0;\</span></span><br><span class="line"><span class="meta">  &#125;\</span></span><br><span class="line"><span class="meta">  return *((T *) queue-&gt;start + index);\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Merge(T) void merge_##T(priority_queue_##T *dst, priority_queue_##T *src, int srcbegin, int srcend)&#123;\</span></span><br><span class="line"><span class="meta">  int srcsize = src-&gt;ptr - (T *) src-&gt;start;\</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span>(srcsize &lt; srcbegin)&#123;\</span></span><br><span class="line"><span class="meta">    printf(<span class="string">&quot;srcbegin has out of index, stop merge\n&quot;</span>);\</span></span><br><span class="line"><span class="meta">    return;\</span></span><br><span class="line"><span class="meta">  &#125;\</span></span><br><span class="line"><span class="meta">  for(int i = srcbegin; i &lt; srcend &amp;&amp; i &lt; srcsize; i++)&#123;\</span></span><br><span class="line"><span class="meta">    dst-&gt;push(dst, *((T *) src-&gt;start + i));\</span></span><br><span class="line"><span class="meta">  &#125;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NewPriorityQueue(T) priority_queue_##T *newpriorityqueue_##T(int (*compare)(const T a, const T b))&#123;\</span></span><br><span class="line"><span class="meta">  priority_queue_##T *queue = (priority_queue_##T *) malloc(sizeof(priority_queue_##T));\</span></span><br><span class="line"><span class="meta">  queue-&gt;start = malloc(32 * sizeof(T));\</span></span><br><span class="line"><span class="meta">  queue-&gt;end = queue-&gt;start + 32 * sizeof(T);\</span></span><br><span class="line"><span class="meta">  queue-&gt;ptr = queue-&gt;start;\</span></span><br><span class="line"><span class="meta">  queue-&gt;compare = compare;\</span></span><br><span class="line"><span class="meta">  queue-&gt;push = push_##T;\</span></span><br><span class="line"><span class="meta">  queue-&gt;pop = pop_##T;\</span></span><br><span class="line"><span class="meta">  queue-&gt;top = top_##T;\</span></span><br><span class="line"><span class="meta">  queue-&gt;size = size_##T;\</span></span><br><span class="line"><span class="meta">  queue-&gt;maxsize = maxsize_##T;\</span></span><br><span class="line"><span class="meta">  queue-&gt;isempty = isempty_##T;\</span></span><br><span class="line"><span class="meta">  queue-&gt;clear = clear_##T;\</span></span><br><span class="line"><span class="meta">  queue-&gt;find = find_##T;\</span></span><br><span class="line"><span class="meta">  queue-&gt;getval = getval_##T;\</span></span><br><span class="line"><span class="meta">  queue-&gt;merge = merge_##T;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DeletePriorityQueue(T) void deletepriorityqueue_##T(priority_queue_##T *queue)&#123;\</span></span><br><span class="line"><span class="meta">  free(queue-&gt;start);\</span></span><br><span class="line"><span class="meta">  free(queue);\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> newpriorityqueue(T) newpriorityqueue_##T</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> deletepriorityqueue(T) deletepriorityqueue_##T</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFINEPRIORITYQUEUE(T) PriorityQueue(T)\</span></span><br><span class="line"><span class="meta">  Push(T)\</span></span><br><span class="line"><span class="meta">  Pop(T)\</span></span><br><span class="line"><span class="meta">  Top(T)\</span></span><br><span class="line"><span class="meta">  Size(T)\</span></span><br><span class="line"><span class="meta">  Maxsize(T)\</span></span><br><span class="line"><span class="meta">  Isempty(T)\</span></span><br><span class="line"><span class="meta">  Clear(T)\</span></span><br><span class="line"><span class="meta">  Find(T)\</span></span><br><span class="line"><span class="meta">  GetVal(T)\</span></span><br><span class="line"><span class="meta">  Merge(T)\</span></span><br><span class="line"><span class="meta">  NewPriorityQueue(T)\</span></span><br><span class="line"><span class="meta">  DeletePriorityQueue(T)</span></span><br><span class="line"></span><br><span class="line">DEFINEPRIORITYQUEUE(<span class="type">int</span>)</span><br><span class="line">DEFINEPRIORITYQUEUE(<span class="type">char</span>)</span><br><span class="line">DEFINEPRIORITYQUEUE(<span class="type">float</span>)</span><br><span class="line">DEFINEPRIORITYQUEUE(<span class="type">double</span>)</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  priorityqueue(<span class="type">int</span>) *<span class="built_in">queue</span> = newpriorityqueue(<span class="type">int</span>) (defaultcompare(<span class="type">int</span>));</span><br><span class="line">  <span class="built_in">queue</span>-&gt;push(<span class="built_in">queue</span>, <span class="number">10</span>);</span><br><span class="line">  <span class="built_in">queue</span>-&gt;push(<span class="built_in">queue</span>, <span class="number">11</span>);</span><br><span class="line">  <span class="built_in">queue</span>-&gt;push(<span class="built_in">queue</span>, <span class="number">15</span>);</span><br><span class="line">  <span class="built_in">queue</span>-&gt;push(<span class="built_in">queue</span>, <span class="number">9</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">queue</span>-&gt;find(<span class="built_in">queue</span>, <span class="number">2</span>));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">queue</span>-&gt;find(<span class="built_in">queue</span>, <span class="number">10</span>));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">queue</span>-&gt;size(<span class="built_in">queue</span>));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">queue</span>-&gt;getval(<span class="built_in">queue</span>, <span class="number">1</span>));</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">queue</span>-&gt;top(<span class="built_in">queue</span>));</span><br><span class="line">    <span class="built_in">queue</span>-&gt;pop(<span class="built_in">queue</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  deletepriorityqueue(<span class="type">int</span>) (<span class="built_in">queue</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="向量">向量</h2>
<p>有点类似于队列，但是在 C++ 中 vector 有个特点就是每次内存不足时会申请原来的内存的两倍的内存，然后将数据存入</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// File Name: myvector.c</span></span><br><span class="line"><span class="comment">// Author: Dragon</span></span><br><span class="line"><span class="comment">// mail: [beloved25177@126.com](mailto:beloved25177@126.com)</span></span><br><span class="line"><span class="comment">// Created Time: Fri 29 Sep 2023 11:36:37 CST</span></span><br><span class="line"><span class="comment">// Description: 向量</span></span><br><span class="line"><span class="comment">//------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Vector(T) typedef struct vector_##T&#123;\</span></span><br><span class="line"><span class="meta">  void *start;\</span></span><br><span class="line"><span class="meta">  void *end;\</span></span><br><span class="line"><span class="meta">  T *ptr;\</span></span><br><span class="line"><span class="meta">  int (*size)(struct vector_##T *vector);\</span></span><br><span class="line"><span class="meta">  int (*max_size)(struct vector_##T *vector);\</span></span><br><span class="line"><span class="meta">  int (*isempty)(struct vector_##T *vector);\</span></span><br><span class="line"><span class="meta">  void (*push_back)(struct vector_##T *vector, T val);\</span></span><br><span class="line"><span class="meta">  void (*pop_back)(struct vector_##T *vector);\</span></span><br><span class="line"><span class="meta">  void (*remove)(struct vector_##T *vec, int begin, int end);\</span></span><br><span class="line"><span class="meta">  int (*find)(struct vector_##T *vec, T val);\</span></span><br><span class="line"><span class="meta">  T (*back)(struct vector_##T *vector);\</span></span><br><span class="line"><span class="meta">  T (*front)(struct vector_##T *vector);\</span></span><br><span class="line"><span class="meta">  void (*copyfrom)(struct vector_##T *dst, struct vector_##T *src, int srcbegin, int srcend);\</span></span><br><span class="line"><span class="meta">  void (*merge)(struct vector_##T *dst, struct vector_##T *src, int dstbegin, int srcbegin, int srcend);\</span></span><br><span class="line"><span class="meta">  void (*clear)(struct vector_##T *vec);\</span></span><br><span class="line"><span class="meta">&#125;vector_##T;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> vector(T) vector_##T</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Size(T) int size_##T(vector_##T *vector)&#123;\</span></span><br><span class="line"><span class="meta">  return vector-&gt;ptr - (T *)vector-&gt;start;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Max_size(T) int max_size_##T(vector_##T *vector)&#123;\</span></span><br><span class="line"><span class="meta">  return (T *) vector-&gt;end - (T *) vector-&gt;start;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Isempty(T) int isempty_##T(vector_##T *vector)&#123;\</span></span><br><span class="line"><span class="meta">  return (void *) vector-&gt;ptr == vector-&gt;start;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Push_back(T) void push_back_##T(vector_##T *vector, T val)&#123;\</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span>(vector-&gt;end - (void *)vector-&gt;ptr &lt; sizeof(T))&#123;\</span></span><br><span class="line"><span class="meta">    int size = vector-&gt;end - vector-&gt;start;\</span></span><br><span class="line"><span class="meta">    void *newstart = malloc(size * 2);\</span></span><br><span class="line"><span class="meta">    memcpy(newstart, vector-&gt;start, size);\</span></span><br><span class="line"><span class="meta">    free(vector-&gt;start);\</span></span><br><span class="line"><span class="meta">    vector-&gt;start = newstart;\</span></span><br><span class="line"><span class="meta">    vector-&gt;end = vector-&gt;start + size * 2;\</span></span><br><span class="line"><span class="meta">    vector-&gt;ptr = vector-&gt;start + size;\</span></span><br><span class="line"><span class="meta">  &#125;\</span></span><br><span class="line"><span class="meta">  memcpy(vector-&gt;ptr, &amp;val, sizeof(T));\</span></span><br><span class="line"><span class="meta">  vector-&gt;ptr += 1;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Pop_back(T) void pop_back_##T(vector_##T *vector)&#123;\</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span>(vector-&gt;ptr != vector-&gt;start)\</span></span><br><span class="line"><span class="meta">    vector-&gt;ptr -= 1;\</span></span><br><span class="line"><span class="meta">  <span class="keyword">else</span> \</span></span><br><span class="line"><span class="meta">    printf(<span class="string">&quot;this vector has been empty\n&quot;</span>);\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Back(T) T back_##T(vector_##T *vector)&#123;\</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span>(vector-&gt;ptr == vector-&gt;start)&#123;\</span></span><br><span class="line"><span class="meta">    printf(<span class="string">&quot;this vector is empty\n&quot;</span>);\</span></span><br><span class="line"><span class="meta">    return (T)0;\</span></span><br><span class="line"><span class="meta">  &#125;\</span></span><br><span class="line"><span class="meta">  T val;\</span></span><br><span class="line"><span class="meta">  memcpy(&amp;val, vector-&gt;ptr - 1, sizeof(T));\</span></span><br><span class="line"><span class="meta">  return val;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Front(T) T front_##T(vector_##T *vector)&#123;\</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span>(vector-&gt;ptr == vector-&gt;start)&#123;\</span></span><br><span class="line"><span class="meta">    printf(<span class="string">&quot;this vector is empty\n&quot;</span>);\</span></span><br><span class="line"><span class="meta">    return (T)0;\</span></span><br><span class="line"><span class="meta">  &#125;\</span></span><br><span class="line"><span class="meta">  T val;\</span></span><br><span class="line"><span class="meta">  memcpy(&amp;val, vector-&gt;start, sizeof(T));\</span></span><br><span class="line"><span class="meta">  return val;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Remove(T) void remove_##T(vector_##T *vec, int begin, int end)&#123;\</span></span><br><span class="line"><span class="meta">  T *pbegin = vec-&gt;start + begin;\</span></span><br><span class="line"><span class="meta">  T *pend = vec-&gt;start + end;\</span></span><br><span class="line"><span class="meta">  memcpy((void *)pbegin, (void *)pend, ((void *) vec-&gt;ptr - (void *) pend));\</span></span><br><span class="line"><span class="meta">  vec-&gt;ptr = pbegin + (vec-&gt;ptr - pend);\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Find(T) int find_##T(vector_##T *vec, T val)&#123;\</span></span><br><span class="line"><span class="meta">  T *iterator = vec-&gt;start;\</span></span><br><span class="line"><span class="meta">  int index = 0;\</span></span><br><span class="line"><span class="meta">  while(iterator != vec-&gt;ptr)&#123;\</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span>(*iterator == val)return index;\</span></span><br><span class="line"><span class="meta">    iterator++;\</span></span><br><span class="line"><span class="meta">    index++;\</span></span><br><span class="line"><span class="meta">  &#125;\</span></span><br><span class="line"><span class="meta">  return -1;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="comment">// srcbegin and srcend is index</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Copyfrom(T) void copyfrom_##T(vector_##T *dst, vector_##T *src, int srcbegin, int srcend)&#123;\</span></span><br><span class="line"><span class="meta">  int srcsize = (void *) src-&gt;ptr - src-&gt;start;\</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span>(srcbegin * sizeof(T) &gt; srcsize)&#123;\</span></span><br><span class="line"><span class="meta">    printf(<span class="string">&quot;begin index has out of range&quot;</span>);\</span></span><br><span class="line"><span class="meta">    return;\</span></span><br><span class="line"><span class="meta">  &#125;\</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span>(srcend * sizeof(T) &gt; srcsize)&#123;\</span></span><br><span class="line"><span class="meta">    printf(<span class="string">&quot;end index has out of range&quot;</span>);\</span></span><br><span class="line"><span class="meta">    return;\</span></span><br><span class="line"><span class="meta">  &#125;\</span></span><br><span class="line"><span class="meta">  int dstmaxsize = dst-&gt;end - dst-&gt;start;\</span></span><br><span class="line"><span class="meta">  int copysize = sizeof(T) * (srcend - srcbegin);\</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span>(dstmaxsize &lt; copysize)&#123;\</span></span><br><span class="line"><span class="meta">    while(dstmaxsize &lt; copysize)\</span></span><br><span class="line"><span class="meta">      dstmaxsize &lt;&lt; 2;\</span></span><br><span class="line"><span class="meta">    void *newstart = malloc(dstmaxsize);\</span></span><br><span class="line"><span class="meta">    dst-&gt;start = newstart;\</span></span><br><span class="line"><span class="meta">  &#125;\</span></span><br><span class="line"><span class="meta">  memcpy(dst-&gt;start, src-&gt;start + sizeof(T) * srcbegin, copysize);\</span></span><br><span class="line"><span class="meta">  dst-&gt;ptr = (T *) dst-&gt;start + srcend - srcbegin;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Merge(T) void merge_##T(struct vector_##T *dst, struct vector_##T *src, int dstbegin, int srcbegin, int srcend)&#123;\</span></span><br><span class="line"><span class="meta">  int srcsize = (void *) src-&gt;ptr - src-&gt;start;\</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span>(srcbegin * sizeof(T) &gt; srcsize)&#123;\</span></span><br><span class="line"><span class="meta">    printf(<span class="string">&quot;begin index has out of range&quot;</span>);\</span></span><br><span class="line"><span class="meta">    return;\</span></span><br><span class="line"><span class="meta">  &#125;\</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span>(srcend * sizeof(T) &gt; srcsize)&#123;\</span></span><br><span class="line"><span class="meta">    printf(<span class="string">&quot;end index has out of range&quot;</span>);\</span></span><br><span class="line"><span class="meta">    return;\</span></span><br><span class="line"><span class="meta">  &#125;\</span></span><br><span class="line"><span class="meta">  int dstmaxsize = dst-&gt;end - dst-&gt;start;\</span></span><br><span class="line"><span class="meta">  int dstsize = (void *) dst-&gt;ptr - dst-&gt;start;\</span></span><br><span class="line"><span class="meta">  while(dstmaxsize &lt; dstsize + (srcend - srcbegin) * sizeof(T))\</span></span><br><span class="line"><span class="meta">    dstmaxsize &lt;&lt; 2;\</span></span><br><span class="line"><span class="meta">  void *newstart = malloc(dstmaxsize);\</span></span><br><span class="line"><span class="meta">  memcpy(newstart, dst-&gt;start, dstbegin * sizeof(T));\</span></span><br><span class="line"><span class="meta">  memcpy(newstart + dstbegin * sizeof(T), src-&gt;start + srcbegin * sizeof(T), (srcend - srcbegin) * sizeof(T));\</span></span><br><span class="line"><span class="meta">  memcpy(newstart + dstbegin * sizeof(T) + srcsize, dst-&gt;start + dstbegin * sizeof(T), (void *) dst-&gt;ptr - dst-&gt;start - dstbegin * sizeof(T));\</span></span><br><span class="line"><span class="meta">  free(dst-&gt;start);\</span></span><br><span class="line"><span class="meta">  dst-&gt;start = newstart;\</span></span><br><span class="line"><span class="meta">  dst-&gt;end = newstart + dstmaxsize;\</span></span><br><span class="line"><span class="meta">  dst-&gt;ptr = newstart + dstsize + (srcend - srcbegin) * sizeof(T);\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Clear(T) void clear_##T(vector_##T *vec)&#123;\</span></span><br><span class="line"><span class="meta">  vec-&gt;ptr = vec-&gt;start;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NewVector(T) vector_##T *newvector_##T()&#123;\</span></span><br><span class="line"><span class="meta">  vector_##T *vector = malloc(sizeof(vector_##T));\</span></span><br><span class="line"><span class="meta">  vector-&gt;start = malloc(sizeof(T) * 32);\</span></span><br><span class="line"><span class="meta">  vector-&gt;end = vector-&gt;start + sizeof(T) * 32;\</span></span><br><span class="line"><span class="meta">  vector-&gt;ptr = vector-&gt;start;\</span></span><br><span class="line"><span class="meta">  vector-&gt;size = size_##T;\</span></span><br><span class="line"><span class="meta">  vector-&gt;max_size = max_size_##T;\</span></span><br><span class="line"><span class="meta">  vector-&gt;push_back = push_back_##T;\</span></span><br><span class="line"><span class="meta">  vector-&gt;pop_back = pop_back_##T;\</span></span><br><span class="line"><span class="meta">  vector-&gt;front = front_##T;\</span></span><br><span class="line"><span class="meta">  vector-&gt;back = back_##T;\</span></span><br><span class="line"><span class="meta">  vector-&gt;find = find_##T;\</span></span><br><span class="line"><span class="meta">  vector-&gt;remove = remove_##T;\</span></span><br><span class="line"><span class="meta">  vector-&gt;copyfrom = copyfrom_##T;\</span></span><br><span class="line"><span class="meta">  vector-&gt;merge = merge_##T;\</span></span><br><span class="line"><span class="meta">  vector-&gt;clear = clear_##T;\</span></span><br><span class="line"><span class="meta">  return vector;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DeleteVector(T) void deletevector_##T(vector_##T *vector)&#123;\</span></span><br><span class="line"><span class="meta">  free(vector-&gt;start);\</span></span><br><span class="line"><span class="meta">  free(vector);\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> newvector(T) newvector_##T</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> deletevector(T) deletevector_##T</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFINEVECTOR(T) Vector(T)\</span></span><br><span class="line"><span class="meta">  Size(T)\</span></span><br><span class="line"><span class="meta">  Max_size(T)\</span></span><br><span class="line"><span class="meta">  Push_back(T)\</span></span><br><span class="line"><span class="meta">  Pop_back(T)\</span></span><br><span class="line"><span class="meta">  Back(T)\</span></span><br><span class="line"><span class="meta">  Front(T)\</span></span><br><span class="line"><span class="meta">  Remove(T)\</span></span><br><span class="line"><span class="meta">  Find(T)\</span></span><br><span class="line"><span class="meta">  Copyfrom(T)\</span></span><br><span class="line"><span class="meta">  Merge(T)\</span></span><br><span class="line"><span class="meta">  Clear(T)\</span></span><br><span class="line"><span class="meta">  NewVector(T)\</span></span><br><span class="line"><span class="meta">  DeleteVector(T)</span></span><br><span class="line"></span><br><span class="line">DEFINEVECTOR(<span class="type">int</span>)</span><br><span class="line">DEFINEVECTOR(<span class="type">char</span>)</span><br><span class="line">DEFINEVECTOR(<span class="type">float</span>)</span><br><span class="line">DEFINEVECTOR(<span class="type">double</span>)</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="built_in">vector</span>(<span class="type">int</span>) *v = newvector(<span class="type">int</span>)();</span><br><span class="line">  <span class="built_in">vector</span>(<span class="type">int</span>) *v2 =newvector(<span class="type">int</span>)();</span><br><span class="line">  <span class="type">int</span> i = <span class="number">33</span>;</span><br><span class="line">  <span class="keyword">while</span>(i--)&#123;</span><br><span class="line">    v-&gt;push_back(v, i);</span><br><span class="line">  &#125;</span><br><span class="line">  i = <span class="number">33</span>;</span><br><span class="line">  v2-&gt;copyfrom(v2, v, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">  v2-&gt;merge(v2, v, <span class="number">5</span>, <span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line">  <span class="keyword">while</span>(i--)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, v-&gt;back(v));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, v2-&gt;back(v2));</span><br><span class="line">    v-&gt;pop_back(v);</span><br><span class="line">    v2-&gt;pop_back(v2);</span><br><span class="line">  &#125;</span><br><span class="line">  v-&gt;pop_back(v);</span><br><span class="line">  deletevector(<span class="type">int</span>)(v);</span><br><span class="line">  deletevector(<span class="type">int</span>)(v2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="栈">栈</h2>
<p><img src="/Blog_NexT/2024/03/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/Untitled%203.png" alt="Untitled"></p>
<p>栈和堆是计算机中比较常用的数据结构，在计算机中，会有栈内存和堆内存，堆是向高地址扩展 也就是常说的向上生长。是不连续的内存区域。栈是向低地址扩展 也就是常说的向下生长。 是连续的内存区域。而且栈是系统分配的内存，速度较快，会自动回收，但是堆是程序员分配的内存，不会自动回收，但是程序结束之后会被回收。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// File Name: mystack.c</span></span><br><span class="line"><span class="comment">// Author: Dragon</span></span><br><span class="line"><span class="comment">// mail: [beloved25177@126.com](mailto:beloved25177@126.com)</span></span><br><span class="line"><span class="comment">// Created Time: Fri 29 Sep 2023 14:05:50 CST</span></span><br><span class="line"><span class="comment">// Description: 栈</span></span><br><span class="line"><span class="comment">//------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Stack(T) typedef struct stack_##T&#123;\</span></span><br><span class="line"><span class="meta">  void *start;\</span></span><br><span class="line"><span class="meta">  void *end;\</span></span><br><span class="line"><span class="meta">  T *ptr;\</span></span><br><span class="line"><span class="meta">  void (*push)(struct stack_##T *stack, T val);\</span></span><br><span class="line"><span class="meta">  void (*pop)(struct stack_##T *stack);\</span></span><br><span class="line"><span class="meta">  T (*top)(struct stack_##T *stack);\</span></span><br><span class="line"><span class="meta">  int (*isfull)(struct stack_##T *stack);\</span></span><br><span class="line"><span class="meta">  int (*isempty)(struct stack_##T *stack);\</span></span><br><span class="line"><span class="meta">  int (*size)(struct stack_##T *stack);\</span></span><br><span class="line"><span class="meta">  int (*maxsize)(struct stack_##T *stack);\</span></span><br><span class="line"><span class="meta">&#125;stack_##T;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> stack(T) stack_##T</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Push(T) void push_##T(stack_##T *stack, T val)&#123;\</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span>(stack-&gt;end - (void *)stack-&gt;ptr &lt; sizeof(T))&#123;\</span></span><br><span class="line"><span class="meta">    printf(<span class="string">&quot;this stack has been full\n&quot;</span>);\</span></span><br><span class="line"><span class="meta">    return;\</span></span><br><span class="line"><span class="meta">  &#125;\</span></span><br><span class="line"><span class="meta">  memcpy((void *)(stack-&gt;ptr), &amp;val, sizeof(T));\</span></span><br><span class="line"><span class="meta">  stack-&gt;ptr += 1;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Pop(T) void pop_##T(stack_##T *stack)&#123;\</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span>((void *)stack-&gt;ptr - stack-&gt;start &lt; sizeof(T))&#123;\</span></span><br><span class="line"><span class="meta">    printf(<span class="string">&quot;this stack has been empty\n&quot;</span>);\</span></span><br><span class="line"><span class="meta">    return;\</span></span><br><span class="line"><span class="meta">  &#125;\</span></span><br><span class="line"><span class="meta">  stack-&gt;ptr -= 1;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Top(T) T top_##T(stack_##T *stack)&#123;\</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span>(stack-&gt;start == (void *)stack-&gt;ptr)return (T)0;\</span></span><br><span class="line"><span class="meta">  T data;\</span></span><br><span class="line"><span class="meta">  memcpy(&amp;data, stack-&gt;ptr - 1, sizeof(T));\</span></span><br><span class="line"><span class="meta">  return data;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Isfull(T) int isfull_##T(stack_##T *stack)&#123;\</span></span><br><span class="line"><span class="meta">  return (void *)stack-&gt;ptr == stack-&gt;end;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Isempty(T) int isempty_##T(stack_##T *stack)&#123;\</span></span><br><span class="line"><span class="meta">  return (void *)stack-&gt;ptr == stack-&gt;start;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Size(T) int size_##T(stack_##T *stack)&#123;\</span></span><br><span class="line"><span class="meta">  return stack-&gt;ptr - (T *) stack-&gt;start;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Maxsize(T) int maxsize_##T(stack_##T *stack)&#123;\</span></span><br><span class="line"><span class="meta">  return (T *) stack-&gt;end - (T *) stack-&gt;start;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NewStack(T) stack_##T *newStack_##T(int size)&#123;\</span></span><br><span class="line"><span class="meta">  stack_##T *stack = (stack_##T *) malloc(sizeof(stack_##T));\</span></span><br><span class="line"><span class="meta">  stack-&gt;start = malloc(sizeof(T) * size);\</span></span><br><span class="line"><span class="meta">  stack-&gt;end = stack-&gt;start + sizeof(T) * size;\</span></span><br><span class="line"><span class="meta">  stack-&gt;ptr = stack-&gt;start;\</span></span><br><span class="line"><span class="meta">  stack-&gt;push = push_##T;\</span></span><br><span class="line"><span class="meta">  stack-&gt;pop = pop_##T;\</span></span><br><span class="line"><span class="meta">  stack-&gt;top = top_##T;\</span></span><br><span class="line"><span class="meta">  stack-&gt;isfull = isfull_##T;\</span></span><br><span class="line"><span class="meta">  stack-&gt;isempty = isempty_##T;\</span></span><br><span class="line"><span class="meta">  stack-&gt;size = size_##T;\</span></span><br><span class="line"><span class="meta">  stack-&gt;maxsize = maxsize_##T;\</span></span><br><span class="line"><span class="meta">  return stack;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> newStack(T) newStack_##T</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DeleteStack(T) void deleteStack_##T(stack_##T *stack)&#123;\</span></span><br><span class="line"><span class="meta">  stack-&gt;ptr = NULL;\</span></span><br><span class="line"><span class="meta">  stack-&gt;end = NULL;\</span></span><br><span class="line"><span class="meta">  free(stack-&gt;start);\</span></span><br><span class="line"><span class="meta">  free(stack);\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> deleteStack(T) deleteStack_##T</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对外接口</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFINESTACK(T) Stack(T)\</span></span><br><span class="line"><span class="meta">  Push(T)\</span></span><br><span class="line"><span class="meta">  Pop(T)\</span></span><br><span class="line"><span class="meta">  Top(T)\</span></span><br><span class="line"><span class="meta">  Isfull(T)\</span></span><br><span class="line"><span class="meta">  Isempty(T)\</span></span><br><span class="line"><span class="meta">  Size(T);\</span></span><br><span class="line"><span class="meta">  Maxsize(T)\</span></span><br><span class="line"><span class="meta">  NewStack(T)\</span></span><br><span class="line"><span class="meta">  DeleteStack(T)</span></span><br><span class="line"></span><br><span class="line">DEFINESTACK(<span class="type">int</span>)</span><br><span class="line">DEFINESTACK(<span class="type">char</span>)</span><br><span class="line">DEFINESTACK(<span class="type">float</span>)</span><br><span class="line">DEFINESTACK(<span class="type">double</span>)</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="built_in">stack</span>(<span class="type">int</span>) *<span class="built_in">stack</span> = newStack(<span class="type">int</span>)(<span class="number">10</span>);</span><br><span class="line">  <span class="type">int</span> i = <span class="number">13</span>;</span><br><span class="line">  <span class="keyword">while</span>(i--)&#123;</span><br><span class="line">    <span class="built_in">stack</span>-&gt;push(<span class="built_in">stack</span>, i);</span><br><span class="line">  &#125;</span><br><span class="line">  i = <span class="number">13</span>;</span><br><span class="line">  <span class="keyword">while</span>(i--)&#123;</span><br><span class="line">    <span class="type">int</span> a = (<span class="built_in">stack</span>-&gt;top(<span class="built_in">stack</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a);</span><br><span class="line">    <span class="built_in">stack</span>-&gt;pop(<span class="built_in">stack</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="树">树</h2>
<h3 id="二叉树">二叉树</h3>
<p>每个树的节点有两个子结点 <code>right_leaf, left_leaf</code> ，从而树的结构表现为两个叉</p>
<h3 id="平衡二叉树">平衡二叉树</h3>
<p>是一种特殊的二叉树，但是左右两侧的树的高度之差不超过1，而且在二叉树中的查找速度相当于是 $$O(\log_2n)$$ 。但是需要特定的算法来保持树的平衡</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// File Name: mybinarytree.c</span></span><br><span class="line"><span class="comment">// Author: Dragon</span></span><br><span class="line"><span class="comment">// mail: [beloved25177@126.com](mailto:beloved25177@126.com)</span></span><br><span class="line"><span class="comment">// Created Time: Mon 02 Oct 2023 10:57:36 CST</span></span><br><span class="line"><span class="comment">// Description: （平衡）二叉树</span></span><br><span class="line"><span class="comment">//------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> max(x, y) (x) &gt; (y)? (x) : (y)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> treenode(T) struct treenode_##T</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Queue(T) typedef struct queuetreenode_##T&#123;\</span></span><br><span class="line"><span class="meta">  void *start;\</span></span><br><span class="line"><span class="meta">  void *end;\</span></span><br><span class="line"><span class="meta">  struct treenode_##T **ptr;\</span></span><br><span class="line"><span class="meta">  int size;\</span></span><br><span class="line"><span class="meta">  void (*push)(struct queuetreenode_##T *queue, treenode_##T *val);\</span></span><br><span class="line"><span class="meta">  void (*pop)(struct queuetreenode_##T *queue);\</span></span><br><span class="line"><span class="meta">  treenode_##T *(*top)(struct queuetreenode_##T *queue);\</span></span><br><span class="line"><span class="meta">&#125;queuetreenode_##T;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> queue(T) queuetreenode_##T</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Push(T) void pushtreenode_##T(queuetreenode_##T *queue, struct treenode_##T *val)&#123;\</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span>((void *) queue-&gt;ptr == queue-&gt;end)&#123;\</span></span><br><span class="line"><span class="meta">    int size = queue-&gt;end - queue-&gt;start;\</span></span><br><span class="line"><span class="meta">    void *newstart = malloc(2 * size);\</span></span><br><span class="line"><span class="meta">    memcpy(newstart, queue-&gt;start, size);\</span></span><br><span class="line"><span class="meta">    free(queue-&gt;start);\</span></span><br><span class="line"><span class="meta">    queue-&gt;start = newstart;\</span></span><br><span class="line"><span class="meta">    queue-&gt;end = queue-&gt;start + 2 * size;\</span></span><br><span class="line"><span class="meta">    queue-&gt;ptr = queue-&gt;start + size;\</span></span><br><span class="line"><span class="meta">  &#125;\</span></span><br><span class="line"><span class="meta">  memcpy(queue-&gt;ptr, &amp;val, sizeof(struct treenode_##T *));\</span></span><br><span class="line"><span class="meta">  queue-&gt;ptr += 1;\</span></span><br><span class="line"><span class="meta">  queue-&gt;size++;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Pop(T) void poptreenode_##T(queuetreenode_##T *queue)&#123;\</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span>((void *) queue-&gt;ptr == queue-&gt;start) return;\</span></span><br><span class="line"><span class="meta">  memmove(queue-&gt;start, queue-&gt;start + sizeof(treenode_##T *), queue-&gt;end - queue-&gt;start - sizeof(treenode_##T *));\</span></span><br><span class="line"><span class="meta">  queue-&gt;ptr -= 1;\</span></span><br><span class="line"><span class="meta">  queue-&gt;size--;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Top(T) treenode_##T *toptreenode_##T(queuetreenode_##T *queue)&#123;\</span></span><br><span class="line"><span class="meta">  treenode_##T *treenode = *((treenode_##T **) queue-&gt;start);\</span></span><br><span class="line"><span class="meta">  return treenode;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NewQueue(T) queuetreenode_##T *newqueuetreenode_##T(int size)&#123;\</span></span><br><span class="line"><span class="meta">  queuetreenode_##T *queue = (queuetreenode_##T *) malloc(sizeof(queuetreenode_##T));\</span></span><br><span class="line"><span class="meta">  queue-&gt;start = malloc(sizeof(treenode_##T *) * size);\</span></span><br><span class="line"><span class="meta">  queue-&gt;end = queue-&gt;start + sizeof(treenode_##T *) * size;\</span></span><br><span class="line"><span class="meta">  queue-&gt;ptr = queue-&gt;start;\</span></span><br><span class="line"><span class="meta">  queue-&gt;push = pushtreenode_##T;\</span></span><br><span class="line"><span class="meta">  queue-&gt;pop = poptreenode_##T;\</span></span><br><span class="line"><span class="meta">  queue-&gt;top = toptreenode_##T;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> newqueue(T) newqueuetreenode_##T</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DeleteQueue(T) void deletequeuetreenode_##T(queuetreenode_##T *queue)&#123;\</span></span><br><span class="line"><span class="meta">  free(queue-&gt;start);\</span></span><br><span class="line"><span class="meta">  free(queue);\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> deletequeue(T) deletequeuetreenode_##T</span></span><br><span class="line"><span class="comment">// 这里的 size 函数是深度优点算法</span></span><br><span class="line"><span class="comment">// 广度优先算法需要借助其他数据结构了</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TreeNode(T) typedef struct treenode_##T&#123;\</span></span><br><span class="line"><span class="meta">  T val;\</span></span><br><span class="line"><span class="meta">  struct treenode_##T *parent;\</span></span><br><span class="line"><span class="meta">  struct treenode_##T *left;\</span></span><br><span class="line"><span class="meta">  struct treenode_##T *right;\</span></span><br><span class="line"><span class="meta">  int height;\</span></span><br><span class="line"><span class="meta">  void (*nodeDFS)(treenode_##T *this, void (*func)(T val));\</span></span><br><span class="line"><span class="meta">  void (*nodeBFS)(treenode_##T *this, void (*func)(T val));\</span></span><br><span class="line"><span class="meta">  void (*insertl)(struct treenode_##T *this, struct treenode_##T *node);\</span></span><br><span class="line"><span class="meta">  void (*insertr)(struct treenode_##T *this, struct treenode_##T *node);\</span></span><br><span class="line"><span class="meta">  int (*isleaf)(struct treenode_##T *this);\</span></span><br><span class="line"><span class="meta">  int (*isroot)(struct treenode_##T *this);\</span></span><br><span class="line"><span class="meta">&#125;treenode_##T;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NodeDFS(T) void nodeDFS_##T(treenode_##T *this, void (*func)(T val))&#123;\</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span>(!this)return;\</span></span><br><span class="line"><span class="meta">  func(this-&gt;val);\</span></span><br><span class="line"><span class="meta">  nodeDFS_##T(this-&gt;left, func);\</span></span><br><span class="line"><span class="meta">  nodeDFS_##T(this-&gt;right, func);\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NodeBFS(T) void nodeBFS_##T(treenode_##T *this, void (*func)(T val))&#123;\</span></span><br><span class="line"><span class="meta">  queue(T) *nodequeue = newqueue(T)(32);\</span></span><br><span class="line"><span class="meta">  nodequeue-&gt;push(nodequeue, this);\</span></span><br><span class="line"><span class="meta">  while(nodequeue-&gt;size)&#123;\</span></span><br><span class="line"><span class="meta">    treenode_##T *node = nodequeue-&gt;top(nodequeue);\</span></span><br><span class="line"><span class="meta">    nodequeue-&gt;pop(nodequeue);\</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span>(!node)continue;\</span></span><br><span class="line"><span class="meta">    func(node-&gt;val);\</span></span><br><span class="line"><span class="meta">    nodequeue-&gt;push(nodequeue, node-&gt;left);\</span></span><br><span class="line"><span class="meta">    nodequeue-&gt;push(nodequeue, node-&gt;right);\</span></span><br><span class="line"><span class="meta">  &#125;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> InsertL(T) void insertl_##T(treenode_##T *this, treenode_##T *node)&#123;\</span></span><br><span class="line"><span class="meta">  this-&gt;left = node;\</span></span><br><span class="line"><span class="meta">  this-&gt;height = (1 + node-&gt;height &gt; this-&gt;height? 1 + node-&gt;height : this-&gt;height);\</span></span><br><span class="line"><span class="meta">  node-&gt;parent = this;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> InsertR(T) void insertr_##T(treenode_##T *this, treenode_##T *node)&#123;\</span></span><br><span class="line"><span class="meta">  this-&gt;right = node;\</span></span><br><span class="line"><span class="meta">  this-&gt;height = (1 + node-&gt;height &gt; this-&gt;height? 1 + node-&gt;height : this-&gt;height);\</span></span><br><span class="line"><span class="meta">  node-&gt;parent = this;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Isleaf(T) int isleaf_##T(treenode_##T *this)&#123;\</span></span><br><span class="line"><span class="meta">  return !this-&gt;right &amp;&amp; !this-&gt;left;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Isroot(T) int isroot_##T(treenode_##T *this)&#123;\</span></span><br><span class="line"><span class="meta">  return !this-&gt;parent;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NewTreeNode(T) treenode_##T *newtreenode_##T(T val)&#123;\</span></span><br><span class="line"><span class="meta">  treenode_##T *node = (treenode_##T *) malloc(sizeof(treenode_##T));\</span></span><br><span class="line"><span class="meta">  node-&gt;val = val;\</span></span><br><span class="line"><span class="meta">  node-&gt;left = NULL;\</span></span><br><span class="line"><span class="meta">  node-&gt;right = NULL;\</span></span><br><span class="line"><span class="meta">  node-&gt;parent = NULL;\</span></span><br><span class="line"><span class="meta">  node-&gt;height = 0;\</span></span><br><span class="line"><span class="meta">  node-&gt;nodeDFS = nodeDFS_##T;\</span></span><br><span class="line"><span class="meta">  node-&gt;nodeBFS = nodeBFS_##T;\</span></span><br><span class="line"><span class="meta">  node-&gt;insertl = insertl_##T;\</span></span><br><span class="line"><span class="meta">  node-&gt;insertr = insertr_##T;\</span></span><br><span class="line"><span class="meta">  node-&gt;isleaf = isleaf_##T;\</span></span><br><span class="line"><span class="meta">  node-&gt;isroot = isroot_##T;\</span></span><br><span class="line"><span class="meta">  return node;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DeleteTreeNode(T) void deletetreenode_##T(treenode_##T *node)&#123;\</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span>(!node)return;\</span></span><br><span class="line"><span class="meta">  deletetreenode_##T(node-&gt;left);\</span></span><br><span class="line"><span class="meta">  deletetreenode_##T(node-&gt;right);\</span></span><br><span class="line"><span class="meta">  free(node);\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> newtreenode newtreenode_##T</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> deletetreenode(T) deletetreenode_##T</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Tree(T) typedef struct tree_##T&#123;\</span></span><br><span class="line"><span class="meta">  treenode_##T *root;\</span></span><br><span class="line"><span class="meta">  int size;\</span></span><br><span class="line"><span class="meta">  int (*compare)(const T a, const T b);\</span></span><br><span class="line"><span class="meta">  int (*isempty)(struct tree_##T *this);\</span></span><br><span class="line"><span class="meta">  treenode_##T *(*getroot)(struct tree_##T *tree);\</span></span><br><span class="line"><span class="meta">  void (*insert)(struct tree_##T *this, T val);\</span></span><br><span class="line"><span class="meta">  int (*heightBFS)(treenode_##T *node);\</span></span><br><span class="line"><span class="meta">  void (*updateheight)(struct tree_##T *this);\</span></span><br><span class="line"><span class="meta">  void (*balanceBFS)(queue(T) *queue, treenode_##T *node);\</span></span><br><span class="line"><span class="meta">  void (*linkBFS)(queue(T) *queue, treenode_##T *node, int left, int right, int mid);\</span></span><br><span class="line"><span class="meta">  void (*balance)(struct tree_##T *this);\</span></span><br><span class="line"><span class="meta">&#125;tree_##T;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> tree(T) tree_##T</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Isempty(T) int isempty_##T(tree_##T *this)&#123;\</span></span><br><span class="line"><span class="meta">  return this-&gt;size == 0;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Getroot(T) treenode_##T *getroot_##T(tree_##T *this)&#123;\</span></span><br><span class="line"><span class="meta">  return this-&gt;root;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HeightBFS(T) int heightBFS_##T(treenode_##T *node)&#123;\</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span>(node == NULL) return 0;\</span></span><br><span class="line"><span class="meta">  int heightleft = heightBFS_##T(node-&gt;left);\</span></span><br><span class="line"><span class="meta">  int heightright = heightBFS_##T(node-&gt;right);\</span></span><br><span class="line"><span class="meta">  node-&gt;height = max(heightleft, heightright) + 1;\</span></span><br><span class="line"><span class="meta">  return node-&gt;height;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Updateheight(T) void updateheight_##T(tree_##T *this)&#123;\</span></span><br><span class="line"><span class="meta">  this-&gt;heightBFS(this-&gt;root);\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Insert(T) void insert_##T(tree_##T *this, T val)&#123;\</span></span><br><span class="line"><span class="meta">  treenode_##T *node = newtreenode_##T(val);\</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span>(!this-&gt;root)&#123;\</span></span><br><span class="line"><span class="meta">    this-&gt;root = node;\</span></span><br><span class="line"><span class="meta">    this-&gt;size++;\</span></span><br><span class="line"><span class="meta">    return;\</span></span><br><span class="line"><span class="meta">  &#125;\</span></span><br><span class="line"><span class="meta">  treenode_##T *iterator = this-&gt;root;\</span></span><br><span class="line"><span class="meta">  while(iterator)&#123;\</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span>(iterator-&gt;val == val)&#123;\</span></span><br><span class="line"><span class="meta">      printf(<span class="string">&quot;this tree has a same val, so can&#x27;t insert\n&quot;</span>);\</span></span><br><span class="line"><span class="meta">      return;\</span></span><br><span class="line"><span class="meta">    &#125;\</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span>(val <span class="string">&lt; iterator-&gt;</span>val)&#123;\</span></span><br><span class="line"><span class="meta">      <span class="keyword">if</span>(!iterator-&gt;left)&#123;\</span></span><br><span class="line"><span class="meta">        iterator-&gt;left = node;\</span></span><br><span class="line"><span class="meta">        break;\</span></span><br><span class="line"><span class="meta">      &#125;\</span></span><br><span class="line"><span class="meta">      iterator = iterator-&gt;left;\</span></span><br><span class="line"><span class="meta">    &#125;\</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span>(val &gt; iterator-&gt;val)&#123;\</span></span><br><span class="line"><span class="meta">      <span class="keyword">if</span>(!iterator-&gt;right)&#123;\</span></span><br><span class="line"><span class="meta">        iterator-&gt;right = node;\</span></span><br><span class="line"><span class="meta">        break;\</span></span><br><span class="line"><span class="meta">      &#125;\</span></span><br><span class="line"><span class="meta">      iterator = iterator-&gt;right;\</span></span><br><span class="line"><span class="meta">    &#125;\</span></span><br><span class="line"><span class="meta">  &#125;\</span></span><br><span class="line"><span class="meta">  this-&gt;balance(this);\</span></span><br><span class="line"><span class="meta">  this-&gt;updateheight(this);\</span></span><br><span class="line"><span class="meta">  this-&gt;size++;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BalanceBFS(T) void balanceBFS_##T(queue(T) *queue, treenode_##T *node)&#123;\</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span>(!node)return;\</span></span><br><span class="line"><span class="meta">  balanceBFS_##T(queue, node-&gt;left);\</span></span><br><span class="line"><span class="meta">  queue-&gt;push(queue, node);\</span></span><br><span class="line"><span class="meta">  balanceBFS_##T(queue, node-&gt;right);\</span></span><br><span class="line"><span class="meta">  node-&gt;parent = NULL;\</span></span><br><span class="line"><span class="meta">  node-&gt;left = NULL;\</span></span><br><span class="line"><span class="meta">  node-&gt;right = NULL;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LinkBFS(T) void linkBFS_##T(queue(T) *queue, treenode_##T *node, int left, int right, int mid)&#123;\</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span>(left &gt;= right) return;\</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span>(left == mid - 1)&#123;\</span></span><br><span class="line"><span class="meta">    node-&gt;left = *((treenode_##T **) queue-&gt;start + left);\</span></span><br><span class="line"><span class="meta">    node-&gt;left-&gt;parent = node;\</span></span><br><span class="line"><span class="meta">  &#125;\</span></span><br><span class="line"><span class="meta">  <span class="keyword">else</span> <span class="keyword">if</span>(left &lt; mid - 1)&#123;\</span></span><br><span class="line"><span class="meta">    int leftmid = (left + mid) &gt;&gt; 1;\</span></span><br><span class="line"><span class="meta">    node-&gt;left = *((treenode_##T **) queue-&gt;start + leftmid);\</span></span><br><span class="line"><span class="meta">    node-&gt;left-&gt;parent = node;\</span></span><br><span class="line"><span class="meta">    linkBFS_##T(queue, node-&gt;left, left, mid - 1, leftmid);\</span></span><br><span class="line"><span class="meta">  &#125;\</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span>(right == mid + 1)&#123;\</span></span><br><span class="line"><span class="meta">    node-&gt;right = *((treenode_##T **) queue-&gt;start + right);\</span></span><br><span class="line"><span class="meta">    node-&gt;right-&gt;parent = node;\</span></span><br><span class="line"><span class="meta">  &#125;\</span></span><br><span class="line"><span class="meta">  <span class="keyword">else</span> <span class="keyword">if</span>(right &gt; mid + 1)&#123;\</span></span><br><span class="line"><span class="meta">    int rightmid = (right + mid) &gt;&gt; 1;\</span></span><br><span class="line"><span class="meta">    node-&gt;right = *((treenode_##T **) queue-&gt;start + rightmid);\</span></span><br><span class="line"><span class="meta">    node-&gt;right-&gt;parent = node;\</span></span><br><span class="line"><span class="meta">    linkBFS_##T(queue, node-&gt;right, mid + 1, right, rightmid);\</span></span><br><span class="line"><span class="meta">  &#125;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Balance(T) void balance_##T(tree_##T *this)&#123;\</span></span><br><span class="line"><span class="meta">  queue(T) *queue = newqueue(T)(this-&gt;root-&gt;height * 2);\</span></span><br><span class="line"><span class="meta">  this-&gt;balanceBFS(queue, this-&gt;root);\</span></span><br><span class="line"><span class="meta">  int size = queue-&gt;size - 1;\</span></span><br><span class="line"><span class="meta">  int mid = size &gt;&gt; 1;\</span></span><br><span class="line"><span class="meta">  this-&gt;root = *((treenode_##T **) queue-&gt;start + mid);\</span></span><br><span class="line"><span class="meta">  this-&gt;linkBFS(queue, this-&gt;root, 0, size, mid);\</span></span><br><span class="line"><span class="meta">  deletequeue(T) (queue);\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NewTree(T) tree_##T *newtree_##T()&#123;\</span></span><br><span class="line"><span class="meta">  tree_##T *tree = (tree_##T *) malloc(sizeof(tree_##T));\</span></span><br><span class="line"><span class="meta">  tree-&gt;root = NULL;\</span></span><br><span class="line"><span class="meta">  tree-&gt;size = 0;\</span></span><br><span class="line"><span class="meta">  tree-&gt;isempty = isempty_##T;\</span></span><br><span class="line"><span class="meta">  tree-&gt;getroot = getroot_##T;\</span></span><br><span class="line"><span class="meta">  tree-&gt;insert = insert_##T;\</span></span><br><span class="line"><span class="meta">  tree-&gt;heightBFS = heightBFS_##T;\</span></span><br><span class="line"><span class="meta">  tree-&gt;updateheight = updateheight_##T;\</span></span><br><span class="line"><span class="meta">  tree-&gt;balanceBFS = balanceBFS_##T;\</span></span><br><span class="line"><span class="meta">  tree-&gt;linkBFS = linkBFS_##T;\</span></span><br><span class="line"><span class="meta">  tree-&gt;balance = balance_##T;\</span></span><br><span class="line"><span class="meta">  return tree;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DeleteTree(T) void deletetree_##T(tree_##T *tree)&#123;\</span></span><br><span class="line"><span class="meta">  deletetreenode_##T(tree-&gt;root);\</span></span><br><span class="line"><span class="meta">  free(tree);\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> newtree(T) newtree_##T</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> deletetree(T) deletetree_##T</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFINETREE(T)  TreeNode(T)\</span></span><br><span class="line"><span class="meta">  Queue(T)\</span></span><br><span class="line"><span class="meta">  Push(T)\</span></span><br><span class="line"><span class="meta">  Pop(T)\</span></span><br><span class="line"><span class="meta">  Top(T)\</span></span><br><span class="line"><span class="meta">  NewQueue(T)\</span></span><br><span class="line"><span class="meta">  DeleteQueue(T)\</span></span><br><span class="line"><span class="meta">  NodeDFS(T)\</span></span><br><span class="line"><span class="meta">  NodeBFS(T)\</span></span><br><span class="line"><span class="meta">  InsertL(T)\</span></span><br><span class="line"><span class="meta">  InsertR(T)\</span></span><br><span class="line"><span class="meta">  Isleaf(T)\</span></span><br><span class="line"><span class="meta">  Isroot(T)\</span></span><br><span class="line"><span class="meta">  NewTreeNode(T)\</span></span><br><span class="line"><span class="meta">  DeleteTreeNode(T)\</span></span><br><span class="line"><span class="meta">  Tree(T)\</span></span><br><span class="line"><span class="meta">  Isempty(T)\</span></span><br><span class="line"><span class="meta">  Getroot(T)\</span></span><br><span class="line"><span class="meta">  HeightBFS(T)\</span></span><br><span class="line"><span class="meta">  Updateheight(T)\</span></span><br><span class="line"><span class="meta">  Insert(T)\</span></span><br><span class="line"><span class="meta">  BalanceBFS(T)\</span></span><br><span class="line"><span class="meta">  LinkBFS(T)\</span></span><br><span class="line"><span class="meta">  Balance(T)\</span></span><br><span class="line"><span class="meta">  NewTree(T)\</span></span><br><span class="line"><span class="meta">  DeleteTree(T)</span></span><br><span class="line"></span><br><span class="line">DEFINETREE(<span class="type">int</span>)</span><br><span class="line">DEFINETREE(<span class="type">char</span>)</span><br><span class="line">DEFINETREE(<span class="type">float</span>)</span><br><span class="line">DEFINETREE(<span class="type">double</span>)</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  tree(<span class="type">int</span>) *tree = newtree(<span class="type">int</span>)();</span><br><span class="line">  tree-&gt;insert(tree, <span class="number">1</span>);</span><br><span class="line">  tree-&gt;insert(tree, <span class="number">1</span>);</span><br><span class="line">  tree-&gt;insert(tree, <span class="number">2</span>);</span><br><span class="line">  tree-&gt;insert(tree, <span class="number">3</span>);</span><br><span class="line">  tree-&gt;insert(tree, <span class="number">-1</span>);</span><br><span class="line">  tree-&gt;insert(tree, <span class="number">-2</span>);</span><br><span class="line">  tree-&gt;root-&gt;nodeDFS(tree-&gt;root);</span><br><span class="line">  tree-&gt;root-&gt;nodeBFS(tree-&gt;root);</span><br><span class="line">  deletetree(<span class="type">int</span>)(tree);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="有根树">有根树</h3>
<p>相当于是一个多节点的树，每个节点都有多个子节点，多叉树，操作系统中的文件结构就类似于一个有根多叉树</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// File Name: k-arytree.c</span></span><br><span class="line"><span class="comment">// Author: Dragon</span></span><br><span class="line"><span class="comment">// mail: [beloved25177@126.com](mailto:beloved25177@126.com)</span></span><br><span class="line"><span class="comment">// Created Time: Thu 05 Oct 2023 11:35:22 CST</span></span><br><span class="line"><span class="comment">// Description: 有根树</span></span><br><span class="line"><span class="comment">//------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> treenode(T) struct treenode_##T</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Queue(T) typedef struct queuetreenode_##T&#123;\</span></span><br><span class="line"><span class="meta">  void *start;\</span></span><br><span class="line"><span class="meta">  void *end;\</span></span><br><span class="line"><span class="meta">  struct treenode_##T **ptr;\</span></span><br><span class="line"><span class="meta">  int size;\</span></span><br><span class="line"><span class="meta">  void (*push)(struct queuetreenode_##T *queue, treenode_##T *val);\</span></span><br><span class="line"><span class="meta">  void (*pop)(struct queuetreenode_##T *queue);\</span></span><br><span class="line"><span class="meta">  void (*merge)(struct queuetreenode_##T *dst, struct queuetreenode_##T *src, int dstbegin, int srcbegin, int srcend);\</span></span><br><span class="line"><span class="meta">  treenode_##T *(*top)(struct queuetreenode_##T *queue);\</span></span><br><span class="line"><span class="meta">&#125;queuetreenode_##T;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> queue(T) queuetreenode_##T</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Push(T) void pushtreenode_##T(queuetreenode_##T *queue, struct treenode_##T *val)&#123;\</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span>((void *) queue-&gt;ptr == queue-&gt;end)&#123;\</span></span><br><span class="line"><span class="meta">    int size = queue-&gt;end - queue-&gt;start;\</span></span><br><span class="line"><span class="meta">    void *newstart = malloc(2 * size);\</span></span><br><span class="line"><span class="meta">    memcpy(newstart, queue-&gt;start, size);\</span></span><br><span class="line"><span class="meta">    free(queue-&gt;start);\</span></span><br><span class="line"><span class="meta">    queue-&gt;start = newstart;\</span></span><br><span class="line"><span class="meta">    queue-&gt;end = queue-&gt;start + 2 * size;\</span></span><br><span class="line"><span class="meta">    queue-&gt;ptr = queue-&gt;start + size;\</span></span><br><span class="line"><span class="meta">  &#125;\</span></span><br><span class="line"><span class="meta">  memcpy(queue-&gt;ptr, &amp;val, sizeof(struct treenode_##T *));\</span></span><br><span class="line"><span class="meta">  queue-&gt;ptr += 1;\</span></span><br><span class="line"><span class="meta">  queue-&gt;size++;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Pop(T) void poptreenode_##T(queuetreenode_##T *queue)&#123;\</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span>((void *) queue-&gt;ptr == queue-&gt;start) return;\</span></span><br><span class="line"><span class="meta">  memmove(queue-&gt;start, queue-&gt;start + sizeof(treenode_##T *), queue-&gt;end - queue-&gt;start - sizeof(treenode_##T *));\</span></span><br><span class="line"><span class="meta">  queue-&gt;ptr -= 1;\</span></span><br><span class="line"><span class="meta">  queue-&gt;size--;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Top(T) treenode_##T *toptreenode_##T(queuetreenode_##T *queue)&#123;\</span></span><br><span class="line"><span class="meta">  treenode_##T *node = *((treenode_##T **) queue-&gt;start);\</span></span><br><span class="line"><span class="meta">  return node;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Merge(T) void merge_##T(queuetreenode_##T *dst, queuetreenode_##T *src, int dstbegin, int srcbegin, int srcen)&#123;\</span></span><br><span class="line"><span class="meta">  int srcsize = src-&gt;ptr - (treenode_##T * *) src-&gt;start;\</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span>(srcbegin &gt;= srcsize)&#123;\</span></span><br><span class="line"><span class="meta">    printf(<span class="string">&quot;begin index has out of range&quot;</span>);\</span></span><br><span class="line"><span class="meta">    return;\</span></span><br><span class="line"><span class="meta">  &#125;\</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span>(srcend * sizeof(treenode_##T *) &gt; srcsize)&#123;\</span></span><br><span class="line"><span class="meta">    printf(<span class="string">&quot;end index has out of range&quot;</span>);\</span></span><br><span class="line"><span class="meta">    return;\</span></span><br><span class="line"><span class="meta">  &#125;\</span></span><br><span class="line"><span class="meta">  int dstmaxsize = dst-&gt;end - dst-&gt;start;\</span></span><br><span class="line"><span class="meta">  int dstsize = (void *) dst-&gt;ptr - dst-&gt;start;\</span></span><br><span class="line"><span class="meta">  while(dstmaxsize &lt; dstsize + (srcend - srcbegin) * sizeof(treenode_##T *))\</span></span><br><span class="line"><span class="meta">    dstmaxsize &lt;&lt; 2;\</span></span><br><span class="line"><span class="meta">  void *newstart = malloc(dstmaxsize);\</span></span><br><span class="line"><span class="meta">  memcpy(newstart, dst-&gt;start, dstbegin * sizeof(treenode_##T *));\</span></span><br><span class="line"><span class="meta">  memcpy(newstart + dstbegin * sizeof(treenode_##T *), src-&gt;start + srcbegin * sizeof(treenode_##T *), (srcend - srcbegin) * sizeof(treenode_##T *));\</span></span><br><span class="line"><span class="meta">  memcpy(newstart + dstbegin * sizeof(treenode_##T *) + srcsize, dst-&gt;start + dstbegin * sizeof(treenode_##T *), (void *) dst-&gt;ptr - dst-&gt;start - dstbegin * sizeof(treenode_##T *));\</span></span><br><span class="line"><span class="meta">  free(dst-&gt;start);\</span></span><br><span class="line"><span class="meta">  dst-&gt;start = newstart;\</span></span><br><span class="line"><span class="meta">  dst-&gt;end = newstart + dstmaxsize;\</span></span><br><span class="line"><span class="meta">  dst-&gt;ptr = newstart + dstsize + (srcend - srcbegin) * sizeof(treenode_##T *);\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NewQueue(T) queuetreenode_##T *newqueuetreenode_##T(int size)&#123;\</span></span><br><span class="line"><span class="meta">  queuetreenode_##T *queue = (queuetreenode_##T *) malloc(sizeof(queuetreenode_##T));\</span></span><br><span class="line"><span class="meta">  queue-&gt;start = malloc(sizeof(treenode_##T *) * size);\</span></span><br><span class="line"><span class="meta">  queue-&gt;end = queue-&gt;start + sizeof(treenode_##T *) * size;\</span></span><br><span class="line"><span class="meta">  queue-&gt;ptr = queue-&gt;start;\</span></span><br><span class="line"><span class="meta">  queue-&gt;push = pushtreenode_##T;\</span></span><br><span class="line"><span class="meta">  queue-&gt;pop = poptreenode_##T;\</span></span><br><span class="line"><span class="meta">  queue-&gt;top = toptreenode_##T;\</span></span><br><span class="line"><span class="meta">  queue-&gt;merge = merge_##T;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> newqueue(T) newqueuetreenode_##T</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DeleteQueue(T) void deletequeuetreenode_##T(queuetreenode_##T *queue)&#123;\</span></span><br><span class="line"><span class="meta">  free(queue-&gt;start);\</span></span><br><span class="line"><span class="meta">  free(queue);\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> deletequeue(T) deletequeuetreenode_##T</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TreeNode(T) typedef struct treenode_##T&#123;\</span></span><br><span class="line"><span class="meta">  treenode_##T *parent;\</span></span><br><span class="line"><span class="meta">  queuetreenode_##T *children;\</span></span><br><span class="line"><span class="meta">  T val;\</span></span><br><span class="line"><span class="meta">  void (*insert)(treenode_##T *this, treenode_##T *node);\</span></span><br><span class="line"><span class="meta">  void (*dfs)(treenode_##T *this, void (*func)(treenode_##T *node));\</span></span><br><span class="line"><span class="meta">  void (*bfs)(treenode_##T *this, void (*func)(treenode_##T *node));\</span></span><br><span class="line"><span class="meta">  int (*isleaf)(struct treenode_##T *this);\</span></span><br><span class="line"><span class="meta">  int (*isroot)(struct treenode_##T *this);\</span></span><br><span class="line"><span class="meta">&#125;treenode_##T;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NodeInsert(T) void nodeinsert_##T(treenode_##T *this, void (*func)(treenode_##T *node))&#123;\</span></span><br><span class="line"><span class="meta">  children-&gt;push(node);\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NodeDFS(T) void nodedfs_##T(treenode_##T *this, void (*func)(treenode_##T *node))&#123;\</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span>(!this)return;\</span></span><br><span class="line"><span class="meta">  func(this);\</span></span><br><span class="line"><span class="meta">  nodedfs_##T(this-&gt;left, func);\</span></span><br><span class="line"><span class="meta">  nodedfs_##T(this-&gt;right, func);\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NodeBFS(T) void nodebfs_##T(treenode_##T *this, void (*func)(treenode_##T *node))&#123;\</span></span><br><span class="line"><span class="meta">  queue(T) *nodequeue = newqueue(T)(32);\</span></span><br><span class="line"><span class="meta">  nodequeue-&gt;push(this);\</span></span><br><span class="line"><span class="meta">  while(nodequeue-&gt;size)&#123;\</span></span><br><span class="line"><span class="meta">    treenode_##T *node = nodequeue-&gt;top(nodequeue);\</span></span><br><span class="line"><span class="meta">    nodequeue-&gt;pop(nodequeue);\</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span>(!node)continue;\</span></span><br><span class="line"><span class="meta">    func(node);\</span></span><br><span class="line"><span class="meta">    nodequeue-&gt;merge(nodequeue, this-&gt;children, nodequeue-&gt;ptr - (treenode_##T **) node-&gt;start, 0, this-&gt;children-&gt;ptr - (treenode_##T **) this-&gt;children-&gt;start);\</span></span><br><span class="line"><span class="meta">  &#125;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IsLeaf(T) int isleaf_##T(treenode_##T *this)&#123;\</span></span><br><span class="line"><span class="meta">  return this-&gt;children-&gt;ptr == this-&gt;children-&gt;start;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IsRoot(T) int isroot_##T(treenode_##T *this)&#123;\</span></span><br><span class="line"><span class="meta">  return !this-&gt;parent;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NewTreeNode(T) treenode_##T *newtreenode_##T(T val)&#123;\</span></span><br><span class="line"><span class="meta">  treenode_##T *node = (treenode_##T *) malloc(sizeof(treenode_##T));\</span></span><br><span class="line"><span class="meta">  node-&gt;val = val;\</span></span><br><span class="line"><span class="meta">  node-&gt;parent = NULL;\</span></span><br><span class="line"><span class="meta">  node-&gt;children = newqueue();\</span></span><br><span class="line"><span class="meta">  node-&gt;insert = NodeInsert(T);\</span></span><br><span class="line"><span class="meta">  node-&gt;bfs = NodeBFS(T);\</span></span><br><span class="line"><span class="meta">  node-&gt;dfs = NodeDFS(T);\</span></span><br><span class="line"><span class="meta">  node-&gt;isleaf = IsLeaf(T);\</span></span><br><span class="line"><span class="meta">  node-&gt;isroot = IsRoot(T);\</span></span><br><span class="line"><span class="meta">  return node;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DeleteTreeNode(T) void deletetreenode_##T(treenode_##T *this)&#123;\</span></span><br><span class="line"><span class="meta">  this-&gt;dfs(this, free);\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> newtreenode(T) newtreenode_##T</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> deletetreenode(T) deletetreenode_##T</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Tree(T) typedef struct tree_##T&#123;\</span></span><br><span class="line"><span class="meta">  treenode_##T *root;\</span></span><br><span class="line"><span class="meta">  int size;\</span></span><br><span class="line"><span class="meta">&#125;tree_##T;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> tree(T) tree_##T</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NewTree(T) tree_##T *newtree_##T()&#123;\</span></span><br><span class="line"><span class="meta">  tree_##T *tree = (tree_##T *) malloc(sizeof(tree_##T));\</span></span><br><span class="line"><span class="meta">  tree-&gt;root = NULL;\</span></span><br><span class="line"><span class="meta">  tree-&gt;size = 0;\</span></span><br><span class="line"><span class="meta">  return tree;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DeleteTree(T) tree_##T *deletetree_##T(tree_##T *this)&#123;\</span></span><br><span class="line"><span class="meta">  deletetreenode(T)(this-&gt;root);\</span></span><br><span class="line"><span class="meta">  free(this);\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFINETREE(T) TreeNode(T)\</span></span><br><span class="line"><span class="meta">  Queue(T)\</span></span><br><span class="line"><span class="meta">  Push(T)\</span></span><br><span class="line"><span class="meta">  Pop(T)\</span></span><br><span class="line"><span class="meta">  Top(T)\</span></span><br><span class="line"><span class="meta">  NewQueue(T)\</span></span><br><span class="line"><span class="meta">  DeleteQueue(T)\</span></span><br><span class="line"><span class="meta">  NodeInsert(T)\</span></span><br><span class="line"><span class="meta">  NodeDFS(T)\</span></span><br><span class="line"><span class="meta">  NodeBFS(T)\</span></span><br><span class="line"><span class="meta">  IsLeaf(T)\</span></span><br><span class="line"><span class="meta">  IsRoot(T)\</span></span><br><span class="line"><span class="meta">  NewTreeNode(T)\</span></span><br><span class="line"><span class="meta">  DeleteTreeNode(T)\</span></span><br><span class="line"><span class="meta">  Tree(T)\</span></span><br><span class="line"><span class="meta">  NewTree(T)\</span></span><br><span class="line"><span class="meta">  DeleteTree(T)</span></span><br></pre></td></tr></table></figure>
<h2 id="矩阵">矩阵</h2>
<p>矩阵实际上就是一个结构体内部有着一个二维数组，并且对这个二维数组进行维护，进行加减乘等运算，还有转置和逆运算</p>
<p><img src="/Blog_NexT/2024/03/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/matrix.png" alt="matrix"></p>
<h2 id="图">图</h2>
<p>图结构是描述和解决实际应用问题的一种基本而有力的工具，可以定义为 <code>G=(V, E)</code> ，其中 <code>V</code> 中的元素称作顶点，集合 <code>E</code> 中的元素对应着 <code>V</code> 中的某一对顶点的边</p>
<p>对于任何边 <code>e = (u, v)</code> ，称顶点u和v彼此邻接（adjacent），互为邻居；而它们都与边 <code>e</code> 彼此关联（incident），在无向图中，与顶点v关联的边数，称作v的度数（degree），记作 <code>deg(v)</code></p>
<p><img src="/Blog_NexT/2024/03/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/map.png" alt="map"></p>
<h3 id="无向图">无向图</h3>
<p>对于上述中的 <code>E</code> 集合中的边是没有方向的，或者说是双向的。</p>
<h3 id="有向图">有向图</h3>
<p>对于上述中的 <code>E</code> 集合中的边是有方向的的</p>
<h3 id="混合图">混合图</h3>
<p>对于上述中的 <code>E</code> 集合中的边是有方向和无方向的混合的</p>
<h3 id="简单图">简单图</h3>
<p>联接于同一顶点之间的边，称作自环（self-loop）</p>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>落
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://luo25177.github.io/2024/03/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="数据结构">https://luo25177.github.io/2024/03/19/数据结构/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/Blog_NexT/tags/C/" rel="tag"># C</a>
              <a href="/Blog_NexT/tags/Cpp/" rel="tag"># Cpp</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/Blog_NexT/2024/03/19/C-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" rel="prev" title="C++内存管理">
      <i class="fa fa-chevron-left"></i> C++内存管理
    </a></div>
      <div class="post-nav-item">
    <a href="/Blog_NexT/2024/03/20/%E7%AE%97%E6%B3%95/" rel="next" title="算法">
      算法 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8"><span class="nav-number">1.</span> <span class="nav-text">链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8"><span class="nav-number">1.1.</span> <span class="nav-text">单向链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8"><span class="nav-number">1.2.</span> <span class="nav-text">双向循环链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B7%B3%E8%A1%A8"><span class="nav-number">1.3.</span> <span class="nav-text">跳表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E7%BB%84"><span class="nav-number">2.</span> <span class="nav-text">数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%98%9F%E5%88%97"><span class="nav-number">3.</span> <span class="nav-text">队列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97"><span class="nav-number">3.1.</span> <span class="nav-text">循环队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E5%85%88%E5%8F%AF%E6%89%A9%E5%85%85%E9%98%9F%E5%88%97"><span class="nav-number">3.2.</span> <span class="nav-text">优先可扩充队列</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%91%E9%87%8F"><span class="nav-number">4.</span> <span class="nav-text">向量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%88"><span class="nav-number">5.</span> <span class="nav-text">栈</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%91"><span class="nav-number">6.</span> <span class="nav-text">树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">6.1.</span> <span class="nav-text">二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">6.2.</span> <span class="nav-text">平衡二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%89%E6%A0%B9%E6%A0%91"><span class="nav-number">6.3.</span> <span class="nav-text">有根树</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9F%A9%E9%98%B5"><span class="nav-number">7.</span> <span class="nav-text">矩阵</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%BE"><span class="nav-number">8.</span> <span class="nav-text">图</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A0%E5%90%91%E5%9B%BE"><span class="nav-number">8.1.</span> <span class="nav-text">无向图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%89%E5%90%91%E5%9B%BE"><span class="nav-number">8.2.</span> <span class="nav-text">有向图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%B7%E5%90%88%E5%9B%BE"><span class="nav-number">8.3.</span> <span class="nav-text">混合图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E5%9B%BE"><span class="nav-number">8.4.</span> <span class="nav-text">简单图</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="落"
      src="/Blog_NexT/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">落</p>
  <div class="site-description" itemprop="description">茶凉言尽，月上柳梢</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/Blog_NexT/archives/">
        
          <span class="site-state-item-count">109</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/Blog_NexT/categories/">
          
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/Blog_NexT/tags/">
          
        <span class="site-state-item-count">98</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Luo25177" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Luo25177" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:beloved25177@126.com" title="E-Mail → mailto:beloved25177@126.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2024 – 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">落</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">1.5m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">22:41</span>
  <img src="https://gcore.jsdelivr.net/gh/CNhuazhu/TuChuang4/blog/备案图标.png">
  <a href="http://www.beian.miit.gov.cn/" target="_blank">豫ICP备2024056598号-1</a>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/Blog_NexT/lib/anime.min.js"></script>
  <script src="/Blog_NexT/lib/velocity/velocity.min.js"></script>
  <script src="/Blog_NexT/lib/velocity/velocity.ui.min.js"></script>

<script src="/Blog_NexT/js/utils.js"></script>

<script src="/Blog_NexT/js/motion.js"></script>


<script src="/Blog_NexT/js/schemes/pisces.js"></script>


<script src="/Blog_NexT/js/next-boot.js"></script>




  




  
<script src="/Blog_NexT/js/local-search.js"></script>













  

  
      
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex@0/dist/katex.min.css">
  <script src="//cdn.jsdelivr.net/npm/katex@0/dist/contrib/copy-tex.min.js"></script>
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex@0/dist/contrib/copy-tex.min.css">


  

</body>
</html>
