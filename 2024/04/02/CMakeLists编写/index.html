<!DOCTYPE html>
<html lang="zh-CN">
<script src="/Blog_NexT/js/snow.js"></script>
<script src="/Blog_NexT/js/forbiden.js"></script>
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.1.1">
  <link rel="icon" type="image/png" sizes="32x32" href="/Blog_NexT/images/logo4.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/Blog_NexT/images/logo4.png">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">

<link rel="stylesheet" href="/Blog_NexT/css/main.css">


<link rel="stylesheet" href="/Blog_NexT/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"luo25177.github.io","root":"/Blog_NexT/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="CMakeLists编写">
<meta property="og:type" content="article">
<meta property="og:title" content="CMakeLists编写">
<meta property="og:url" content="https://luo25177.github.io/2024/04/02/CMakeLists%E7%BC%96%E5%86%99/index.html">
<meta property="og:site_name" content="LuosBlog">
<meta property="og:description" content="CMakeLists编写">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-04-02T13:30:22.000Z">
<meta property="article:modified_time" content="2025-09-29T17:05:18.776Z">
<meta property="article:author" content="落">
<meta property="article:tag" content="Cpp">
<meta property="article:tag" content="C">
<meta property="article:tag" content="cmake">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://luo25177.github.io/2024/04/02/CMakeLists%E7%BC%96%E5%86%99/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>CMakeLists编写 | LuosBlog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/Blog_NexT/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">LuosBlog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/Blog_NexT/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-引导">

    <a href="/Blog_NexT/../" rel="section"><i class="fas fa-heart fa-fw"></i>引导</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/Blog_NexT/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/Blog_NexT/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/Blog_NexT/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-友链">

    <a href="/Blog_NexT/links/" rel="section"><i class="fa fa-link fa-fw"></i>友链</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://luo25177.github.io/2024/04/02/CMakeLists%E7%BC%96%E5%86%99/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/Blog_NexT/images/avatar.png">
      <meta itemprop="name" content="落">
      <meta itemprop="description" content="茶凉言尽，月上柳梢">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuosBlog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          CMakeLists编写
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-02 21:30:22" itemprop="dateCreated datePublished" datetime="2024-04-02T21:30:22+08:00">2024-04-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-09-30 01:05:18" itemprop="dateModified" datetime="2025-09-30T01:05:18+08:00">2025-09-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/Blog_NexT/categories/%E5%B0%8F%E5%B7%A5%E5%85%B7/" itemprop="url" rel="index"><span itemprop="name">小工具</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>18k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>16 分钟</span>
            </span>
            <div class="post-description">CMakeLists编写</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="前言">前言</h2>
<p>CMake是一个跨平台的构建系统，能自动生成各种平台和编译器的构建文件，相对于直接编写 <code>makefile</code> 文件，编写 <code>CMakeLists</code> 文件不需要考虑太多的文件之间的依赖关系，它可以自动帮你管理复杂项目的构建过程，检测依赖关系，生成目标文件，编译静态库和动态库等，减少手动管理的负担</p>
<p>可以看看这个知乎专题 <a target="_blank" rel="noopener" href="https://www.zhihu.com/column/c_1369781372333240320">CMake实践应用专题 - 知乎 (zhihu.com)</a> ，下面的内容几乎都是从这里整理的</p>
<h3 id="ubuntu-上-cmake-的更新">ubuntu 上 cmake 的更新</h3>
<p>在使用旧版本的 ubuntu 时，总是会出现 cmake 的版本太低，导致编译不通过，所以需要更新 cmake，一般使用 <code>apt</code> 指令直接安装的 cmake 版本都比较低。所以可以在<a target="_blank" rel="noopener" href="https://cmake.org/">官网</a>上下载源代码编译安装，最后检验安装的版本正确即可</p>
<ol>
<li>安装依赖<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install libssl-dev</span><br></pre></td></tr></table></figure>
</li>
<li>下载压缩包并且解压</li>
<li>编译安装<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir build &amp;&amp; cd build</span><br><span class="line">../config</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>
</li>
<li>动态库链接<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ldconfig</span><br></pre></td></tr></table></figure>
</li>
<li>检验<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake --version</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="cmake-一般使用流程">CMake 一般使用流程</h2>
<h3 id="生成构建系统">生成构建系统</h3>
<p>通过 <code>cmake</code> 指令生成构建系统，可以在命令行中输入 <code>cmake --help</code> 来看到 <code>cmake</code> 指令支持的详细参数，常用参数如下</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>-S</td>
<td>指定源文件根目录，该目录下必须包含 CMakeLists.txt 文件</td>
</tr>
<tr>
<td>-B</td>
<td>指定构建目录，构建生成的中间文件和目标文件的生成路径</td>
</tr>
<tr>
<td>-D</td>
<td>指定变量，格式为 -D <var> = <value>， -D 后的空格可省</value></var></td>
</tr>
</tbody>
</table>
<p>例如，使用当前目录为源文件目录，其中包含 <code>CMakeLists.txt</code> 文件，使用 <code>build</code> 目录作为构建目录，设定变量 <code>CMAKE_BUILD_TYPE</code> 为 <code>Debug</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake -S . -B build -DCMAKE_BUILD_TYPE=Debug</span><br></pre></td></tr></table></figure>
<h3 id="执行构建">执行构建</h3>
<p>使用 <code>cmake --build [&lt;dir&gt; | --preset &lt;preset&gt;]</code> 进行构建</p>
<p>这里指定的目录就是生成构建系统时的指定的构建目录，常用的一些参数</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>—target</td>
<td>指定构建目标代替默认的构建目标，可以指定多个</td>
</tr>
<tr>
<td>—parallel / -j[<jobs>]</jobs></td>
<td>指定构建目标时使用的进程数</td>
</tr>
</tbody>
</table>
<h3 id="执行测试-安装或打包">执行测试，安装或打包</h3>
<p>安装打包的内容可以看后面</p>
<p>测试主要是使用的 <code>gtest</code> 库，所以可以看看我的 <code>gtest</code> 使用的文章</p>
<h2 id="cmake基础语法">CMake基础语法</h2>
<h3 id="注释">注释</h3>
<p>使用 <code>#</code> 开头的行是注释行，会被忽略，块注释为 <code>#[[ ... ]]</code></p>
<h3 id="普通变量">普通变量</h3>
<p>使用 <code>set</code> 指令来<strong>定义变量</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set(VALUE_NAME value)</span><br></pre></td></tr></table></figure>
<p>使用 <code>$</code> 来读取变量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;VALUE_NAME&#125;</span><br></pre></td></tr></table></figure>
<p>使用 <code>unset</code> 来取消设置变量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unset(VALUE_NAME)</span><br></pre></td></tr></table></figure>
<ol>
<li>如果要设置的变量值包含空格，需要使用双引号把整个或者 <code>\</code> 转义</li>
<li>如果设置多个值或者字符串值的中间有 <code>;</code> ，则保存成 <code>list</code></li>
<li>变量可以被 <code>list</code> 命令操作，单个值的变量相当于只有一个元素的列表</li>
<li>在<code>if()</code>条件判断中可以简化为只用变量名</li>
</ol>
<h3 id="cache变量">Cache变量</h3>
<p>作用是为了提供用户配置选项，若未指定则使用默认值，使用如下方法设置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set(&lt;variable&gt; &lt;value&gt;... CACHE &lt;type&gt; &lt;docstring&gt; [FORCE])</span><br></pre></td></tr></table></figure>
<p>使用 <code>$CACHE</code> 引用变量， <code>CACHE</code> 变量会被保存在构建目录下的 <code>CMakeCache.txt</code> 中，缓存之后是不变的的，除非重新配置</p>
<h3 id="环境变量">环境变量</h3>
<p>修改当前处理进程的环境变量，设置格式如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set(ENV&#123;&lt;variable&gt;&#125; [&lt;value&gt;])</span><br></pre></td></tr></table></figure>
<p>可以使用 <code>$ENV</code> 来引用环境变量</p>
<h3 id="条件语句">条件语句</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if(CONDITION1)</span><br><span class="line">	...</span><br><span class="line">elseif(CONDITION2)</span><br><span class="line">	...</span><br><span class="line">else()</span><br><span class="line">	...</span><br><span class="line">endif()</span><br></pre></td></tr></table></figure>
<p>用于比较的语法</p>
<ol>
<li>字符串： <code>STREQUAL</code> ， <code>STRLESS</code> ， <code>STRGREATER</code></li>
<li>数值比较： <code>EQUAL</code> ， <code>LESS</code> ， <code>GREATER</code></li>
<li>布尔运算： <code>AND</code> ， <code>OR</code> ， <code>NOT</code></li>
<li>路径判断： <code>EXISTS</code> ， <code>IS_DIRECTORY</code> <strong>，</strong> <code>IS_ABSOLUTE</code></li>
<li>多个条件语句组合： <code>(cond1) AND (cond2 OR (cond3))</code></li>
<li>常量： <code>ON</code> ， <code>YES</code> ， <code>TRUE</code> ， <code>Y</code> 和非 0 值被视为 <code>True</code> ，对于 <code>0</code> ， <code>OFF</code> ， <code>NO</code> ， <code>FALSE</code> ， <code>N</code> ， <code>IGNORE</code> ，空字符串， <code>NOTFOUND</code> ，以及以 <code>-NOTFOUND</code> 结尾的字符串都被视为 <code>False</code></li>
</ol>
<h3 id="循环语句">循环语句</h3>
<p>类似于 <code>python</code> 中的循环语句的定义</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foreach(item IN LISTS items)</span><br><span class="line">	...</span><br><span class="line">endforeach()</span><br></pre></td></tr></table></figure>
<h3 id="函数">函数</h3>
<p>可以自定义自己的函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function(FUNCTION_NAME arg1 arg2)</span><br><span class="line">	...</span><br><span class="line">endfunction()</span><br></pre></td></tr></table></figure>
<h3 id="宏">宏</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">macro(MACRO_NAME arg1 arg2)</span><br><span class="line">	...</span><br><span class="line">endmacro()</span><br></pre></td></tr></table></figure>
<h3 id="消息打印">消息打印</h3>
<p>利用 <code>message</code> 指令来把信息打印出来，如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">message([&lt;mode&gt;] &quot;message text&quot; ... )</span><br></pre></td></tr></table></figure>
<p>其中 <code>mode</code> 的选值如下</p>
<ol>
<li>空或者是 <code>NOTICE</code> ：比较重要的信息</li>
<li><code>DEBUG</code> ：调试信息</li>
<li><code>STATUS</code> ：状态信息</li>
<li><code>WARNING</code> ： <code>cmake</code> 警告，不会打断进程</li>
<li><code>SEND_ERROR</code> ： <code>cmake</code> 错误，会继续执行，但是跳过生成构建系统</li>
<li><code>FATAL_ERROR</code> ： <code>cmake</code> 致命错误，会终止进程</li>
</ol>
<h3 id="列表操作">列表操作</h3>
<p>设置多个值或者字符串值的中间有 <code>;</code> ，则保存成 <code>list</code> ， <code>list</code> 存在于 <code>cmake</code> 中，有很多子命令</p>
<ol>
<li><code>APPEND</code> 向列表中添加元素</li>
<li><code>LENGTH</code> 获取列表中元素的个数</li>
<li><code>JOIN</code> 将列表元素用指定的分隔符连接起来</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">set(LIST A B)</span><br><span class="line">set(LIST A;B)</span><br><span class="line">set(LIST &quot;A;B&quot;)</span><br><span class="line">list(APPEND LIST &quot;C&quot;)</span><br><span class="line">list(LENGTH LIST LIST_LEN)</span><br><span class="line">list(JOIN LIST &quot;,&quot; LIST_SPLIT)</span><br></pre></td></tr></table></figure>
<h3 id="文件操作">文件操作</h3>
<p><code>cmake</code> 的 <code>file</code> 命令支持的操作比较多，可以读写，创建或复制文件和目录，计算文件hash，下载文件，压缩文件等，例如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file(GLOB_RECURSE ALLSRC src/*.c)</span><br></pre></td></tr></table></figure>
<p>其中 <code>GLOB_RECURSE</code> 表示执行递归查找，查找目录下的所有符合指定的正则表达式的文件</p>
<h3 id="执行系统命令">执行系统命令</h3>
<p>使用 <code>execute_process</code> 指令可以执行一条或者顺序执行多条系统命令</p>
<p><code>execute_process(COMMAND bash &quot;-c&quot; &quot;git rev-parse --short HEAD&quot; OUTPUT_VARIABLE COMMIT_ID)</code></p>
<p>上述是获取当前仓库最新提交的 <code>commit</code> 的 <code>commit id</code></p>
<h3 id="设置项目和版本">设置项目和版本</h3>
<p>如果需要在项目中<strong>标明版本号、Git的hash号、编译时间</strong>等信息，可以利用 <code>configure_file</code> 来实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">configure_file(&lt;input&gt; &lt;output&gt;</span><br><span class="line">               [COPYONLY] [ESCAPE_QUOTES] [@ONLY]</span><br><span class="line">               [NEWLINE_STYLE [UNIX|DOS|WIN32|LF|CRLF] ])</span><br></pre></td></tr></table></figure>
<p>其中</p>
<ul>
<li><code>input</code> 输入文件，一般是以 <code>.h.in</code> 为后缀</li>
<li><code>output</code> 输出文件，一般是 <code>.h</code> 后缀</li>
<li><code>COPYONLY</code> 只拷贝文件，不进行任何变量替换，与 <code>NEWLINE_STYLE</code> 冲突（指定 <code>NEWLINE_STYLE</code> 之后无效）</li>
<li><code>ESCAPE_QUOTES</code> 避开所有反斜杠的转义</li>
<li><code>@ONLY</code> 限制变量替换，让其只替换被 <code>@VAR@</code> 引用的变量（那么 <code>$&#123;VAR&#125;</code> 格式的变量将不会被替换）。这在配置<code>$&#123;VAR&#125;</code>语法的脚本时是非常有用的</li>
<li><code>NEWLINE_STYLE</code> 指定输出文件中的新行格式。 <code>UNIX</code> 和 <code>LF</code> 的新行是 <code>\n</code>， <code>DOS</code> 和 <code>WIN32</code> 和 <code>CRLF</code> 的新行格式是 <code>\r\n</code>。这个选项在指定了 <code>COPYONLY</code> 选项时不能使用(无效)</li>
</ul>
<p>在 <code>cmake</code> 教程中对它的解释是将一个文件复制到另一个位置并且修改其内容，这里的修改并非是随意修改，而是**将input文件复制到output文件，并在输入文件内容中的变量，替换引用为@VAR@或${VAR}的变量值。每个变量引用将替换为该变量的当前值，如果未定义该变量，则为空字符串，**如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">set(BUILD_Version 1)</span><br><span class="line"></span><br><span class="line">// input file</span><br><span class="line">#define BUILD_Version @BUILD_Version@</span><br><span class="line"></span><br><span class="line">// output file</span><br><span class="line">#define BUILD_Version 1</span><br></pre></td></tr></table></figure>
<p>在 <code>CMakeLists.txt</code> 文件中使用 <code>project</code> 指令可以指定版本号</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">project(ProjectName VERSION 1.0.0 LANGUAGES C CXX)</span><br></pre></td></tr></table></figure>
<p>其中第一个参数为项目名称，并且可以通过 <code>VERSION</code> 指定版本号，格式为 <code>major.minor.patch.tweak</code> 并且 <code>cmake</code> 会将对应的值分别赋给以下变量，如果没有将会是空字符串</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PROJECT_VERSION, &lt;PROJECT-NAME&gt;_VERSION</span><br><span class="line">PROJECT_VERSION_MAJOR, &lt;PROJECT-NAME&gt;_VERSION_MAJOR</span><br><span class="line">PROJECT_VERSION_MINOR, &lt;PROJECT-NAME&gt;_VERSION_MINOR</span><br><span class="line">PROJECT_VERSION_PATCH, &lt;PROJECT-NAME&gt;_VERSION_PATCH</span><br><span class="line">PROJECT_VERSION_TWEAK, &lt;PROJECT-NAME&gt;_VERSION_TWEAK</span><br></pre></td></tr></table></figure>
<p>利用上述的 <code>configure_file</code> 命令可以配置自动生成版本头文件，将头文件版本号定义成对应的宏，或者定义为接口，便于了解当前版本</p>
<h3 id="指定编程语言版本">指定编程语言版本</h3>
<p>可以使得在不同的机器上都能够有统一的编译，可以指定语言版本</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set(CMAKE_C_STANDARD 99)</span><br><span class="line">set(CMAKE_CXX_STANDARD 11)</span><br></pre></td></tr></table></figure>
<p><code>CMAKE_</code> ， <code>_CMAKE</code> 或者是下划线开头后面加上任意 <code>cmake</code> 命令的变量名都是 <code>cmake</code> 保留的，都是 <code>cmake</code> 的内置变量，可以通过修改这些变量的值来配置 <code>cmake</code> 的构建</p>
<h3 id="配置编译选项">配置编译选项</h3>
<p>通过指令 <code>add_compile_options</code> 指令可以为所有编译器配置编译选项，同时对多个编译器有效</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_compile_options(-g -Wall -Werror)</span><br></pre></td></tr></table></figure>
<p>通过设置变量 <code>CMAKE_C_FLAGS</code> 可以配置 C 编译器的编译选项</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set(CMAKE_C_FLAGS &quot;$&#123;CMAKE_C_FLAGS&#125; -pipe -std=c99&quot;)</span><br></pre></td></tr></table></figure>
<p>而设置变量 <code>CMAKE_CXX_FLAGS</code> 可以配置 C++ 编译器的选项</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set(CMAKE_CXX_FLAGS &quot;$&#123;CMAKE_CXX_FLAGS&#125; -pipe -std=c++11&quot;)</span><br></pre></td></tr></table></figure>
<h3 id="配置编译类型">配置编译类型</h3>
<p>通过设置变量 <code>CMAKE_BUILD_TYPE</code> 来配置编译类型，可以设置为 <code>Debug</code> ， <code>Release</code> ， <code>RelWithDebInfo</code> ， <code>MinSizeRel</code> 等</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set(CMAKE_BUILD_TYPE Debug)</span><br></pre></td></tr></table></figure>
<p>也可以在执行 <code>cmake</code> 命令的时候通过参数 <code>-D</code> 来指定， <code>cmake</code> 会检查是否有对应编译类型的编译选项，如果有就将它的内容追加到其中</p>
<p>对于不同的编译类型可以设置不同的编译选项，比如对于 <code>Debug</code> 类型，开启调试信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set(CMAKE_C_FLAGS_DEBUG &quot;$&#123;CMAKE_C_FLAGS_DEBUG&#125; -g&quot;)</span><br><span class="line">set(CMAKE_CXX_FLAGS_DEBUG &quot;$&#123;CMAKE_CXX_FLAGS_DEBUG&#125; -g&quot;)</span><br></pre></td></tr></table></figure>
<h3 id="添加全局宏定义">添加全局宏定义</h3>
<p>通过命令 <code>add_definitions</code> 可以添加全局的宏定义，在源代码中就可以通过判断不同的宏定义来实现相应的代码逻辑，例如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_definitions(-DDEBUG -DREAL_COOL_ENGINEER)</span><br></pre></td></tr></table></figure>
<h3 id="添加include目录">添加include目录</h3>
<p>通过命令 <code>include_directories</code> 来设置头文件的搜索目录</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">include_directories(.) # 表示所有的头文件</span><br><span class="line">include_directories(inc/)</span><br></pre></td></tr></table></figure>
<h3 id="编译目标文件">编译目标文件</h3>
<p>一般来说，编译目标的类型一般有静态库，动态库和可执行文件，编写 <code>CMakeLists.txt</code> 主要包括两步</p>
<ul>
<li>编译：确定编译目标所需要的源文件</li>
<li>链接：确定链接的时候需要依赖的额外的库</li>
</ul>
<h3 id="编译生成库文件">编译生成库文件</h3>
<p>将项目目录路径下的源文件编译为静态库，需要获取编译此静态库需要的文件列表，可以使用<code>set</code>命令，或者<code>file</code>命令来进行设置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">file(GLOB_RECURSE FUNCTION_LIB_SRC /function/*.c)</span><br><span class="line"># set(FUNCTION_LIB_SRC /function/*.c)</span><br><span class="line">add_library(function_lib STATIC $&#123;FUNCTION_LIB_SRC &#125;)</span><br></pre></td></tr></table></figure>
<p>其中使用 <code>add_library</code> 指令编译名为 <code>function_lib</code> 的静态库，第二个参数表示库的类型， <code>STATIC</code> 表示静态链接库， <code>SHARED</code> 表示动态链接库</p>
<h3 id="编译可执行文件">编译可执行文件</h3>
<p>通过 <code>add_executable</code> 命令来向构建系统中添加一个可执行构建目标，指定编译需要的源文件。但是对于可执行文件来说，有时候还会依赖其它的库则需要使用 <code>target_link_libraries</code> 命令来声明构建此可执行文件需要链接的库</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add_executable(demo main.c)</span><br><span class="line">target_link_libraries(demo function_lib)</span><br></pre></td></tr></table></figure>
<h2 id="cmake模块化构建">CMake模块化构建</h2>
<p><code>CMakeLists.txt</code> 是定义一个目录的构建系统，所谓的模块化构建是分别为每一个子模块目录编写一个 <code>CMakeLists.txt</code> 文件，并且在其上层目录中导入子目录构建系统生成对应的目标，以便在上层目录中使用</p>
<p>这里使用的是一个 <code>cmake</code> 模板的开源项目 <a target="_blank" rel="noopener" href="https://gitee.com/RealCoolEngineer/cmake-template">cmake-template-gitee</a></p>
<p>在这个项目中，将 <code>math</code> 目录视为子模块，为其单独定义构建系统，而整个项目的编译依赖于 <code>math</code> 模块的编译结果来生成其它目标文件</p>
<h3 id="定义子目录的构建系统">定义子目录的构建系统</h3>
<p>在需要构建的子目录下创建一个 <code>CMakeLists.txt</code> 文件，在其中写入的内容只需要<strong>编译构建库文件</strong>，以及针对对外提供的接口的功能进行测试就行</p>
<p>对于子目录，也有自己的 <code>project</code> 指令，同时可以指定自己的版本号</p>
<p><code>aux_source_directory</code> 可以搜索指定目录（第一个参数）下的所有源文件，将源文件的列表保存到指定的变量（第二个参数）</p>
<p>在 <code>src/math</code> 目录下新建  <code>CMakeLists.txt</code> 文件，写入内容，将其编译为一个静态链接库</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">project(CMakeTemplateMath VERSION 0.0.1 LANGUAGES C CXX)</span><br><span class="line"></span><br><span class="line">aux_source_directory(. MATH_SRC)</span><br><span class="line">message(&quot;MATH_SRC: $&#123;MATH_SRC&#125;&quot;)</span><br><span class="line"></span><br><span class="line">add_library(math STATIC $&#123;MATH_SRC&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="包含子目录">包含子目录</h3>
<p>使用 <code>add_subdirectory</code> 命令可以包含一个子目录的构建系统，如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_subdirectory(dir [binary_dir] [EXCLUDE_FROM_ALL])</span><br></pre></td></tr></table></figure>
<p>其中</p>
<ol>
<li><code>dir</code> 就是需要包含的目标目录，该目录下必须存在一个 <code>CMakeLists.txt</code> 文件，一般相对于当前的 <code>CMakeLists.txt</code> 的目录路径，也可以是绝对路径</li>
<li><code>binary_dir</code> 是可选的参数，用于指定子构建系统输出文件的路径，相对于当前的 <code>binary_tree</code> ，也可以是绝对路径。如果 <code>dir</code> 是当前目录的子目录，那 <code>binary_dir</code> 是不做任何相对路径展开的 <code>dir</code> ，但是如果 <code>dir</code> 不是当前的子目录，必须指定 <code>binary_dir</code> ， 从而 <code>cmake</code> 才能确定文件的生成目录</li>
<li><code>EXCLUDE_FROM_ALL</code> 如果指定了，那子路径下的目标默认不会被包含到父路径的 ALL 目标里，并且也会被排除在工程文件之外，但是如果在父级项目显式声明依赖子目录的目标文件，那么对应的目标文件还是会被构建以满足父级项目的依赖需求</li>
</ol>
<p>可以在根目录下的 <code>CMakeLists.txt</code> 写入命令来链接编译的静态库</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add_subdirectory(src/c/math)</span><br><span class="line">add_executable(demo src/c/main.c)</span><br><span class="line">target_link_libraries(demo math)</span><br></pre></td></tr></table></figure>
<p>而且此时构建和编译的命令没有任何改变，依旧是在终端中输入 <code>cmake</code> 指令</p>
<h2 id="导入目标文件">导入目标文件</h2>
<p>上述中所用的 <code>add_subdirectory</code> 方法实际上就是通过源文件来构建项目所依赖的目标文件，但是在 <code>cmake</code> 中也可以通过命令导入已经编译好的目标文件</p>
<h3 id="导入库文件">导入库文件</h3>
<p>使用 <code>add_library</code> 指令可以通过指定 <code>IMPORTED</code> 选项表明是一个导入的库文件，通过 <code>set_property</code> 设置属性来指明路径</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add_library(math STATIC IMPORTED)</span><br><span class="line">set_property(TARGET math PROPERTY </span><br><span class="line">						IMPORTED_LOCATION &quot;./lib/libmath.a&quot;)</span><br></pre></td></tr></table></figure>
<p>也可以使用 <code>find_library</code> 命令来查找，比如在 <code>lib</code> 目录下查找 <code>math</code> 的 <code>Realse</code> 版本和 <code>Debug</code> 版本</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">find_library(LIB_MATH_DEBUG mathd HINTS &quot;./lib&quot;)</span><br><span class="line">find_library(LIB_MATH_RELEASE math HINTS &quot;./lib&quot;)</span><br></pre></td></tr></table></figure>
<p>可以通过指令 <code>set_target_properties</code> 来设置不同的编译选项，例如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set_target_properties(math PROPERTIES</span><br><span class="line">  IMPORTED_LOCATION &quot;$&#123;LIB_MATH_RELEASE&#125;&quot;</span><br><span class="line">  IMPORTED_LOCATION_DEBUG &quot;$&#123;LIB_MATH_DEBUG&#125;&quot;</span><br><span class="line">  IMPORTED_CONFIGURATIONS &quot;RELEASE;DEBUG&quot;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>导入之后，就可以将该库链接到其它目标上，但是导入该库的目标不能被 <code>install</code></p>
<h3 id="导入可执行文件">导入可执行文件</h3>
<p>在 <code>add_executable</code> 通过指定 <code>IMPORTED</code> 来指定可执行文件是外部导入的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add_executable(demo IMPORTED)</span><br><span class="line">set_property(TARGET demo PROPERTY</span><br><span class="line">             IMPORTED_LOCATION &quot;./bin/demo&quot;)</span><br></pre></td></tr></table></figure>
<h2 id="库依赖">库依赖</h2>
<p>主要是对于 <code>target_link_libraries</code> 命令的几个关键字，就是目标文件依赖项的使用范围，对于两个动态链接库 <code>[a.so](http://a.so)</code> 和 <code>b.so</code></p>
<ul>
<li><code>PRIVATE</code> 就是 <code>a</code> 使用了 <code>b</code> ，但是并不对外暴漏 <code>b</code> 的接口</li>
<li><code>INTERFACE</code> 就是 <code>a</code> 未使用 <code>b</code> ，但是对外暴漏 <code>b</code> 的接口</li>
<li><code>PUBLIC</code> 就是 <code>a</code> 使用了 <code>b</code> 并且对外暴漏 <code>b</code> 的接口</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">target_link_libraries(a PRIVATE/INTERFACE/PUBLIC b)</span><br><span class="line">target_include_directories(a PRIVATE/INTERFACE/PUBLIC b)</span><br></pre></td></tr></table></figure>
<h2 id="安装">安装</h2>
<h3 id="install指令"><strong>install指令</strong></h3>
<p>安装时使用 <code>install</code> 指令，用于指定一个项目的安装规则，命令格式如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">install</span>(TARGETS &lt;target&gt;... [...])</span><br><span class="line"><span class="built_in">install</span>(&#123;FILES | PROGRAMS&#125; &lt;file&gt;... [...])</span><br><span class="line"><span class="built_in">install</span>(DIRECTORY &lt;dir&gt;... [...])</span><br><span class="line"><span class="built_in">install</span>(SCRIPT &lt;file&gt; [...])</span><br><span class="line"><span class="built_in">install</span>(CODE &lt;code&gt; [...])</span><br><span class="line"><span class="built_in">install</span>(EXPORT &lt;<span class="keyword">export</span>-name&gt; [...])</span><br></pre></td></tr></table></figure>
<p>可以看出 <code>install</code> 命令可以安装的目标类型为：构建目标、文件、程序、目录等，对应的关键字后面跟上对应要安装的目标，安装不同目标时有一些通用的关键字<br>
<strong>DESTINATION</strong></p>
<p>就是安装对象的目标安装路径，可以是绝对路径，也可以是相对路径</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">install(TARGETS function_lib</span><br><span class="line">        RUNTIME DESTINATION bin</span><br><span class="line">        LIBRARY DESTINATION lib</span><br><span class="line">        ARCHIVE DESTINATION lib)</span><br></pre></td></tr></table></figure>
<p>其中</p>
<ul>
<li><code>TARGETS</code> 用于指定需要安装的目标</li>
<li><code>RUNTIME DESTINATION</code> 指定可执行文件的安装路径</li>
<li><code>LIBRARY DESTINATION</code> 指定共享库文件的安装路径</li>
<li><code>ARCHIVE DESTINATION</code> 指定静态库文件的安装路径</li>
</ul>
<p>如果指定 <code>CMAKE_INSTALL_PREFIX</code> 目录之后，那库文件将会被安装在对应目录下的 <code>lib</code> 文件夹中，可执行文件将会被安装在对应目录下的 <code>bin</code> 文件夹中，不同类型的目标文件安装到不同子目录。需要注意的是， <code>CMAKE_INSTALL_PREFIX</code> 在不同的系统上会有不同的默认值，使用时最好显式指定</p>
<p>头文件也可以使用上述的命令安装</p>
<p><strong>CONFIGURATIONS</strong></p>
<p>为不同的配置设置不同的安装规则，例如对于 <code>Debug</code> 和 <code>Release</code> 配置不同的安装路径，如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">install</span>(TARGETS target</span><br><span class="line">        CONFIGURATIONS Debug</span><br><span class="line">        RUNTIME DESTINATION Debug/bin)</span><br><span class="line"><span class="built_in">install</span>(TARGETS target</span><br><span class="line">        CONFIGURATIONS Release</span><br><span class="line">        RUNTIME DESTINATION Release/bin)</span><br></pre></td></tr></table></figure>
<p><strong>PERMISSIONS</strong></p>
<p>设置安装目标权限，接受的是一个权限关键字列表，例如</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">install</span>(TARGETS target</span><br><span class="line">        RUNTIME PERMISSIONS OWNER_READ OWNER_WRITE OWNER_EXECUTE)</span><br></pre></td></tr></table></figure>
<h3 id="安装构建目标"><strong>安装构建目标</strong></h3>
<p>安装一个构建好的目标，命令格式为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">install(TARGETS function_lib</span><br><span class="line">        RUNTIME DESTINATION bin</span><br><span class="line">        LIBRARY DESTINATION lib</span><br><span class="line">        ARCHIVE DESTINATION lib)</span><br></pre></td></tr></table></figure>
<p>完整的命令格式为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">install(TARGETS targets... [EXPORT &lt;export-name&gt;]</span><br><span class="line">        [[ARCHIVE|LIBRARY|RUNTIME|OBJECTS|FRAMEWORK|PRIVATE_HEADER|PUBLIC_HEADER|RESOURCE]</span><br><span class="line">         [DESTINATION &lt;dir&gt;]</span><br><span class="line">         [PERMISSIONS permissions...]</span><br><span class="line">         [CONFIGURATIONS [Debug|Release|...]]</span><br><span class="line">         [COMPONENT &lt;component&gt;]</span><br><span class="line">         [NAMELINK_COMPONENT &lt;component&gt;]</span><br><span class="line">         [OPTIONAL] [EXCLUDE_FROM_ALL]</span><br><span class="line">         [NAMELINK_ONLY|NAMELINK_SKIP]</span><br><span class="line">        ] [...]</span><br><span class="line">        [INCLUDES DESTINATION [&lt;dir&gt; ...]]</span><br><span class="line">        )</span><br></pre></td></tr></table></figure>
<p>其中参数中的<code>TARGET</code>可以是很多种目标文件，最常见的是通过 <code>ADD_EXECUTABLE</code> 或者 <code>ADD_LIBRARY</code> 定义的目标文件，即可执行二进制，动态库，静态库</p>
<table>
<thead>
<tr>
<th>目标文件</th>
<th>内容</th>
<th>安装目录变量</th>
<th>默认安装文件夹</th>
</tr>
</thead>
<tbody>
<tr>
<td>ARCHIVE</td>
<td>静态库</td>
<td>${CMAKE_INSTALL_LIBDIR}</td>
<td>lib</td>
</tr>
<tr>
<td>LIBRARY</td>
<td>动态库</td>
<td>${CMAKE_INSTALL_LIBDIR}</td>
<td>lib</td>
</tr>
<tr>
<td>RUNTIME</td>
<td>可执行二进制文件</td>
<td>${CMAKE_INSTALL_BINDIR}</td>
<td>bin</td>
</tr>
<tr>
<td>PUBLIC_HEADER</td>
<td>与库关联的PUBLIC头文件</td>
<td>${CMAKE_INSTALL_INCLUDEDIR}</td>
<td>include</td>
</tr>
<tr>
<td>PRIVATE_HEADER</td>
<td>与库关联的PRIVATE头文件</td>
<td>${CMAKE_INSTALL_INCLUDEDIR}</td>
<td>include</td>
</tr>
</tbody>
</table>
<h3 id="安装目录"><strong>安装目录</strong></h3>
<p>安装一个目录，一般用于将头文件安装到目标路径，实际中，一般将需要安装的头文件放在一个特定的目录下，然后直接安装整个目录，如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">install(DIRECTORY &quot;$&#123;PROJECT_SOURCE_DIR&#125;/include/&quot;</span><br><span class="line">	      DESTINATION &quot;$&#123;CMAKE_INSTALL_INCLUDEDIR&#125;&quot;)</span><br></pre></td></tr></table></figure>
<p>更加完整的命令格式为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">install(DIRECTORY dirs...</span><br><span class="line">        TYPE &lt;type&gt; | DESTINATION &lt;dir&gt;</span><br><span class="line">        [FILES_MATCHING]</span><br><span class="line">        [[PATTERN &lt;pattern&gt; | REGEX &lt;regex&gt;]</span><br><span class="line">         [EXCLUDE] [PERMISSIONS permissions...]])</span><br></pre></td></tr></table></figure>
<p><strong>TYPE/DESTINATION</strong></p>
<p>安装目录必须指定安装的目录类型 <code>TYPE</code> 或者安装的目标路径 <code>DESTINATION</code> ，但是不可以同时指定， <code>TYPE</code> 用于指定安装的目录中的文件类型，并且 <code>cmake</code> 会自动按照类型分配安装位置，不同类型对应的安装路径如下</p>
<table>
<thead>
<tr>
<th>TYPE类型</th>
<th>安装目录变量</th>
<th>默认安装文件夹</th>
</tr>
</thead>
<tbody>
<tr>
<td>BIN</td>
<td>${CMAKE_INSTALL_BINDIR}</td>
<td>bin</td>
</tr>
<tr>
<td>SBIN</td>
<td>${CMAKE_INSTALL_SBINDIR}</td>
<td>sbin</td>
</tr>
<tr>
<td>LIB</td>
<td>${CMAKE_INSTALL_LIBDIR}</td>
<td>lib</td>
</tr>
<tr>
<td>INCLUDE</td>
<td>${CMAKE_INSTALL_INCLUDEDIR}</td>
<td>include</td>
</tr>
<tr>
<td>SYSCONF</td>
<td>${CMAKE_INSTALL_SYSCONFDIR}</td>
<td>etc</td>
</tr>
<tr>
<td>SHAREDSTATE</td>
<td>${CMAKE_INSTALL_SHARESTATEDIR}</td>
<td>com</td>
</tr>
<tr>
<td>LOCALSTATE</td>
<td>${CMAKE_INSTALL_LOCALSTATEDIR}</td>
<td>var</td>
</tr>
<tr>
<td>RUNSTATE</td>
<td>${CMAKE_INSTALL_RUNSTATEDIR}</td>
<td>/run</td>
</tr>
<tr>
<td>DATA</td>
<td>${CMAKE_INSTALL_DATADIR}</td>
<td></td>
</tr>
<tr>
<td>INFO</td>
<td>${CMAKE_INSTALL_INFODIR}</td>
<td>/info</td>
</tr>
<tr>
<td>LOCALE</td>
<td>${CMAKE_INSTALL_LOCALEDIR}</td>
<td>/locale</td>
</tr>
<tr>
<td>MAN</td>
<td>${CMAKE_INSTALL_MANDIR}</td>
<td>/man</td>
</tr>
<tr>
<td>DOC</td>
<td>${CMAKE_INSTALL_DOCDIR}</td>
<td>/doc</td>
</tr>
</tbody>
</table>
<p>也可以选择使用 <code>DESTINATION</code> 显式指定安装目录</p>
<p><strong>FILES_MATCHING</strong></p>
<p>安装目录的时候默认会安装所有的文件，如果使用 <code>FILES_MATCHING</code> 关键字（在第一个 <code>PATTERN</code> 或者 <code>REGEX</code> 之前），则表示必须要满足对应的模式或者正则的文件才能被安装</p>
<p>例如，对于安装一个目录下的头文件，但是头文件与源文件混合，如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">install(DIRECTORY src/ DESTINATION include/</span><br><span class="line">        FILES_MATCHING PATTERN &quot;*.h&quot;)</span><br></pre></td></tr></table></figure>
<p><strong>PATTERN/REGEX</strong></p>
<ul>
<li><code>PATTERN</code> 文件名完全一致才会被安装</li>
<li><code>REGEX</code> 通过正则表达式匹配之后才会安装</li>
</ul>
<p>在这两个表达式后面还可以加上 <code>EXCLUDE</code> 表示反选，或者使用 <code>PERMISSIONS</code> 指定匹配的目标文件的权限</p>
<h3 id="安装文件">安装文件</h3>
<p>与安装目录类似，命令格式为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">install(&lt;FILES|PROGRAMS&gt; files...</span><br><span class="line">        TYPE &lt;type&gt; | DESTINATION &lt;dir&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>FILE</code> 指的是文件的默认权限是一般文件</li>
<li><code>PROGRAMS</code> 指的是文件为可执行文件，默认有可执行权限</li>
</ul>
<h3 id="自定义安装脚本">自定义安装脚本</h3>
<p>使用 <code>install</code> 命令可以在安装的时候执行自定义脚本，格式为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">install([[SCRIPT &lt;file&gt;] [CODE &lt;code&gt;]]</span><br><span class="line">        [COMPONENT &lt;component&gt;] [EXCLUDE_FROM_ALL] [...])</span><br></pre></td></tr></table></figure>
<p>其中</p>
<ul>
<li><code>SCRIPT</code> 指定安装时需要执行的脚本</li>
<li><code>CODE</code> 指定的是 <code>cmake</code> 的指令，也就是在安装期间执行的 <code>cmake</code> 指令</li>
</ul>
<h3 id="执行安装">执行安装</h3>
<p>在构建编译完成之后，执行命令安装</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake --build . --target install</span><br></pre></td></tr></table></figure>
<p>针对 <code>make</code> 工具，安装的指令为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make install</span><br></pre></td></tr></table></figure>
<p>在 <code>cmake-3.15</code> 之后，可以使用如下指令安装</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake --install . --prefix &quot;../output&quot;</span><br></pre></td></tr></table></figure>
<p>其中 <code>--install</code> 指定构建目录， <code>--prefix</code> 指定安装路径，指定之后会覆盖安装路径变量 <code>CMAKE_INSTALL_PREFIX</code></p>
<h2 id="打包">打包</h2>
<h3 id="cpack">CPack</h3>
<p>使用打包功能，需要先使用命令 <code>include(CPack)</code> 启用相关的功能，构建之后会在构建目录下生成两个 <code>cpack</code> 配置文件，<code>CPackConfig.cmake</code>和<code>CPackSourceConfig.cmake</code> ，分别对应着 <code>package</code> 和 <code>package_source</code></p>
<p>在执行构建编译之后使用 <code>cpack</code> 命令行工具进行打包安装。可以使用 <code>-G</code> 参数指定生成器，常用的为 <code>ZIP</code> ， <code>TGZ</code> ， <code>7Z</code> 等，也可以同时指定多种类型，利用 <code>CMake</code> 语法中的列表，在构建目录下使用如下指令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cpack -G ZIP --config CPackConfig.cmake</span><br><span class="line">cpack -G ZIP --config CPackSourceConfig.cmake</span><br></pre></td></tr></table></figure>
<p>对于 <code>cmake</code> 指令，可以在构建目录下使用如下指令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmake --build . --target package</span><br><span class="line">cmake --build . --target package_source</span><br></pre></td></tr></table></figure>
<p>对于 <code>make</code> 工具，也可以使用命令 <code>make package</code> 或者 <code>make package_source</code> 进行打包安装</p>
<h3 id="内置变量">内置变量</h3>
<p>打包的内容就是 <code>install</code> 指令安装的内容，还需要设置一些变量</p>
<table>
<thead>
<tr>
<th>变量</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>CPACK_GENERATOR</td>
<td>打包使用的工具</td>
</tr>
<tr>
<td>CPACK_OUTPUT_FILE_PREFIX</td>
<td>打包安装的路径前缀，如果是相对路径，那就是相对于构建路径</td>
</tr>
<tr>
<td>CPACK_INSTALL_PREFIX</td>
<td>打包压缩包的内部目录</td>
</tr>
<tr>
<td>CPACK_PACKAGE_FILE_NAME</td>
<td>打包压缩包的名称，由CPACK_PACKAGE_NAME，CPACK_PACKAGE_VERSION，CPACK_SYSTEM_NAME三部分构成</td>
</tr>
<tr>
<td>CPACK_SET_DESTDIR</td>
<td>如果没有 CPACK_SET_DESTDIR，CPack 使用 CPACK_PACKAGING_INSTALL_PREFIX 作为前缀，而设置 CPACK_SET_DESTDIR 后，CPack 将使用 CMAKE_INSTALL_PREFIX 作为前缀。</td>
</tr>
<tr>
<td>CPACK_OUTPUT_CONFIG_FILE</td>
<td>配置文件，默认为CPackConfig.cmake</td>
</tr>
<tr>
<td>CPACK_PACKAGE_VERSION</td>
<td>默认为项目版本号，默认值为 project 所设置的版本号，如果没有设置就是 cmake 的默认值</td>
</tr>
</tbody>
</table>
<p><code>cpack</code> 有一些参数是可以覆盖 <code>CMakeLists.txt</code> 中所设置的参数的，所以一般来说以上变量的设置在 <code>include(CPack)</code> 之前</p>
<h2 id="编译过程">编译过程</h2>
<p>实际上 <code>cmake</code> 的编译过程中的命令与 <code>gcc</code> 的编译过程是有关联的</p>
<h3 id="预处理">预处理</h3>
<p>可以使用下列指令定义一个宏定义</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_definitions(-Dname)</span><br></pre></td></tr></table></figure>
<h3 id="编译">编译</h3>
<p>使用如下指令给编译过程添加编译选项</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_compile_options(-O0 -g ...)</span><br></pre></td></tr></table></figure>
<p>需要注意的是，因为CMake的构建目标必须是库或者可执行文件，并没有命令仅生成 <code>.o</code> 文件。如果使用生成器表达式的话，对于多个编译选项，需要使用双引号把生成器表达式括起来，且在选项之间使用分号隔开</p>
<h3 id="链接">链接</h3>
<p>使用如下指令来进行指定编译过程中的链接参数</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_link_options(-pthread ...)</span><br></pre></td></tr></table></figure>
<h2 id="合并静态库">合并静态库</h2>
<h3 id="基于cmake">基于cmake</h3>
<p><code>**add_custom_command</code>**</p>
<p>向目标添加规则，并通过执行命令生成输出。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">add_custom_command(OUTPUT output1 [output2 ...]</span><br><span class="line">                   COMMAND command1 [ARGS] [args1...]</span><br><span class="line">                   [COMMAND command2 [ARGS] [args2...] ...]</span><br><span class="line">                   [MAIN_DEPENDENCY depend]</span><br><span class="line">                   [DEPENDS [depends...]]</span><br><span class="line">                   [BYPRODUCTS [files...]]</span><br><span class="line">                   [IMPLICIT_DEPENDS &lt;lang1&gt; depend1</span><br><span class="line">                                    [&lt;lang2&gt; depend2] ...]</span><br><span class="line">                   [WORKING_DIRECTORY dir]</span><br><span class="line">                   [COMMENT comment]</span><br><span class="line">                   [DEPFILE depfile]</span><br><span class="line">                   [JOB_POOL job_pool]</span><br><span class="line">                   [VERBATIM] [APPEND] [USES_TERMINAL]</span><br><span class="line">                   [COMMAND_EXPAND_LISTS])</span><br></pre></td></tr></table></figure>
<p>其中</p>
<ul>
<li>OUTPUT：指定命令预期生成的输出文件。3.20版本以后，输出参数可使用一组受限的生成器表达式。</li>
<li>COMMAND：指定生成时要执行的命令行。</li>
<li>MAIN_DEPENDENCY：指定命令的主输入源文件。类似于DEPENDS。</li>
<li>DEPENDS：指定命令所依赖的文件。</li>
<li>BYPRODUCTS：指定命令预期生成的文件，但其修改时间可能比依赖项的新，也可能不比依赖项的新。</li>
<li>IMPLICIT_DEPENDS：请求扫描输入文件的隐式依赖项。此选项不能与DEPFILE选项同时指定。</li>
<li>WORKING_DIRECTORY：指定在何处执行命令。</li>
<li>COMMENT：指定在生成时执行命令之前显示的消息。</li>
<li>DEPFILE：指定保存自定义命令依赖项的depfile。它通常由自定义命令本身发出。仅当生成器支持此关键字时，才能使用此关键字。</li>
<li>JOB_POOL：为Ninja生成器指定一个池。</li>
<li>VERBATIM：对于构建工具，命令的所有参数都将被正确转义，以便被调用的命令接收到的每个参数不变。请注意，在add_custom_command甚至看到参数之前，CMake语言处理器仍然使用一级转义。建议使用VERBATIM，因为它可以保证正确的行为。如果不指定VERBATIM，则行为是依赖于平台的，因为CMake没有针对于特定工具中特殊字符的保护措施。</li>
<li>APPEND：将COMMAND和DEPENDS 附加到第一个指定输出的自定义命令。</li>
<li>USES_TERMINAL：如果可能，该命令将被授予直接访问终端的权限。</li>
<li>COMMAND_EXPAND_LISTS：命令参数中的列表将展开，包括使用生成器表达式创建的列表</li>
</ul>
<p><strong><code>add_custom_target</code></strong></p>
<p>在很多时候，需要在<code>cmake</code>中创建一些目标，如<code>clean</code>、<code>copy</code>等等，这就需要通过<code>add_custom_target</code>来指定。同时，<code>add_custom_command</code>可以用来完成对<code>add_custom_target</code>生成的<code>target</code>的补充</p>
<p>用于增加一个没有输出的目标，使得它总是被构建</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">add_custom_target(Name [ALL] [command1 [args1...]]</span><br><span class="line">                  [COMMAND command2 [args2...] ...]</span><br><span class="line">                  [DEPENDS depend depend depend ... ]</span><br><span class="line">                  [BYPRODUCTS [files...]]</span><br><span class="line">                  [WORKING_DIRECTORY dir]</span><br><span class="line">                  [COMMENT comment]</span><br><span class="line">                  [JOB_POOL job_pool]</span><br><span class="line">                  [VERBATIM] [USES_TERMINAL]</span><br><span class="line">                  [COMMAND_EXPAND_LISTS]</span><br><span class="line">                  [SOURCES src1 [src2...]])</span><br></pre></td></tr></table></figure>
<p>其中</p>
<ul>
<li>ALL：表明该目标会被添加到默认的构建目标，使得它每次都被运行</li>
<li>COMMAND：指定要在构建时执行的命令行；</li>
<li>DEPENDS：指定命令所依赖的文件；</li>
<li>COMMENT：在构建时执行命令之前显示给定消息；</li>
<li>WORKING_DIRECTORY：使用给定的当前工作目录执行命令。如果它是相对路径，它将相对于对应于当前源目录的构建树目录；</li>
<li>BYPRODUCTS：指定命令预期产生的文件。</li>
</ul>
<p><strong>具体流程</strong></p>
<ol>
<li>
<p>合并静态库</p>
<p>利用 <code>add_custom_command</code> 配合 <code>add_custom_target</code> 命令，将 <code>liba.a</code> 和 <code>libb.a</code> 合并为 <code>libmerge.a</code></p>
<p>对于 macos 系统中，在根目录下的 <code>CMakeLists.txt</code> 文件中写入</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add_custom_command(OUTPUT libmerge.a</span><br><span class="line">									COMMAND libtool -static -o libmerge.a $&lt;TARGET_FILE:math&gt; $&lt;TARGET_FILE:nn&gt;</span><br><span class="line">									DEPENDS a b)</span><br></pre></td></tr></table></figure>
<p>对于其它系统中，在根目录下的 <code>CMakeLists.txt</code> 文件中写入</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add_custom_command(OUTPUT libmerge.a</span><br><span class="line">							    COMMAND ar crsT libmerge.a $&lt;TARGET_FILE:math&gt; $&lt;TARGET_FILE:nn&gt;</span><br><span class="line">							    DEPENDS a b)</span><br></pre></td></tr></table></figure>
<p>还需要在后面添加一句，且必须得有</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_custom_target(_merge ALL DEPENDS libmerge.a)</span><br></pre></td></tr></table></figure>
<p>在合并静态库时，需要知道每个静态库的路径，在 <code>cmake</code> 中，目标静态库 <code>a</code> 的路径可以通过生成器表达式 <code>$&lt;TARGET_FILE:a&gt;</code> 获取</p>
<p>如果使用 <code>find_library</code>  查找到的静态库，这时候就 <code>DEPENDS</code> 不需要加入 c ，如下</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find_library(LIB_C c HINTS $&#123;SEARCH_PATH&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>导入合并的静态库</p>
<p>把静态库导入，并且链接到可执行程序使用</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">add_library(merge STATIC IMPORTED GLOBAL)</span><br><span class="line">set_target_properties(merge PROPERTIES</span><br><span class="line">    IMPORTED_LOCATION $&#123;CMAKE_CURRENT_BINARY_DIR&#125;/libmerge.a</span><br><span class="line">)</span><br><span class="line">add_executable(main src/c/main.c)</span><br><span class="line">target_link_libraries(main PRIVATE merge)</span><br></pre></td></tr></table></figure>
<p>由于 <code>libmerge</code> 是由 <code>add_custom_command</code> 指定的输出，所以会标记为自动生成的文件 <code>GENERATED</code></p>
<p>链接项目中依赖于导入的静态库文件 <code>merge</code> ，而对于 <code>merge</code> 被指定了 <code>IMPORTED_LOCATION</code> ，也就是被指定为自动生成的，所以 cmake 就会等待 <code>libmerge.a</code> 生成之后再进行链接</p>
</li>
</ol>
<h3 id="其它方法">其它方法</h3>
<ol>
<li>
<p>方法1</p>
<p>先使用 <code>ar</code> 把静态库 <code>liba</code> 和 <code>libb</code> 拆解为多个 <code>.o</code> 文件</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ar x liba.a</span><br><span class="line">ar x libb.a</span><br></pre></td></tr></table></figure>
<p>再把所有的 <code>.o</code> 文件打包为一个静态库</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ar crs libmerge.a *.o</span><br></pre></td></tr></table></figure>
<p>其中</p>
<ul>
<li><code>x</code> 拆解静态库文件为其包含的内容</li>
<li><code>c</code> 封装 <code>.o</code> 文件为静态库文件</li>
<li><code>r</code> 覆盖同名库文件或者创建新的目标库文件</li>
<li><code>s</code> 相当于对结果执行一次 <code>ranlib</code> 为静态库的内容添加索引，以此提高访问效率</li>
</ul>
</li>
<li>
<p>方法2</p>
<p>上述方法1中一个更简洁的表达</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ar crsT libmerge.a liba.a libb.a</span><br></pre></td></tr></table></figure>
<p>其中</p>
<ul>
<li><code>T</code> 表示将后续所有静态库中的 <code>.o</code> 文件打包到第一个参数指定的静态库文件中。如果不加该参数，得到的将会是后面几个 <code>.a</code> 文件的集合</li>
<li>可以使用 <code>ar -t</code> 查看打包的内容</li>
</ul>
</li>
<li>
<p>方法3</p>
<p>使用 MRI 脚本，首先写一个 MRI 脚本， <code>merge.mri</code> ，写入如下内容</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create libmerge.a</span><br><span class="line">addlib liba.a </span><br><span class="line">addlib libb.a</span><br><span class="line">save</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>然后使用命令</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ar -M &lt; merge.mri</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>方法</p>
<p>使用 <code>libtool</code> 命令</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">libtool -static -o libmerge.a liba.a libb.a</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>上述方法中，方法1，4适用于macos，方法1，2，3均适用于linux</p>
<h2 id="生成器表达式">生成器表达式</h2>
<p>就是再 <code>cmake</code> 生成构建系统时根据不同配置动态生成特定的内容，着就依赖于不同的条件。生成器表达式的格式为 <code>$&lt;...&gt;</code> ，可以嵌套，可以在很多构建目标的属性设置和特定的 <code>cmake</code> 指令中，并且在生成构建系统时表达式被展开，所以不能通过解析配置 <code>CMakeLists.txt</code> 阶段的 <code>message</code> 指令打印</p>
<h3 id="布尔生成器表达式">布尔生成器表达式</h3>
<p><strong>逻辑运算符</strong></p>
<ol>
<li><code>$&lt;BOOL:string&gt;</code> 如果字符串为空，0。不区分大小写的 <code>FALSE</code> ， <code>OFF</code> ， <code>N</code> ， <code>NO</code> ， <code>IGNORE</code> ， <code>NOTFOUND</code> 。或者区分大小写以 <code>-NOTFOUND</code> 结尾的字符串，则为 0，否则为 1</li>
<li><code>$&lt;AND:condition&gt;</code> 逻辑与， <code>condition</code> 是以逗号分割的条件列表</li>
<li><code>$&lt;OR:condition&gt;</code> 逻辑或</li>
<li><code>$&lt;NOT:condition&gt;</code> 逻辑非</li>
</ol>
<p><strong>字符串比较</strong></p>
<ol>
<li><code>$&lt;STREQUAL:str1, str2&gt;</code> 判断字符串是否相等</li>
<li><code>$&lt;EQUAL:val1, val2&gt;</code> 判断数值是否相等</li>
<li><code>$&lt;IN_LIST:str, list&gt;</code> 判断字符串是否在列表 <code>list</code> 中</li>
</ol>
<p><strong>变量查询</strong></p>
<ol>
<li><code>$&lt;TARGET_EXISTS:target&gt;</code> 判断目标是否存在</li>
<li><code>$&lt;CONFIG:cfg&gt;</code> 判断编译类型配置是否包含在 <code>cfg</code> 列表中，不区分大小写</li>
<li><code>$&lt;PLATFORM_ID:platform_ids&gt;</code> 判断cmake定义的平台ID是否包含在 <code>platform_ids</code> 列表中</li>
<li><code>$&lt;COMPILE_LANGUAGE:languages&gt;</code> 判断编译语言是否包含在 <code>languages</code> 列表中</li>
</ol>
<h3 id="字符串值生成器表达式">字符串值生成器表达式</h3>
<p>使用生成表达式的目的是生成特殊的字符串</p>
<p><strong>条件表达式</strong></p>
<p>主要是两种格式</p>
<ol>
<li><code>$&lt;condition:true_string&gt;</code> 如果条件为真，则结果为 <code>true_string</code> ，否则为空</li>
<li><code>$&lt;IF:condition,str1,str2&gt;</code> 如果条件为真，结果为 <code>str1</code> ，否则 <code>str2</code></li>
</ol>
<p><strong>转义字符</strong></p>
<p>由于有些字符有特殊含义，可能需要转义，例如</p>
<ul>
<li><code>$&lt;COMMA&gt;</code> 表示 <code>,</code></li>
<li><code>$&lt;SEMICOLON&gt;</code> 表示 <code>;</code></li>
</ul>
<p><strong>字符串操作</strong></p>
<ul>
<li><code>$&lt;LOWER_CASE:string&gt;</code> 将字符串转为小写</li>
<li><code>$&lt;UPPER_CASE:string&gt;</code> 将字符串转为大写</li>
</ul>
<p><strong>获取变量值</strong></p>
<p>与上文中的变量查询很类似</p>
<ol>
<li><code>$&lt;CONFIG&gt;</code> 获取变量值</li>
<li><code>$&lt;CONFIG:cfgs&gt;</code> 判断是否存在于列表中</li>
</ol>
<p><strong>编译目标信息</strong></p>
<p>更多信息：<a target="_blank" rel="noopener" href="https://cmake.org/cmake/help/latest/manual/cmake-generator-expressions.7.html#target-dependent-queries">target-dependent-queries</a></p>
<p>编译目标：是指通过 <code>add_execuate()</code> 和 <code>add_library()</code> 指令生成的目标文件和库文件</p>
<ol>
<li><code>$&lt;TARGET_FILE:tgt&gt;</code> 获取编译目标 <code>tgt</code> 的文件路径</li>
<li><code>$&lt;TARGET_FILE_NAME:tgt&gt;</code> 获取编译目标的文件名</li>
<li><code>$&lt;TARGET_FILE_BASE_NAME:tgt&gt;</code> 获取编译目标的基础名字，也就是文件名去除前缀和扩展名</li>
</ol>
<h3 id="调试信息">调试信息</h3>
<ol>
<li>
<p>通过输出到文件的方式，在 <code>cmake</code> 执行完之后检查是否符合预期</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file(GENERATE OUTPUT &quot;./ouput.txt&quot; CONTENT &quot;$&lt;$&lt;CONFIG:Debug&gt;:-g;-O0&gt;,$&lt;PLATFORM_ID&gt;\n&quot;)</span><br></pre></td></tr></table></figure>
<p>执行完 <code>cmake</code> 之后在文件中得到生成器表达式的内容</p>
</li>
<li>
<p>添加一个自定义目标</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_custom_target(gentest COMMAND $&#123;CMAKE_COMMAND&#125; -E echo &quot;\&quot;$&lt;$&lt;CONFIG:Debug&gt;:-g;-O0&gt;,$&lt;PLATFORM_ID&gt;\&quot;&quot;)</span><br></pre></td></tr></table></figure>
<p>这里需要将双引号转义，以便确保生成器表达式展开之后为字符串</p>
<p>在执行 <code>cmake</code> 之后，可以使用 <code>make gentest</code> 命令输出到生成器表达式的内容</p>
</li>
</ol>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>落
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://luo25177.github.io/2024/04/02/CMakeLists%E7%BC%96%E5%86%99/" title="CMakeLists编写">https://luo25177.github.io/2024/04/02/CMakeLists编写/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/Blog_NexT/tags/Cpp/" rel="tag"># Cpp</a>
              <a href="/Blog_NexT/tags/C/" rel="tag"># C</a>
              <a href="/Blog_NexT/tags/cmake/" rel="tag"># cmake</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/Blog_NexT/2024/04/02/makefile%E7%BC%96%E5%86%99/" rel="prev" title="makefile编写">
      <i class="fa fa-chevron-left"></i> makefile编写
    </a></div>
      <div class="post-nav-item">
    <a href="/Blog_NexT/2024/04/02/GTest%E4%BD%BF%E7%94%A8/" rel="next" title="GTest使用">
      GTest使用 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ubuntu-%E4%B8%8A-cmake-%E7%9A%84%E6%9B%B4%E6%96%B0"><span class="nav-number">1.1.</span> <span class="nav-text">ubuntu 上 cmake 的更新</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#cmake-%E4%B8%80%E8%88%AC%E4%BD%BF%E7%94%A8%E6%B5%81%E7%A8%8B"><span class="nav-number">2.</span> <span class="nav-text">CMake 一般使用流程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%9F%E6%88%90%E6%9E%84%E5%BB%BA%E7%B3%BB%E7%BB%9F"><span class="nav-number">2.1.</span> <span class="nav-text">生成构建系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E6%9E%84%E5%BB%BA"><span class="nav-number">2.2.</span> <span class="nav-text">执行构建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E6%B5%8B%E8%AF%95-%E5%AE%89%E8%A3%85%E6%88%96%E6%89%93%E5%8C%85"><span class="nav-number">2.3.</span> <span class="nav-text">执行测试，安装或打包</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#cmake%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95"><span class="nav-number">3.</span> <span class="nav-text">CMake基础语法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E9%87%8A"><span class="nav-number">3.1.</span> <span class="nav-text">注释</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%99%AE%E9%80%9A%E5%8F%98%E9%87%8F"><span class="nav-number">3.2.</span> <span class="nav-text">普通变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#cache%E5%8F%98%E9%87%8F"><span class="nav-number">3.3.</span> <span class="nav-text">Cache变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="nav-number">3.4.</span> <span class="nav-text">环境变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5"><span class="nav-number">3.5.</span> <span class="nav-text">条件语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5"><span class="nav-number">3.6.</span> <span class="nav-text">循环语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0"><span class="nav-number">3.7.</span> <span class="nav-text">函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%8F"><span class="nav-number">3.8.</span> <span class="nav-text">宏</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E6%89%93%E5%8D%B0"><span class="nav-number">3.9.</span> <span class="nav-text">消息打印</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%97%E8%A1%A8%E6%93%8D%E4%BD%9C"><span class="nav-number">3.10.</span> <span class="nav-text">列表操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C"><span class="nav-number">3.11.</span> <span class="nav-text">文件操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E7%B3%BB%E7%BB%9F%E5%91%BD%E4%BB%A4"><span class="nav-number">3.12.</span> <span class="nav-text">执行系统命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E9%A1%B9%E7%9B%AE%E5%92%8C%E7%89%88%E6%9C%AC"><span class="nav-number">3.13.</span> <span class="nav-text">设置项目和版本</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E5%AE%9A%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%89%88%E6%9C%AC"><span class="nav-number">3.14.</span> <span class="nav-text">指定编程语言版本</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E7%BC%96%E8%AF%91%E9%80%89%E9%A1%B9"><span class="nav-number">3.15.</span> <span class="nav-text">配置编译选项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E7%BC%96%E8%AF%91%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.16.</span> <span class="nav-text">配置编译类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%BB%E5%8A%A0%E5%85%A8%E5%B1%80%E5%AE%8F%E5%AE%9A%E4%B9%89"><span class="nav-number">3.17.</span> <span class="nav-text">添加全局宏定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%BB%E5%8A%A0include%E7%9B%AE%E5%BD%95"><span class="nav-number">3.18.</span> <span class="nav-text">添加include目录</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6"><span class="nav-number">3.19.</span> <span class="nav-text">编译目标文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E7%94%9F%E6%88%90%E5%BA%93%E6%96%87%E4%BB%B6"><span class="nav-number">3.20.</span> <span class="nav-text">编译生成库文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6"><span class="nav-number">3.21.</span> <span class="nav-text">编译可执行文件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#cmake%E6%A8%A1%E5%9D%97%E5%8C%96%E6%9E%84%E5%BB%BA"><span class="nav-number">4.</span> <span class="nav-text">CMake模块化构建</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E5%AD%90%E7%9B%AE%E5%BD%95%E7%9A%84%E6%9E%84%E5%BB%BA%E7%B3%BB%E7%BB%9F"><span class="nav-number">4.1.</span> <span class="nav-text">定义子目录的构建系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%85%E5%90%AB%E5%AD%90%E7%9B%AE%E5%BD%95"><span class="nav-number">4.2.</span> <span class="nav-text">包含子目录</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%BC%E5%85%A5%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6"><span class="nav-number">5.</span> <span class="nav-text">导入目标文件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%BC%E5%85%A5%E5%BA%93%E6%96%87%E4%BB%B6"><span class="nav-number">5.1.</span> <span class="nav-text">导入库文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%BC%E5%85%A5%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6"><span class="nav-number">5.2.</span> <span class="nav-text">导入可执行文件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BA%93%E4%BE%9D%E8%B5%96"><span class="nav-number">6.</span> <span class="nav-text">库依赖</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%89%E8%A3%85"><span class="nav-number">7.</span> <span class="nav-text">安装</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#install%E6%8C%87%E4%BB%A4"><span class="nav-number">7.1.</span> <span class="nav-text">install指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%89%E8%A3%85%E6%9E%84%E5%BB%BA%E7%9B%AE%E6%A0%87"><span class="nav-number">7.2.</span> <span class="nav-text">安装构建目标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%89%E8%A3%85%E7%9B%AE%E5%BD%95"><span class="nav-number">7.3.</span> <span class="nav-text">安装目录</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%89%E8%A3%85%E6%96%87%E4%BB%B6"><span class="nav-number">7.4.</span> <span class="nav-text">安装文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AE%89%E8%A3%85%E8%84%9A%E6%9C%AC"><span class="nav-number">7.5.</span> <span class="nav-text">自定义安装脚本</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E5%AE%89%E8%A3%85"><span class="nav-number">7.6.</span> <span class="nav-text">执行安装</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%93%E5%8C%85"><span class="nav-number">8.</span> <span class="nav-text">打包</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#cpack"><span class="nav-number">8.1.</span> <span class="nav-text">CPack</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E7%BD%AE%E5%8F%98%E9%87%8F"><span class="nav-number">8.2.</span> <span class="nav-text">内置变量</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B"><span class="nav-number">9.</span> <span class="nav-text">编译过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%84%E5%A4%84%E7%90%86"><span class="nav-number">9.1.</span> <span class="nav-text">预处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E8%AF%91"><span class="nav-number">9.2.</span> <span class="nav-text">编译</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%93%BE%E6%8E%A5"><span class="nav-number">9.3.</span> <span class="nav-text">链接</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%88%E5%B9%B6%E9%9D%99%E6%80%81%E5%BA%93"><span class="nav-number">10.</span> <span class="nav-text">合并静态库</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8Ecmake"><span class="nav-number">10.1.</span> <span class="nav-text">基于cmake</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E5%AE%83%E6%96%B9%E6%B3%95"><span class="nav-number">10.2.</span> <span class="nav-text">其它方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%9F%E6%88%90%E5%99%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">11.</span> <span class="nav-text">生成器表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%83%E5%B0%94%E7%94%9F%E6%88%90%E5%99%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">11.1.</span> <span class="nav-text">布尔生成器表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%80%BC%E7%94%9F%E6%88%90%E5%99%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">11.2.</span> <span class="nav-text">字符串值生成器表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E8%AF%95%E4%BF%A1%E6%81%AF"><span class="nav-number">11.3.</span> <span class="nav-text">调试信息</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="落"
      src="/Blog_NexT/images/avatar.png">
  <p class="site-author-name" itemprop="name">落</p>
  <div class="site-description" itemprop="description">茶凉言尽，月上柳梢</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/Blog_NexT/archives/">
        
          <span class="site-state-item-count">121</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/Blog_NexT/categories/">
          
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/Blog_NexT/tags/">
          
        <span class="site-state-item-count">116</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Luo25177" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Luo25177" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:beloved25177@126.com" title="E-Mail → mailto:beloved25177@126.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2024 – 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">落</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">1.6m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">23:46</span>
  <img src="https://gcore.jsdelivr.net/gh/CNhuazhu/TuChuang4/blog/备案图标.png">
  <a href="http://www.beian.miit.gov.cn/" target="_blank">豫ICP备2024056598号-1</a>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/Blog_NexT/lib/anime.min.js"></script>
  <script src="/Blog_NexT/lib/velocity/velocity.min.js"></script>
  <script src="/Blog_NexT/lib/velocity/velocity.ui.min.js"></script>

<script src="/Blog_NexT/js/utils.js"></script>

<script src="/Blog_NexT/js/motion.js"></script>


<script src="/Blog_NexT/js/schemes/pisces.js"></script>


<script src="/Blog_NexT/js/next-boot.js"></script>




  




  
<script src="/Blog_NexT/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
